#!/usr/bin/env bun
/**
 * Test suite to verify Zod validation is working in the XML parsing pipeline
 */

import { describe, test, expect } from 'bun:test';
import { parseXmlToAst, serializeAstToXml } from '../grammar/parser';
import { ParseError } from '../types';

describe('XML Parsing with Zod Validation', () => {
  describe('Valid Documents Pass Validation', () => {
    test('should parse and validate basic document', () => {
      const validXml = `
        <document id="test-doc">
          <p>Hello world</p>
          <fncall idyll-fn="demo:echo">
            <params><![CDATA[{"message": "test"}]]></params>
            <content>Test function call</content>
          </fncall>
        </document>
      `;

      expect(() => parseXmlToAst(validXml)).not.toThrow();
      const result = parseXmlToAst(validXml);
      expect(result.id).toBe('test-doc');
      expect(result.nodes).toBeDefined();
      expect(result.nodes.length).toBeGreaterThan(0);
    });

    test('should parse and validate agent document', () => {
      const validAgentXml = `
        <agent id="test-agent" name="Test Agent">
          <p>Agent instructions</p>
        </agent>
      `;

      expect(() => parseXmlToAst(validAgentXml)).not.toThrow();
      const result = parseXmlToAst(validAgentXml);
      expect(result.type).toBe('agent');
      expect(result.id).toBe('test-agent');
    });
  });

  describe('Invalid Documents Fail Validation', () => {
    test('should reject document with invalid function name format', () => {
      const invalidXml = `
        <document id="test-doc">
          <fncall idyll-fn="invalid-function-name">
            <params><![CDATA[{"message": "test"}]]></params>
            <content>Test function call</content>
          </fncall>
        </document>
      `;

      expect(() => parseXmlToAst(invalidXml)).toThrow(ParseError);
      expect(() => parseXmlToAst(invalidXml)).toThrow(/Invalid format for idyll-fn/);
    });

    test('should reject document with malformed XML', () => {
      const invalidXml = `
        <document id="test-doc">
          <p>Unclosed paragraph
        </document>
      `;

      expect(() => parseXmlToAst(invalidXml)).toThrow(ParseError);
    });

    test('should reject unknown root element', () => {
      const invalidXml = `
        <unknown id="test">
          <p>Hello world</p>
        </unknown>
      `;

      expect(() => parseXmlToAst(invalidXml)).toThrow(ParseError);
      expect(() => parseXmlToAst(invalidXml)).toThrow(/Unknown root element/);
    });

    // Note: Empty IDs are auto-generated by parser, so validation passes
    // This is expected behavior - parser provides UUID fallbacks
    test('should auto-generate IDs for empty/missing attributes', () => {
      const xmlWithoutId = `
        <document>
          <p>Hello world</p>
        </document>
      `;

      expect(() => parseXmlToAst(xmlWithoutId)).not.toThrow();
      const result = parseXmlToAst(xmlWithoutId);
      expect(result.id).toMatch(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/);
    });
  });

  describe('Validation Error Messages', () => {
    test('should provide detailed validation error for function name at parser level', () => {
      const invalidXml = `
        <document id="test-doc">
          <fncall idyll-fn="bad-name">
            <params><![CDATA[{}]]></params>
            <content>Test function</content>
          </fncall>
        </document>
      `;

      try {
        parseXmlToAst(invalidXml);
        expect(false).toBe(true); // Should not reach here
      } catch (error) {
        expect(error).toBeInstanceOf(ParseError);
        expect(error.message).toContain('Invalid format for idyll-fn');
      }
    });

    test('should demonstrate Zod validation works on parsed AST', () => {
      // This test shows that Zod validation is integrated and working
      // by parsing a valid document and ensuring validation passes
      const validXml = `
        <document id="test-doc">
          <p>This demonstrates Zod validation integration</p>
          <fncall idyll-fn="demo:test">
            <params><![CDATA[{"key": "value"}]]></params>
            <content>Test content</content>
          </fncall>
        </document>
      `;

      // This should pass both parsing AND Zod validation
      expect(() => parseXmlToAst(validXml)).not.toThrow();
      const result = parseXmlToAst(validXml);
      
      // Verify the structure is correct and validated
      expect(result.id).toBe('test-doc');
      expect(result.nodes).toHaveLength(2);
      expect(result.nodes[1].type).toBe('function_call');
    });
  });

  describe('Serialization Roundtrip with Validation', () => {
    test('should validate roundtrip: parse → serialize → parse', async () => {
      const originalXml = `
        <document id="roundtrip-test">
          <p>This is a <strong>bold</strong> statement with a <variable name="testVar" prompt="Enter value" /></p>
          <fncall idyll-fn="test:generate">
            <params><![CDATA[{"prompt": "Generate a summary"}]]></params>
            <content>Generate a summary of the above content</content>
          </fncall>
        </document>
      `;

      // Parse original
      const doc1 = parseXmlToAst(originalXml);
      expect(doc1).toBeDefined();

      // Serialize
      const serializedXml = serializeAstToXml(doc1);
      expect(serializedXml).toContain('<document id="roundtrip-test">');

      // Parse again - should pass validation
      const doc2 = parseXmlToAst(serializedXml);
      expect(doc2).toBeDefined();
      expect(doc2.id).toBe(doc1.id);
      expect(doc2.nodes).toBeDefined();
    });
  });

  describe('Performance with Validation', () => {
    test('should parse and validate large document efficiently', () => {
      // Generate a large document
      const largeParagraphs = Array.from({ length: 100 }, (_, i) => 
        `<p>This is paragraph ${i} with some <strong>bold</strong> text.</p>`
      ).join('\n');

      const largeXml = `
        <document id="large-doc">
          ${largeParagraphs}
          <fncall idyll-fn="test:process">
            <params><![CDATA[{"count": 100}]]></params>
            <content>Process all paragraphs</content>
          </fncall>
        </document>
      `;

      const startTime = performance.now();
      const result = parseXmlToAst(largeXml);
      const endTime = performance.now();

      expect(result).toBeDefined();
      expect(result.nodes.length).toBe(101); // 100 paragraphs + 1 function call
      expect(endTime - startTime).toBeLessThan(100); // Should be fast even with validation
    });
  });
});