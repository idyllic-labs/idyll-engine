{"version":3,"sources":["../document/ast.ts","../document/parser-grammar.ts","../types.ts","../document/grammars/grammar-dsl.ts","../document/grammars/document-grammar.ts","../document/grammars/agent-grammar.ts","../document/grammars/diff-grammar.ts","../document/grammars/index.ts","../document/grammar-compiler.ts","../document/executor.ts","../document/tool-registry.ts","../document/tool-naming.ts","../document/validator.ts","../document/variable-resolution.ts","../document/custom-tool-executor.ts","../document/diff-applier.ts","../document/blocknote-converter.ts","../agent/agent.ts","../agent/memory.ts","../agent/system-prompt.ts","../agent/custom-tools.ts","../agent/response-compressor.ts"],"sourcesContent":["/**\n * Core AST types for Idyllic documents\n * \n * This defines the semantic model for documents, independent of:\n * - BlockNote editor representation\n * - XML serialization format\n * - Specific tool implementations\n */\n\n// ============================================\n// Core Document Types\n// ============================================\n\n/**\n * The root document structure\n */\nexport interface IdyllDocument {\n  id: string;\n  nodes: Node[];\n  metadata?: DocumentMetadata;\n}\n\n// Backward compatibility: allow accessing nodes via blocks property\nexport interface IdyllDocumentCompat extends IdyllDocument {\n  blocks: Block[];\n}\n\n/**\n * Agent system prompt document\n */\nexport interface AgentDocument {\n  type: 'agent';\n  id: string;\n  name?: string;\n  description?: string;\n  model?: string;\n  nodes: Node[];\n}\n\n/**\n * Diff document for edit operations\n */\nexport interface DiffDocument {\n  type: 'diff';\n  targetDocument?: string;\n  timestamp: Date;\n  operations: EditOperation[];\n}\n\n/**\n * Edit operation types\n */\nexport type EditOperation = \n  | EditAttrOperation\n  | EditContentOperation\n  | EditParamsOperation\n  | EditIdOperation\n  | InsertOperation\n  | DeleteOperation\n  | ReplaceOperation\n  | MoveOperation;\n\nexport interface EditAttrOperation {\n  type: 'edit:attr';\n  nodeId: string;\n  name: string;\n  value: string;\n}\n\nexport interface EditContentOperation {\n  type: 'edit:content';\n  nodeId: string;\n  content: RichContent[];\n}\n\nexport interface EditParamsOperation {\n  type: 'edit:params';\n  nodeId: string;\n  params: Record<string, unknown>;\n}\n\nexport interface EditIdOperation {\n  type: 'edit:id';\n  nodeId: string;\n  newId: string;\n}\n\nexport interface InsertOperation {\n  type: 'insert';\n  afterNodeId?: string;\n  beforeNodeId?: string;\n  atStart?: boolean;\n  atEnd?: boolean;\n  nodes: Node[];\n}\n\nexport interface DeleteOperation {\n  type: 'delete';\n  nodeId: string;\n}\n\nexport interface ReplaceOperation {\n  type: 'replace';\n  nodeId: string;\n  nodes: Node[];\n}\n\nexport interface MoveOperation {\n  type: 'move';\n  nodeId?: string;\n  nodeIds?: string[];\n  fromNodeId?: string;\n  toNodeId?: string;\n  afterNodeId?: string;\n  beforeNodeId?: string;\n  atStart?: boolean;\n  atEnd?: boolean;\n}\n\nexport interface DocumentMetadata {\n  version?: string;\n  created?: Date;\n  modified?: Date;\n  [key: string]: unknown;\n}\n\n/**\n * A node can be either content (text, headings, etc) or executable\n */\nexport type Node = ContentNode | ExecutableNode;\n\n// Backward compatibility aliases\nexport type Block = Node;\nexport type ContentBlock = ContentNode;\nexport type ExecutableBlock = ExecutableNode;\n\n// ============================================\n// Content Nodes\n// ============================================\n\nexport interface ContentNode {\n  id: string;\n  type: ContentBlockType;\n  content: RichContent[];\n  children?: Node[];\n  props?: Record<string, unknown>;\n}\n\n// Define node types directly\nexport type NodeType = \n  | 'p' | 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6'\n  | 'ul' | 'ol' | 'li'\n  | 'blockquote' | 'code' | 'pre'\n  | 'hr' | 'br'\n  | 'function_call' | 'trigger' | '_params' | '_content' | '_result'\n  | 'heading' | 'paragraph';  // Added for compatibility\n\n// ContentNodeType includes all content-related types\nexport type ContentNodeType = \n  | 'paragraph' | 'heading'\n  | 'bulletListItem' | 'numberedListItem' | 'checklistItem'\n  | 'code' | 'quote' | 'separator' | 'data' | 'tool';\n\n// ============================================\n// Executable Nodes\n// ============================================\n\nexport interface ExecutableNode {\n  id: string;\n  type: ExecutableBlockType;\n  tool: string; // e.g., \"documents:create\", \"ai:generate-text\"\n  parameters: Record<string, unknown>;\n  instructions?: RichContent[]; // Natural language instructions\n  result?: ExecutionResult;\n  metadata?: ExecutableMetadata;\n  props?: Record<string, unknown>; // Additional properties for compatibility\n}\n\nexport type ExecutableNodeType = 'function_call' | 'trigger';\n\n// Backward compatibility\nexport type BlockType = NodeType;\nexport type ContentBlockType = ContentNodeType;\nexport type ExecutableBlockType = ExecutableNodeType;\n\nexport interface ExecutableMetadata {\n  enabled?: boolean; // For triggers\n  modelId?: string; // For AI operations\n  [key: string]: unknown;\n}\n\nexport interface ExecutionResult {\n  success: boolean;\n  data?: unknown;\n  error?: ExecutionError;\n  timestamp?: Date;\n}\n\nexport interface ExecutionError {\n  code: string;\n  message: string;\n  details?: unknown;\n}\n\n// ============================================\n// Rich Content Types\n// ============================================\n\n/**\n * Rich content represents inline formatted text and elements\n */\nexport type RichContent = TextContent | InlineElement;\n\nexport interface TextContent {\n  type: 'text';\n  text: string;\n  styles?: TextStyle[];\n}\n\nexport type TextStyle = \n  | 'bold'\n  | 'italic'\n  | 'underline'\n  | 'strikethrough'\n  | 'code';\n\nexport type InlineElement = \n  | MentionElement\n  | VariableElement\n  | LinkElement\n  | AnnotationElement;\n\nexport interface MentionElement {\n  type: 'mention';\n  mentionType: 'user' | 'document' | 'agent' | 'custom';\n  id: string;\n  label?: string;\n}\n\nexport interface VariableElement {\n  type: 'variable';\n  name: string; // e.g., \"previousResult\", \"currentDate\"\n  prompt?: string; // Optional prompt for user input\n  value?: string; // Optional resolved value\n}\n\nexport interface LinkElement {\n  type: 'link';\n  href: string;\n  content: RichContent[];\n}\n\nexport interface AnnotationElement {\n  type: 'annotation';\n  content: RichContent[];\n  annotation: {\n    title?: string;\n    comment?: string;\n    confidence?: number;\n    [key: string]: unknown;\n  };\n}\n\n// ============================================\n// Utility Types\n// ============================================\n\n/**\n * Type guards for runtime type checking\n */\nexport function isContentNode(node: Node): node is ContentNode {\n  return !isExecutableNode(node);\n}\n\n// Backward compatibility\nexport function isContentBlock(block: Block): block is ContentBlock {\n  return isContentNode(block);\n}\n\nexport function isExecutableNode(node: Node): node is ExecutableNode {\n  return node.type === 'function_call' || node.type === 'trigger';\n}\n\n// Backward compatibility\nexport function isExecutableBlock(block: Block): block is ExecutableBlock {\n  return isExecutableNode(block);\n}\n\nexport function isTextContent(content: RichContent): content is TextContent {\n  return content.type === 'text';\n}\n\nexport function isMention(content: RichContent): content is MentionElement {\n  return content.type === 'mention';\n}\n\nexport function isVariable(content: RichContent): content is VariableElement {\n  return content.type === 'variable';\n}\n\n// ============================================\n// Document Traversal Utilities\n// ============================================\n\n/**\n * Traverse all nodes in a document (including nested children)\n */\nexport function* traverseNodes(nodes: Node[]): Generator<Node> {\n  for (const node of nodes) {\n    yield node;\n    if ('children' in node && node.children) {\n      yield* traverseNodes(node.children);\n    }\n  }\n}\n\n// Backward compatibility\nexport function* traverseBlocks(blocks: Block[]): Generator<Block> {\n  yield* traverseNodes(blocks);\n}\n\n/**\n * Find a node by ID\n */\nexport function findNode(nodes: Node[], id: string): Node | undefined {\n  for (const node of traverseNodes(nodes)) {\n    if (node.id === id) {\n      return node;\n    }\n  }\n  return undefined;\n}\n\n// Backward compatibility\nexport function findBlock(blocks: Block[], id: string): Block | undefined {\n  return findNode(blocks, id);\n}\n\n/**\n * Get all executable nodes\n */\nexport function getExecutableNodes(nodes: Node[]): ExecutableNode[] {\n  const executable: ExecutableNode[] = [];\n  for (const node of traverseNodes(nodes)) {\n    if (isExecutableNode(node)) {\n      executable.push(node);\n    }\n  }\n  return executable;\n}\n\n// Backward compatibility\nexport function getExecutableBlocks(blocks: Block[]): ExecutableBlock[] {\n  return getExecutableNodes(blocks);\n}\n\n/**\n * Extract all mentions from a document\n */\nexport function extractMentions(nodes: Node[]): MentionElement[] {\n  const mentions: MentionElement[] = [];\n  \n  function extractFromContent(content: RichContent[]) {\n    for (const item of content) {\n      if (isMention(item)) {\n        mentions.push(item);\n      } else if ('content' in item && Array.isArray(item.content)) {\n        extractFromContent(item.content);\n      }\n    }\n  }\n  \n  for (const node of traverseNodes(nodes)) {\n    if ('content' in node && Array.isArray(node.content)) {\n      extractFromContent(node.content);\n    }\n    if (isExecutableNode(node) && node.instructions) {\n      extractFromContent(node.instructions);\n    }\n  }\n  \n  return mentions;\n}\n\n/**\n * Extract all variables from a document\n */\nexport function extractVariables(nodes: Node[]): VariableElement[] {\n  const variables: VariableElement[] = [];\n  \n  function extractFromContent(content: RichContent[]) {\n    for (const item of content) {\n      if (isVariable(item)) {\n        variables.push(item);\n      } else if ('content' in item && Array.isArray(item.content)) {\n        extractFromContent(item.content);\n      }\n    }\n  }\n  \n  for (const node of traverseNodes(nodes)) {\n    if ('content' in node && Array.isArray(node.content)) {\n      extractFromContent(node.content);\n    }\n    if (isExecutableNode(node) && node.instructions) {\n      extractFromContent(node.instructions);\n    }\n  }\n  \n  return variables;\n}","/**\n * Grammar-based XML parser for Idyllic documents\n *\n * This parser uses the grammar as the single source of truth\n * for parsing, validation, and AST construction\n */\n\nimport * as xml2js from \"xml-js\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport {\n  IdyllDocument,\n  AgentDocument,\n  DiffDocument,\n  EditOperation,\n  Node,\n  Block,\n  ContentNode,\n  ContentBlock,\n  ExecutableNode,\n  ExecutableBlock,\n  RichContent,\n  TextContent,\n  TextStyle,\n  MentionElement,\n  VariableElement,\n  LinkElement,\n  AnnotationElement,\n  ContentNodeType,\n  ContentBlockType,\n  isExecutableNode,\n  isExecutableBlock,\n  isTextContent,\n} from \"./ast\";\nimport { ParseError } from \"../types\";\nimport { GRAMMAR } from \"./grammar\";\nimport { GrammarCompiler } from \"./grammar-compiler\";\n\n// Initialize grammar compiler\nconst compiler = new GrammarCompiler(GRAMMAR);\nconst compiled = compiler.compile();\n\n// ============================================\n// XML to AST Parsing\n// ============================================\n\n/**\n * Parse XML string into AST - determines document type automatically\n */\nexport function parseXmlToAst(\n  xmlString: string\n): IdyllDocument | AgentDocument | DiffDocument {\n  if (!xmlString || !xmlString.trim()) {\n    throw new ParseError(\"Empty XML content provided\");\n  }\n\n  // Parse XML\n  const options: xml2js.Options.XML2JS = {\n    compact: false,\n    textKey: \"text\",\n    ignoreDeclaration: true,\n    ignoreInstruction: true,\n    ignoreComment: true,\n    ignoreDoctype: true,\n    ignoreText: false,\n    trim: false,\n    sanitize: false,\n    nativeType: false,\n  };\n\n  let result: xml2js.Element;\n  try {\n    result = xml2js.xml2js(xmlString, options) as xml2js.Element;\n  } catch (error) {\n    throw new ParseError(\n      `Invalid XML format: ${\n        error instanceof Error ? error.message : \"Failed to parse XML\"\n      }`\n    );\n  }\n\n  // Determine root type and parse accordingly\n  const rootElement = result.elements?.[0];\n  if (!rootElement || rootElement.type !== \"element\") {\n    throw new ParseError(\"No root element found\");\n  }\n\n  switch (rootElement.name) {\n    case \"document\":\n      return parseDocument(rootElement);\n    case \"agent\":\n      return parseAgent(rootElement);\n    case \"diff\":\n      return parseDiff(rootElement);\n    default:\n      throw new ParseError(\n        `Unknown root element: ${rootElement.name}. Expected: document, agent, or diff`\n      );\n  }\n}\n\n/**\n * Parse document root\n */\nfunction parseDocument(documentElement: xml2js.Element): IdyllDocument {\n  // Validate document element\n  const attrs = documentElement.attributes || {};\n  const validationErrors = compiled.validateAttributes(\"document\", attrs);\n  if (validationErrors.length > 0) {\n    throw new ParseError(\n      `Document validation failed: ${validationErrors[0].message}`\n    );\n  }\n\n  const documentId = (attrs.id as string) || uuidv4();\n\n  // Parse nodes\n  const nodes: Node[] = [];\n  const childElements = documentElement.elements || [];\n\n  for (const element of childElements) {\n    if (element.type === \"element\" && element.name) {\n      const node = parseNode(element);\n      if (node) {\n        nodes.push(node);\n      }\n    }\n  }\n\n  return {\n    id: documentId,\n    nodes: nodes.length > 0 ? nodes : [createEmptyParagraph()],\n    metadata: extractMetadata(attrs),\n  };\n}\n\n/**\n * Parse agent root\n */\nfunction parseAgent(agentElement: xml2js.Element): AgentDocument {\n  const attrs = agentElement.attributes || {};\n  const validationErrors = compiled.validateAttributes(\"agent\", attrs);\n  if (validationErrors.length > 0) {\n    throw new ParseError(\n      `Agent validation failed: ${validationErrors[0].message}`\n    );\n  }\n\n  const agentId = (attrs.id as string) || uuidv4();\n\n  // Parse nodes (same as document)\n  const nodes: Node[] = [];\n  const childElements = agentElement.elements || [];\n\n  for (const element of childElements) {\n    if (element.type === \"element\" && element.name) {\n      const node = parseNode(element);\n      if (node) {\n        nodes.push(node);\n      }\n    }\n  }\n\n  return {\n    type: \"agent\",\n    id: agentId,\n    name: attrs.name as string,\n    description: attrs.description as string,\n    model: attrs.model as string,\n    nodes,\n  };\n}\n\n/**\n * Parse diff root\n */\nfunction parseDiff(diffElement: xml2js.Element): DiffDocument {\n  const attrs = diffElement.attributes || {};\n  const validationErrors = compiled.validateAttributes(\"diff\", attrs);\n  if (validationErrors.length > 0) {\n    throw new ParseError(\n      `Diff validation failed: ${validationErrors[0].message}`\n    );\n  }\n\n  // Parse edit operations\n  const operations: EditOperation[] = [];\n  const childElements = diffElement.elements || [];\n\n  for (const element of childElements) {\n    if (element.type === \"element\" && element.name) {\n      const operation = parseEditOperation(element);\n      if (operation) {\n        operations.push(operation);\n      }\n    }\n  }\n\n  return {\n    type: \"diff\",\n    targetDocument: attrs.targetDocument as string,\n    timestamp: attrs.timestamp\n      ? new Date(attrs.timestamp as string)\n      : new Date(),\n    operations,\n  };\n}\n\n/**\n * Parse edit operation\n */\nfunction parseEditOperation(element: xml2js.Element): EditOperation | null {\n  if (!element.name) return null;\n\n  const attrs = element.attributes || {};\n\n  switch (element.name) {\n    case \"edit:prop\":\n      return {\n        type: \"edit:attr\",\n        nodeId: (attrs[\"node-id\"] || attrs[\"block-id\"]) as string,\n        name: attrs.name as string,\n        value: attrs.value as string,\n      };\n\n    case \"edit:content\":\n      return {\n        type: \"edit:content\",\n        nodeId: (attrs[\"node-id\"] || attrs[\"block-id\"]) as string,\n        content: parseRichContent(element),\n      };\n\n    case \"insert\":\n      const insertNodes: Node[] = [];\n      for (const child of element.elements || []) {\n        if (child.type === \"element\" && child.name) {\n          const node = parseNode(child);\n          if (node) {\n            insertNodes.push(node);\n          }\n        }\n      }\n      return {\n        type: \"insert\",\n        afterNodeId: (attrs[\"after-node-id\"] || attrs[\"after-block-id\"]) as string,\n        beforeNodeId: (attrs[\"before-node-id\"] || attrs[\"before-block-id\"]) as string,\n        atStart: attrs[\"at-start\"] === \"true\",\n        atEnd: attrs[\"at-end\"] === \"true\",\n        nodes: insertNodes,\n      };\n\n    case \"delete\":\n      return {\n        type: \"delete\",\n        nodeId: (attrs[\"node-id\"] || attrs[\"block-id\"]) as string,\n      };\n\n    case \"replace\":\n      const replaceNodes: Node[] = [];\n      for (const child of element.elements || []) {\n        if (child.type === \"element\" && child.name) {\n          const node = parseNode(child);\n          if (node) {\n            replaceNodes.push(node);\n          }\n        }\n      }\n      return {\n        type: \"replace\",\n        nodeId: (attrs[\"node-id\"] || attrs[\"block-id\"]) as string,\n        nodes: replaceNodes,\n      };\n\n    default:\n      console.warn(`Unknown edit operation: ${element.name}`);\n      return null;\n  }\n}\n\n/**\n * Parse a block element using grammar rules\n */\nfunction parseNode(element: xml2js.Element): Node | null {\n  if (!element.name) return null;\n\n  const elementType = compiled.elementToType[element.name];\n  if (!elementType) {\n    return null;\n  }\n\n  const id = (element.attributes?.id as string) || uuidv4();\n  const attrs = element.attributes || {};\n\n  // Validate attributes\n  const errors = compiled.validateAttributes(element.name, attrs);\n  if (errors.length > 0) {\n    throw new ParseError(\n      `Invalid attributes for ${element.name}: ${errors[0].message}`\n    );\n  }\n\n  // Route based on element type\n  switch (elementType) {\n    case \"function_call\":\n      return parseFunctionCall(element, id, attrs);\n    case \"trigger\":\n      return parseTrigger(element, id, attrs);\n    case \"tool\":\n      return parseTool(element, id, attrs);\n    default:\n      return parseContentNode(element, id, attrs, elementType);\n  }\n}\n\n/**\n * Parse function call block\n */\nfunction parseFunctionCall(\n  element: xml2js.Element,\n  id: string,\n  attrs: Record<string, unknown>\n): ExecutableBlock {\n  const tool = attrs[\"idyll-tool\"] as string;\n\n  let parameters: Record<string, unknown> = {};\n  let instructions: RichContent[] = [];\n  let result: unknown;\n\n  // Parse child elements according to grammar\n  for (const child of element.elements || []) {\n    if (child.type === \"element\" && child.name) {\n      switch (child.name) {\n        case \"params\":\n          const paramsText = extractTextContent(child);\n          if (paramsText) {\n            try {\n              parameters = JSON.parse(paramsText);\n            } catch {\n              throw new ParseError(`Invalid JSON in params: ${paramsText}`);\n            }\n          }\n          break;\n\n        case \"content\":\n          instructions = parseRichContent(child);\n          break;\n\n        case \"result\":\n          const resultText = extractTextContent(child);\n          if (resultText) {\n            try {\n              result = JSON.parse(resultText);\n            } catch {\n              result = resultText;\n            }\n          }\n          break;\n      }\n    }\n  }\n\n  return {\n    id,\n    type: \"function_call\",\n    tool,\n    parameters,\n    instructions: instructions.length > 0 ? instructions : undefined,\n    result: result ? { success: true, data: result } : undefined,\n    metadata: {\n      modelId: attrs.modelId as string,\n    },\n  };\n}\n\n/**\n * Parse trigger block\n */\nfunction parseTrigger(\n  element: xml2js.Element,\n  id: string,\n  attrs: Record<string, unknown>\n): ExecutableBlock {\n  const tool = attrs[\"idyll-trigger\"] as string;\n  const enabled = attrs.enabled !== false;\n\n  let parameters: Record<string, unknown> = {};\n  let instructions: RichContent[] = [];\n\n  for (const child of element.elements || []) {\n    if (child.type === \"element\" && child.name) {\n      switch (child.name) {\n        case \"params\":\n          const paramsText = extractTextContent(child);\n          if (paramsText) {\n            try {\n              parameters = JSON.parse(paramsText);\n            } catch {\n              throw new ParseError(`Invalid JSON in params: ${paramsText}`);\n            }\n          }\n          break;\n\n        case \"content\":\n          instructions = parseRichContent(child);\n          break;\n      }\n    }\n  }\n\n  return {\n    id,\n    type: \"trigger\",\n    tool,\n    parameters,\n    instructions: instructions.length > 0 ? instructions : undefined,\n    metadata: { enabled },\n  };\n}\n\n/**\n * Parse tool block\n */\nfunction parseTool(\n  element: xml2js.Element,\n  id: string,\n  attrs: Record<string, unknown>\n): ContentBlock {\n  // Tools are stored as content blocks with special props\n  const title = attrs.title as string;\n  const icon = attrs.icon as string;\n\n  let description = \"\";\n  let definition: Block[] = [];\n\n  for (const child of element.elements || []) {\n    if (child.type === \"element\" && child.name) {\n      switch (child.name) {\n        case \"tool:description\":\n          description = extractTextContent(child);\n          break;\n\n        case \"tool:definition\":\n          // Parse blocks within tool definition\n          for (const defChild of child.elements || []) {\n            if (defChild.type === \"element\" && defChild.name) {\n              // Check that it's not another tool (grammar constraint)\n              if (compiled.elementToType[defChild.name] === \"tool\") {\n                throw new ParseError(\"Tools cannot contain other tools\");\n              }\n\n              const node = parseNode(defChild);\n              if (node) {\n                definition.push(node);\n              }\n            }\n          }\n          break;\n      }\n    }\n  }\n\n  return {\n    id,\n    type: \"tool\" as ContentBlockType,\n    content: [{ type: \"text\", text: description }],\n    children: definition.length > 0 ? definition : undefined,\n    props: { title, icon },\n  };\n}\n\n/**\n * Parse content block\n */\nfunction parseContentNode(\n  element: xml2js.Element,\n  id: string,\n  attrs: Record<string, unknown>,\n  blockType: string\n): ContentBlock {\n  const content = parseRichContent(element);\n\n  // Parse children for nested blocks\n  const children: Block[] = [];\n  for (const child of element.elements || []) {\n    if (child.type === \"element\" && child.name) {\n      const childType = compiled.elementToType[child.name];\n      if (childType && compiled.blockTypes.has(childType)) {\n        const childNode = parseNode(child);\n        if (childNode) {\n          children.push(childNode);\n        }\n      }\n    }\n  }\n\n  // Handle heading level\n  if (blockType === \"heading\") {\n    if (element.name === \"heading\") {\n      // Already has level attribute\n    } else if (element.name) {\n      const match = element.name.match(/^h(\\d)$/);\n      if (match) {\n        attrs.level = parseInt(match[1], 10);\n      }\n    }\n  }\n\n  return {\n    id,\n    type: blockType as ContentBlockType,\n    content,\n    children: children.length > 0 ? children : undefined,\n    props: attrs,\n  };\n}\n\n/**\n * Parse rich content using grammar rules\n */\nfunction parseRichContent(element: xml2js.Element): RichContent[] {\n  const content: RichContent[] = [];\n\n  if (!element.elements) return content;\n\n  for (const child of element.elements) {\n    if (child.type === \"text\" && child.text) {\n      content.push({\n        type: \"text\",\n        text: child.text as string,\n      });\n    } else if (child.type === \"element\" && child.name) {\n      const inlineElement = parseInlineElement(child);\n      if (inlineElement) {\n        if (Array.isArray(inlineElement)) {\n          content.push(...inlineElement);\n        } else {\n          content.push(inlineElement);\n        }\n      }\n    }\n  }\n\n  return content;\n}\n\n/**\n * Parse inline element\n */\nfunction parseInlineElement(\n  element: xml2js.Element\n): RichContent | RichContent[] | null {\n  if (!element.name) return null;\n\n  // Check if it's a mention\n  if (element.name.startsWith(\"mention:\")) {\n    const mentionType = element.name.substring(8) as any;\n    const id = element.attributes?.id as string;\n    const label =\n      (element.attributes?.label as string) || extractTextContent(element);\n\n    return {\n      type: \"mention\",\n      mentionType,\n      id,\n      label,\n    } as MentionElement;\n  }\n\n  // Check if it's a variable\n  if (element.name === \"variable\") {\n    const name = element.attributes?.name as string;\n    const prompt = element.attributes?.prompt as string;\n    const value = element.attributes?.value as string;\n    return {\n      type: \"variable\",\n      name,\n      ...(prompt && { prompt }),\n      ...(value && { value }),\n    } as VariableElement;\n  }\n\n  // Check if it's a link\n  if (element.name === \"a\") {\n    const href = element.attributes?.href as string;\n    return {\n      type: \"link\",\n      href,\n      content: parseRichContent(element),\n    } as LinkElement;\n  }\n\n  // Check if it's an annotation\n  if (element.name === \"annotation\") {\n    return {\n      type: \"annotation\",\n      content: parseRichContent(element),\n      annotation: (element.attributes as any) || {},\n    } as AnnotationElement;\n  }\n\n  // Check if it's annotated text\n  if (element.name === \"annotatedtext\") {\n    const annotation = element.attributes?.annotation as string;\n    return {\n      type: \"annotation\",\n      content: parseRichContent(element),\n      annotation: { title: annotation },\n    } as AnnotationElement;\n  }\n\n  // Check if it's AI edit response\n  if (element.name === \"aieditresponse\") {\n    const status = element.attributes?.status as string;\n    return {\n      type: \"annotation\",\n      content: parseRichContent(element),\n      annotation: { type: \"ai-edit\", status },\n    } as AnnotationElement;\n  }\n\n  // Check if it's a style element\n  const styleMap: Record<string, TextStyle> = {\n    strong: \"bold\",\n    b: \"bold\",\n    em: \"italic\",\n    i: \"italic\",\n    u: \"underline\",\n    underline: \"underline\",\n    s: \"strikethrough\",\n    strike: \"strikethrough\",\n    del: \"strikethrough\",\n    code: \"code\",\n    tt: \"code\",\n  };\n\n  const style = styleMap[element.name];\n  if (style) {\n    const innerContent = parseRichContent(element);\n    return innerContent.map((item) => {\n      if (isTextContent(item)) {\n        return {\n          ...item,\n          styles: [...(item.styles || []), style],\n        } as TextContent;\n      }\n      return item;\n    });\n  }\n\n  return null;\n}\n\n// ============================================\n// AST to XML Serialization\n// ============================================\n\n/**\n * Serialize AST document to XML string\n */\nexport function serializeAstToXml(\n  document: IdyllDocument | AgentDocument | DiffDocument\n): string {\n  let root: xml2js.Element;\n\n  if (\"type\" in document) {\n    if (document.type === \"agent\") {\n      root = serializeAgentDocument(document);\n    } else if (document.type === \"diff\") {\n      root = serializeDiffDocument(document);\n    } else {\n      throw new Error(`Unknown document type`);\n    }\n  } else {\n    root = serializeIdyllDocument(document);\n  }\n\n  const options: xml2js.Options.JS2XML = {\n    compact: false,\n    spaces: 2,\n    textKey: \"text\",\n  };\n\n  // xml2js expects the root element to be wrapped in an object with elements array\n  const wrapped = {\n    elements: [root]\n  };\n\n  return `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n${xml2js.js2xml(\n    wrapped,\n    options\n  )}`;\n}\n\n/**\n * Serialize IdyllDocument\n */\nfunction serializeIdyllDocument(document: IdyllDocument): xml2js.Element {\n  return {\n    type: \"element\",\n    name: \"document\",\n    attributes: {\n      id: document.id,\n      ...serializeMetadata(document.metadata),\n    },\n    elements: document.nodes.map(serializeNode),\n  };\n}\n\n/**\n * Serialize AgentDocument\n */\nfunction serializeAgentDocument(document: AgentDocument): xml2js.Element {\n  return {\n    type: \"element\",\n    name: \"agent\",\n    attributes: {\n      id: document.id,\n      ...(document.name && { name: document.name }),\n      ...(document.description && { description: document.description }),\n      ...(document.model && { model: document.model }),\n    },\n    elements: document.nodes.map(serializeNode),\n  };\n}\n\n/**\n * Serialize DiffDocument\n */\nfunction serializeDiffDocument(document: DiffDocument): xml2js.Element {\n  return {\n    type: \"element\",\n    name: \"diff\",\n    attributes: {\n      ...(document.targetDocument && {\n        targetDocument: document.targetDocument,\n      }),\n      timestamp: document.timestamp.toISOString(),\n    },\n    elements: document.operations.map(serializeEditOperation),\n  };\n}\n\n/**\n * Serialize a block to XML element\n */\nfunction serializeNode(node: Node): xml2js.Element {\n  if (isExecutableNode(node)) {\n    return serializeExecutableNode(node);\n  }\n\n  // Special handling for tool nodes\n  if (node.type === \"tool\") {\n    return serializeToolNode(node);\n  }\n\n  return serializeContentNode(node);\n}\n\n/**\n * Serialize executable block\n */\nfunction serializeExecutableNode(node: ExecutableNode): xml2js.Element {\n  const elements: xml2js.Element[] = [];\n\n  // Add params\n  if (Object.keys(node.parameters).length > 0) {\n    elements.push({\n      type: \"element\",\n      name: \"params\",\n      elements: [\n        {\n          type: \"cdata\",\n          cdata: JSON.stringify(node.parameters),\n        },\n      ],\n    });\n  }\n\n  // Add content\n  if (node.instructions && node.instructions.length > 0) {\n    elements.push({\n      type: \"element\",\n      name: \"content\",\n      elements: serializeRichContent(node.instructions),\n    });\n  }\n\n  if (node.type === \"function_call\") {\n    // Add result\n    if (node.result) {\n      elements.push({\n        type: \"element\",\n        name: \"result\",\n        elements: [\n          {\n            type: \"cdata\",\n            cdata: JSON.stringify(node.result.data || node.result),\n          },\n        ],\n      });\n    }\n\n    return {\n      type: \"element\",\n      name: \"fncall\",\n      attributes: {\n        id: node.id,\n        \"idyll-tool\": node.tool,\n        ...(node.metadata?.modelId && { modelId: node.metadata.modelId }),\n      },\n      elements,\n    };\n  } else {\n    return {\n      type: \"element\",\n      name: \"trigger\",\n      attributes: {\n        id: node.id,\n        \"idyll-trigger\": node.tool,\n        enabled: String(node.metadata?.enabled !== false),\n      },\n      elements,\n    };\n  }\n}\n\n/**\n * Serialize tool block\n */\nfunction serializeToolNode(node: ContentNode): xml2js.Element {\n  const elements: xml2js.Element[] = [];\n\n  // Add description\n  const description = node.content\n    .map((c) => (isTextContent(c) ? c.text : \"\"))\n    .join(\"\");\n\n  elements.push({\n    type: \"element\",\n    name: \"tool:description\",\n    elements: [{ type: \"text\", text: description }],\n  });\n\n  // Add definition\n  if (node.children && node.children.length > 0) {\n    elements.push({\n      type: \"element\",\n      name: \"tool:definition\",\n      elements: node.children.map(serializeNode),\n    });\n  }\n\n  const attributes: Record<string, string> = {\n    id: node.id,\n    title: node.props?.title as string,\n  };\n\n  if (node.props?.icon) {\n    attributes.icon = node.props.icon as string;\n  }\n\n  return {\n    type: \"element\",\n    name: \"tool\",\n    attributes,\n    elements,\n  };\n}\n\n/**\n * Serialize content block\n */\nfunction serializeContentNode(node: ContentNode): xml2js.Element {\n  const elements = [\n    ...serializeRichContent(node.content),\n    ...(node.children || []).map(serializeNode),\n  ];\n\n  // Get element name from type\n  const typeToElement = Object.entries(compiled.elementToType).reduce(\n    (acc, [elem, type]) => {\n      if (!acc[type]) acc[type] = [];\n      acc[type].push(elem);\n      return acc;\n    },\n    {} as Record<string, string[]>\n  );\n\n  let elementName = typeToElement[node.type]?.[0] || \"p\";\n\n  // Special handling for headings\n  if (node.type === \"heading\" && node.props?.level) {\n    elementName = `h${node.props.level}`;\n  }\n\n  return {\n    type: \"element\",\n    name: elementName,\n    attributes: {\n      id: node.id,\n      ...node.props,\n    },\n    elements: elements.length > 0 ? elements : undefined,\n  };\n}\n\n/**\n * Serialize rich content\n */\nfunction serializeRichContent(\n  content: RichContent[]\n): (xml2js.Element | { type: \"text\"; text: string })[] {\n  return content.map((item) => {\n    if (isTextContent(item)) {\n      if (item.styles && item.styles.length > 0) {\n        // Map styles to elements\n        const styleToElement: Record<TextStyle, string> = {\n          bold: \"strong\",\n          italic: \"em\",\n          underline: \"u\",\n          strikethrough: \"s\",\n          code: \"code\",\n        };\n\n        // Wrap in style elements\n        let element: xml2js.Element = {\n          type: \"element\",\n          name: styleToElement[item.styles[0]],\n          elements: [{ type: \"text\", text: item.text }],\n        };\n\n        // Nest additional styles\n        for (let i = 1; i < item.styles.length; i++) {\n          element = {\n            type: \"element\",\n            name: styleToElement[item.styles[i]],\n            elements: [element],\n          };\n        }\n\n        return element;\n      }\n      return { type: \"text\", text: item.text };\n    }\n\n    // Handle other inline elements\n    switch (item.type) {\n      case \"mention\":\n        return {\n          type: \"element\",\n          name: `mention:${item.mentionType}`,\n          attributes: {\n            id: item.id,\n            ...(item.label && { label: item.label }),\n          },\n          elements: item.label\n            ? undefined\n            : [{ type: \"text\", text: item.label || \"\" }],\n        };\n\n      case \"variable\":\n        return {\n          type: \"element\",\n          name: \"variable\",\n          attributes: {\n            name: item.name,\n            ...(item.prompt && { prompt: item.prompt }),\n            ...(item.value && { value: item.value }),\n          },\n        };\n\n      case \"link\":\n        return {\n          type: \"element\",\n          name: \"a\",\n          attributes: { href: item.href },\n          elements: serializeRichContent(item.content),\n        };\n\n      case \"annotation\":\n        return {\n          type: \"element\",\n          name: \"annotation\",\n          attributes: {\n            ...(item.annotation.title && { title: String(item.annotation.title) }),\n            ...(item.annotation.comment && { comment: String(item.annotation.comment) }),\n            ...(item.annotation.confidence !== undefined && { confidence: String(item.annotation.confidence) }),\n          },\n          elements: serializeRichContent(item.content),\n        };\n\n      default:\n        return { type: \"text\", text: \"\" };\n    }\n  });\n}\n\n// ============================================\n// Utility Functions\n// ============================================\n\nfunction extractTextContent(element: xml2js.Element): string {\n  let text = \"\";\n\n  if (element.elements) {\n    for (const child of element.elements) {\n      if (child.type === \"text\" && child.text) {\n        text += child.text;\n      } else if (child.type === \"cdata\" && child.cdata) {\n        text += child.cdata;\n      } else if (child.type === \"element\") {\n        text += extractTextContent(child);\n      }\n    }\n  }\n\n  return text;\n}\n\nfunction createEmptyParagraph(): ContentNode {\n  return {\n    id: uuidv4(),\n    type: \"paragraph\",\n    content: [],\n  };\n}\n\nfunction extractMetadata(\n  attrs: Record<string, unknown>\n): Record<string, unknown> | undefined {\n  const metadata: Record<string, unknown> = {};\n\n  if (attrs.version) metadata.version = attrs.version;\n  if (attrs.created) metadata.created = new Date(attrs.created as string);\n  if (attrs.modified) metadata.modified = new Date(attrs.modified as string);\n\n  return Object.keys(metadata).length > 0 ? metadata : undefined;\n}\n\nfunction serializeMetadata(\n  metadata?: Record<string, unknown>\n): Record<string, string> {\n  if (!metadata) return {};\n\n  const result: Record<string, string> = {};\n\n  if (metadata.version) result.version = String(metadata.version);\n  if (metadata.created instanceof Date)\n    result.created = metadata.created.toISOString();\n  if (metadata.modified instanceof Date)\n    result.modified = metadata.modified.toISOString();\n\n  return result;\n}\n\n/**\n * Serialize edit operation\n */\nfunction serializeEditOperation(operation: EditOperation): xml2js.Element {\n  switch (operation.type) {\n    case \"edit:attr\":\n      return {\n        type: \"element\",\n        name: \"edit:prop\",\n        attributes: {\n          \"node-id\": (operation as any).nodeId || (operation as any).blockId,\n          name: operation.name,\n          value: operation.value,\n        },\n      };\n\n    case \"edit:content\":\n      return {\n        type: \"element\",\n        name: \"edit:content\",\n        attributes: {\n          \"node-id\": (operation as any).nodeId || (operation as any).blockId,\n        },\n        elements: serializeRichContent(operation.content),\n      };\n\n    case \"insert\":\n      return {\n        type: \"element\",\n        name: \"insert\",\n        attributes: {\n          ...((operation as any).afterNodeId && {\n            \"after-node-id\": (operation as any).afterNodeId,\n          }),\n          ...((operation as any).afterBlockId && {\n            \"after-block-id\": (operation as any).afterBlockId,\n          }),\n          ...((operation as any).beforeNodeId && {\n            \"before-node-id\": (operation as any).beforeNodeId,\n          }),\n          ...((operation as any).beforeBlockId && {\n            \"before-block-id\": (operation as any).beforeBlockId,\n          }),\n          ...(operation.atStart && { \"at-start\": \"true\" }),\n          ...(operation.atEnd && { \"at-end\": \"true\" }),\n        },\n        elements: (operation as any).nodes.map(serializeNode),\n      };\n\n    case \"delete\":\n      return {\n        type: \"element\",\n        name: \"delete\",\n        attributes: {\n          \"node-id\": (operation as any).nodeId || (operation as any).blockId,\n        },\n      };\n\n    case \"replace\":\n      return {\n        type: \"element\",\n        name: \"replace\",\n        attributes: {\n          \"node-id\": (operation as any).nodeId || (operation as any).blockId,\n        },\n        elements: (operation as any).nodes.map(serializeNode),\n      };\n\n    default:\n      throw new Error(`Unknown operation type`);\n  }\n}\n\n// ============================================\n// Backward Compatibility Exports\n// ============================================\n\n/**\n * @deprecated Use parseXmlToAst instead for clarity\n */\nexport const parseXML = parseXmlToAst;\n\n/**\n * @deprecated Use serializeAstToXml instead for clarity  \n */\nexport const serializeToXML = serializeAstToXml;\n","/**\n * Consolidated type definitions for Idyll Engine\n */\n\nimport type { MentionElement, VariableElement } from './document/ast';\n\n// ============================================\n// Validation Context\n// ============================================\n\n/**\n * Context for validating document references\n */\nexport interface ValidationContext {\n  /**\n   * Validate that a mention reference exists\n   * @param mention The mention to validate\n   * @returns True if valid, false otherwise\n   */\n  validateMention?(mention: MentionElement): boolean;\n  \n  /**\n   * Validate that a variable exists and optionally get its value\n   * @param variable The variable to validate\n   * @returns Validation result with optional value\n   */\n  validateVariable?(variable: VariableElement): {\n    valid: boolean;\n    value?: unknown;\n  };\n  \n  /**\n   * Validate that a tool exists\n   * @param toolName The tool name to validate\n   * @returns True if tool exists, false otherwise\n   */\n  validateTool?(toolName: string): boolean;\n}\n\n// ============================================\n// Execution Context\n// ============================================\n\n/**\n * Runtime context for document/agent execution\n */\nexport interface ExecutionContext {\n  /**\n   * User performing the execution\n   */\n  user: {\n    id: string;\n    name?: string;\n    email?: string;\n  };\n  \n  /**\n   * Available variables during execution\n   */\n  variables: Record<string, unknown>;\n  \n  /**\n   * Resolve a mention to its value\n   * @param mention The mention to resolve\n   * @returns The resolved value or undefined\n   */\n  resolveMention?(mention: MentionElement): unknown;\n  \n  /**\n   * Resolve a variable to its value\n   * @param variable The variable to resolve\n   * @returns The resolved value or undefined\n   */\n  resolveVariable?(variable: VariableElement): unknown;\n  \n  /**\n   * Additional metadata\n   */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Context specific to document execution\n */\nexport interface DocumentExecutionContext extends ExecutionContext {\n  /**\n   * Document being executed\n   */\n  documentId: string;\n  \n  /**\n   * Whether the user can edit the document\n   */\n  canEdit: boolean;\n}\n\n/**\n * Context specific to agent execution\n */\nexport interface AgentExecutionContext extends ExecutionContext {\n  /**\n   * Agent performing the execution\n   */\n  agentId: string;\n  \n  /**\n   * Thread ID if in a conversation\n   */\n  threadId?: string;\n  \n  /**\n   * Conversation history if available\n   */\n  messages?: Array<{\n    role: 'user' | 'assistant' | 'system';\n    content: string;\n  }>;\n}\n\n// ============================================\n// Tool Definition\n// ============================================\n\n/**\n * Definition of a tool that can be executed\n */\nexport interface ToolDefinition {\n  /**\n   * Unique tool identifier (e.g., \"documents:create\")\n   */\n  name: string;\n  \n  /**\n   * Human-readable title\n   */\n  title?: string;\n  \n  /**\n   * Tool description\n   */\n  description?: string;\n  \n  /**\n   * Whether the tool requires content/instructions\n   */\n  contentRequirement?: 'required' | 'optional' | 'disabled';\n  \n  /**\n   * Validate parameters before execution\n   * @param params The parameters to validate\n   * @returns Validation result\n   */\n  validate(params: unknown): ToolValidationResult;\n}\n\nexport type ToolValidationResult = \n  | { success: true }\n  | { success: false; errors: string[] };\n\n// ============================================\n// Tool Resolution & Execution\n// ============================================\n\n/**\n * Interface for resolving tool definitions\n */\nexport interface ToolResolver {\n  /**\n   * Resolve a tool by name\n   * @param name Tool identifier\n   * @returns Tool definition or null if not found\n   */\n  resolve(name: string): ToolDefinition | null;\n  \n  /**\n   * List all available tools\n   * @returns Array of tool names\n   */\n  list?(): string[];\n}\n\n/**\n * Interface for executing tools\n */\nexport interface ToolExecutor {\n  /**\n   * Execute a tool with given parameters\n   * @param tool Tool name\n   * @param params Tool parameters (already validated)\n   * @param context Execution context\n   * @returns Tool execution result\n   */\n  execute(\n    tool: string, \n    params: Record<string, unknown>, \n    context: ToolExecutionContext\n  ): Promise<ToolResult>;\n}\n\n/**\n * Context provided during tool execution\n */\nexport interface ToolExecutionContext {\n  /**\n   * Execution mode - where the tool is being executed from\n   */\n  mode: 'document' | 'agent';\n  \n  /**\n   * User executing the tool\n   */\n  user: {\n    id: string;\n    name?: string;\n    email?: string;\n  };\n  \n  /**\n   * Instructions/content provided with the tool call\n   */\n  instructions?: string;\n  \n  /**\n   * Document-specific context\n   */\n  document?: {\n    id: string;\n    nodeId: string;\n  };\n  \n  /**\n   * Agent-specific context\n   */\n  agent?: {\n    id: string;\n    threadId?: string;\n  };\n  \n  /**\n   * Additional metadata\n   */\n  metadata?: Record<string, unknown>;\n}\n\n// ============================================\n// Tool Results\n// ============================================\n\n/**\n * Result from tool execution\n */\nexport interface ToolResult {\n  success: boolean;\n  data?: unknown;\n  error?: ToolError;\n  /**\n   * Human-readable message about the result\n   */\n  message?: string;\n}\n\nexport interface ToolError {\n  code: string;\n  message: string;\n  details?: unknown;\n}\n\n/**\n * Helper class for creating tool results\n */\nexport class ToolResponse {\n  static success(data: unknown, message?: string): ToolResult {\n    return {\n      success: true,\n      data,\n      message,\n    };\n  }\n  \n  static error(error: string | ToolError, details?: unknown): ToolResult {\n    if (typeof error === 'string') {\n      return {\n        success: false,\n        error: {\n          code: 'TOOL_ERROR',\n          message: error,\n          details,\n        },\n      };\n    }\n    return {\n      success: false,\n      error,\n    };\n  }\n  \n  static empty(): ToolResult {\n    return {\n      success: true,\n    };\n  }\n}\n\n// ============================================\n// Error Types\n// ============================================\n\n/**\n * Base error class for all engine errors\n */\nexport class IdyllEngineError extends Error {\n  constructor(\n    message: string,\n    public code: string,\n    public details?: unknown\n  ) {\n    super(message);\n    this.name = 'IdyllEngineError';\n  }\n}\n\n/**\n * Error during document parsing\n */\nexport class ParseError extends IdyllEngineError {\n  constructor(message: string, details?: unknown) {\n    super(message, 'PARSE_ERROR', details);\n    this.name = 'ParseError';\n  }\n}\n\n/**\n * Error during document validation\n */\nexport class ValidationError extends IdyllEngineError {\n  constructor(\n    message: string,\n    public errors: string[],\n    details?: unknown\n  ) {\n    super(message, 'VALIDATION_ERROR', details);\n    this.name = 'ValidationError';\n  }\n}\n\n/**\n * Error during tool execution\n */\nexport class ToolExecutionError extends IdyllEngineError {\n  constructor(\n    message: string,\n    public toolName: string,\n    public nodeId?: string,\n    details?: unknown\n  ) {\n    super(message, 'TOOL_EXECUTION_ERROR', details);\n    this.name = 'ToolExecutionError';\n  }\n}\n\n/**\n * Error when a tool is not found\n */\nexport class ToolNotFoundError extends IdyllEngineError {\n  constructor(toolName: string) {\n    super(`Tool not found: ${toolName}`, 'TOOL_NOT_FOUND', { toolName });\n    this.name = 'ToolNotFoundError';\n  }\n}\n\n/**\n * Error during agent execution\n */\nexport class AgentExecutionError extends IdyllEngineError {\n  constructor(\n    message: string,\n    public agentId: string,\n    details?: unknown\n  ) {\n    super(message, 'AGENT_EXECUTION_ERROR', details);\n    this.name = 'AgentExecutionError';\n  }\n}\n\n// ============================================\n// Error Utilities\n// ============================================\n\n/**\n * Check if an error is an engine error\n */\nexport function isIdyllEngineError(error: unknown): error is IdyllEngineError {\n  return error instanceof IdyllEngineError;\n}\n\n/**\n * Format error for display\n */\nexport function formatError(error: unknown): string {\n  if (isIdyllEngineError(error)) {\n    return `${error.code}: ${error.message}`;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return String(error);\n}","/**\n * Grammar DSL Types and Builder Functions\n * \n * Provides the core types and helper functions for building grammars.\n */\n\n// ============================================\n// DSL Types\n// ============================================\n\nexport type Rule = \n  | TerminalRule\n  | SequenceRule\n  | ChoiceRule\n  | RepeatRule\n  | OptionalRule\n  | RefRule;\n\ninterface TerminalRule {\n  type: 'terminal';\n  element: string;\n  attributes?: Record<string, AttributeDef>;\n  content?: 'text' | 'rich' | 'json' | 'none';\n}\n\ninterface SequenceRule {\n  type: 'sequence';\n  rules: Rule[];\n}\n\ninterface ChoiceRule {\n  type: 'choice';\n  rules: Rule[];\n}\n\ninterface RepeatRule {\n  type: 'repeat';\n  rule: Rule;\n  min: number;\n  max: number | null; // null = unbounded\n}\n\ninterface OptionalRule {\n  type: 'optional';\n  rule: Rule;\n}\n\ninterface RefRule {\n  type: 'ref';\n  name: string;\n}\n\nexport interface AttributeDef {\n  type: 'string' | 'number' | 'boolean' | 'enum';\n  required?: boolean;\n  values?: readonly string[];\n  pattern?: RegExp;\n  validate?: (value: unknown) => string | null;\n  default?: any;\n}\n\n// ============================================\n// DSL Builder Functions\n// ============================================\n\nexport function terminal(element: string, attrs?: Record<string, AttributeDef>, content?: 'text' | 'rich' | 'json' | 'none'): TerminalRule {\n  return { type: 'terminal', element, attributes: attrs, content };\n}\n\nexport function seq(...rules: (Rule | string)[]): SequenceRule {\n  return { \n    type: 'sequence', \n    rules: rules.map(r => typeof r === 'string' ? ref(r) : r)\n  };\n}\n\nexport function choice(...rules: (Rule | string)[]): ChoiceRule {\n  return { \n    type: 'choice', \n    rules: rules.map(r => typeof r === 'string' ? ref(r) : r)\n  };\n}\n\nexport function repeat(rule: Rule | string, min = 0, max: number | null = null): RepeatRule {\n  return { \n    type: 'repeat', \n    rule: typeof rule === 'string' ? ref(rule) : rule,\n    min, \n    max \n  };\n}\n\nexport function optional(rule: Rule | string): OptionalRule {\n  return { \n    type: 'optional', \n    rule: typeof rule === 'string' ? ref(rule) : rule\n  };\n}\n\nexport function ref(name: string): RefRule {\n  return { type: 'ref', name };\n}\n\n// Shorthand helpers\nexport const zeroOrMore = (rule: Rule | string) => repeat(rule, 0, null);\nexport const oneOrMore = (rule: Rule | string) => repeat(rule, 1, null);\nexport const zeroOrOne = optional;","/**\n * Document Grammar for Idyll Documents\n * \n * Defines the structure for content documents with blocks and rich text.\n */\n\nimport { Rule, terminal, seq, choice, repeat, optional, ref, oneOrMore, zeroOrMore } from './grammar-dsl';\n\nexport const DOCUMENT_GRAMMAR: Record<string, Rule> = {\n  // Document root\n  document: seq(\n    terminal('document', { \n      id: { type: 'string', required: false },\n      version: { type: 'string', required: false },\n      created: { type: 'string', required: false },\n      modified: { type: 'string', required: false }\n    }),\n    zeroOrMore('block')\n  ),\n\n  // Blocks\n  block: choice(\n    'content-block',\n    'executable-block', \n    'tool-block'\n  ),\n\n  'content-block': choice(\n    'paragraph',\n    'heading',\n    'bullet-list-item',\n    'numbered-list-item',\n    'checklist-item',\n    'code',\n    'quote',\n    'separator',\n    'data'\n  ),\n\n  'executable-block': choice(\n    'function-call',\n    'trigger'\n  ),\n\n  // Content blocks\n  paragraph: choice(\n    terminal('p', {}, 'rich'),\n    terminal('paragraph', {}, 'rich') // legacy support\n  ),\n  \n  heading: choice(\n    terminal('h1', {}, 'rich'),\n    terminal('h2', {}, 'rich'),\n    terminal('h3', {}, 'rich'),\n    terminal('h4', {}, 'rich'),\n    terminal('h5', {}, 'rich'),\n    terminal('h6', {}, 'rich'),\n    terminal('heading', { // legacy support\n      level: { type: 'number', required: true, validate: (v: unknown) => {\n        const num = Number(v);\n        return num >= 1 && num <= 6 ? null : 'Level must be 1-6';\n      }}\n    }, 'rich')\n  ),\n\n  // List items (individual blocks, no containers)\n  'bullet-list-item': terminal('bulletlistitem', {}, 'rich'),\n  \n  'numbered-list-item': terminal('numberedlistitem', {}, 'rich'),\n  \n  'checklist-item': terminal('checklistitem', {\n    checked: { type: 'boolean', required: true }\n  }, 'rich'),\n\n  code: terminal('code', { \n    language: { type: 'string', required: false } \n  }, 'text'),\n\n  quote: terminal('quote', {\n    author: { type: 'string', required: false },\n    source: { type: 'string', required: false }\n  }, 'rich'),\n\n  separator: terminal('separator', {}, 'none'),\n  \n  data: terminal('data', {\n    title: { type: 'string', required: false }\n  }, 'text'),\n\n  // Executable blocks\n  'function-call': seq(\n    terminal('fncall', {\n      'idyll-tool': {\n        type: 'string',\n        required: true,\n        // Format: \\\"module:function\\\" or just \\\"function\\\" (e.g., \\\"demo:echo\\\", \\\"ai:analyzeText\\\", \\\"echo\\\")\n        // Module and function names MUST be valid JS identifiers\n        // For Azure Functions compatibility, transform at adapter layer:\n        // \\\"module:function\\\"  \\\"module--function\\\" (double hyphen separator)\n        pattern: /^([a-zA-Z_$][a-zA-Z0-9_$]*:)?[a-zA-Z_$][a-zA-Z0-9_$]*$/\n      },\n      modelId: { type: 'string', required: false }\n    }),\n    optional('params'),\n    optional('content'),\n    optional('result')\n  ),\n\n  trigger: seq(\n    terminal('trigger', {\n      'idyll-trigger': {\n        type: 'string',\n        required: true,\n        // Format: \\\"module:trigger\\\" or just \\\"trigger\\\" (e.g., \\\"time:schedule\\\", \\\"webhook:receive\\\", \\\"daily\\\")\n        // Module and trigger names MUST be valid JS identifiers\n        // For Azure Functions compatibility, transform at adapter layer:\n        // \\\"module:trigger\\\"  \\\"module--trigger\\\" (double hyphen separator)\n        pattern: /^([a-zA-Z_$][a-zA-Z0-9_$]*:)?[a-zA-Z_$][a-zA-Z0-9_$]*$/\n      },\n      enabled: { type: 'boolean', default: true }\n    }),\n    optional('params'),\n    optional('content')\n  ),\n\n  // Tool blocks\n  'tool-block': seq(\n    terminal('tool', {\n      title: { type: 'string', required: true },\n      icon: { type: 'string', required: false }\n    }),\n    ref('tool-description'),\n    ref('tool-definition')\n  ),\n\n  'tool-description': terminal('tool:description', {}, 'text'),\n\n  'tool-definition': seq(\n    terminal('tool:definition'),\n    zeroOrMore(choice('content-block', 'executable-block')) // no nested tools!\n  ),\n\n  // Function call children\n  params: seq(\n    terminal('params'),\n    ref('json-content')\n  ),\n\n  content: seq(\n    terminal('content'),\n    ref('rich-content')\n  ),\n\n  result: seq(\n    terminal('result'),\n    ref('json-content')\n  ),\n\n  // Content types\n  'rich-content': zeroOrMore(choice(\n    'text',\n    'styled-text',\n    'mention',\n    'variable',\n    'link',\n    'annotation',\n    'annotated-text',\n    'ai-edit-response'\n  )),\n\n  'text-content': terminal('_text', {}, 'text'), // pseudo-element for plain text\n  'json-content': terminal('_json', {}, 'json'), // pseudo-element for JSON\n\n  // Inline elements\n  'styled-text': choice(\n    seq(choice(terminal('strong'), terminal('b')), ref('rich-content')),\n    seq(choice(terminal('em'), terminal('i')), ref('rich-content')),\n    seq(choice(terminal('u'), terminal('underline')), ref('rich-content')),\n    seq(choice(terminal('s'), terminal('strike'), terminal('del')), ref('rich-content')),\n    seq(choice(terminal('code'), terminal('tt')), ref('rich-content'))\n  ),\n  \n  annotation: seq(\n    terminal('annotation', {\n      title: { type: 'string', required: false },\n      comment: { type: 'string', required: false },\n      confidence: { type: 'number', required: false }\n    }),\n    ref('rich-content')\n  ),\n\n  mention: choice(\n    terminal('mention:user', { \n      id: { type: 'string', required: true },\n      label: { type: 'string', required: false }\n    }, 'text'),\n    terminal('mention:document', { \n      id: { type: 'string', required: true },\n      label: { type: 'string', required: false }\n    }, 'text'),\n    terminal('mention:agent', { \n      id: { type: 'string', required: true },\n      label: { type: 'string', required: false }\n    }, 'text'),\n    terminal('mention:custom', {\n      id: { type: 'string', required: true },\n      type: { type: 'string', required: true },\n      label: { type: 'string', required: false }\n    }, 'text')\n  ),\n\n  variable: terminal('variable', { \n    name: { type: 'string', required: true },\n    prompt: { type: 'string', required: false },\n    value: { type: 'string', required: false }\n  }, 'none'),\n\n  link: seq(\n    terminal('a', { \n      href: { type: 'string', required: true, pattern: /^https?:\\/\\/.+/ } \n    }),\n    ref('rich-content')\n  ),\n  \n  'annotated-text': seq(\n    terminal('annotatedtext', {\n      annotation: { type: 'string', required: true }\n    }),\n    ref('rich-content')\n  ),\n  \n  'ai-edit-response': seq(\n    terminal('aieditresponse', {\n      status: { type: 'enum', values: ['pending', 'accepted', 'rejected'] as const, required: true }\n    }),\n    ref('rich-content')\n  ),\n\n  text: terminal('_text', {}, 'text'), // Raw text node\n};","/**\n * Agent Grammar for Idyll System Prompts\n * \n * Defines the structure for agent documents containing system prompts.\n */\n\nimport { Rule, terminal, seq, zeroOrMore } from './grammar-dsl';\n\nexport const AGENT_GRAMMAR: Record<string, Rule> = {\n  // Agent system prompt root\n  agent: seq(\n    terminal('agent', {\n      id: { type: 'string', required: false },\n      name: { type: 'string', required: false },\n      description: { type: 'string', required: false },\n      model: { type: 'string', required: false }\n    }),\n    zeroOrMore('block')\n  )\n};\n\n// Note: Agent grammar references 'block' from document grammar\n// This will be resolved when grammars are combined","/**\n * Diff Grammar for Idyll Document Transformations\n * \n * Defines the structure for diff operations that modify documents.\n */\n\nimport { Rule, terminal, seq, oneOrMore, choice, ref } from './grammar-dsl';\n\nexport const DIFF_GRAMMAR: Record<string, Rule> = {\n  // Diff operations root\n  diff: seq(\n    terminal('diff', {\n      targetDocument: { type: 'string', required: false },\n      timestamp: { type: 'string', required: false }\n    }),\n    oneOrMore('edit-operation')\n  ),\n\n  // Edit operations\n  'edit-operation': choice(\n    'edit-attr',\n    'edit-content',\n    'edit-params',\n    'edit-id',\n    'insert',\n    'delete',\n    'replace',\n    'move'\n  ),\n\n  'edit-attr': terminal('edit:attr', {\n    'block-id': { type: 'string', required: true },\n    name: { type: 'string', required: true },\n    value: { type: 'string', required: true }\n  }, 'none'),\n\n  'edit-content': seq(\n    terminal('edit:content', {\n      'block-id': { type: 'string', required: true }\n    }),\n    ref('rich-content')\n  ),\n\n  'edit-params': seq(\n    terminal('edit:params', {\n      'block-id': { type: 'string', required: true }\n    }),\n    ref('json-content')\n  ),\n\n  'edit-id': terminal('edit:id', {\n    'block-id': { type: 'string', required: true },\n    value: { type: 'string', required: true }\n  }, 'none'),\n\n  insert: seq(\n    terminal('insert', {\n      'after-block-id': { type: 'string', required: false },\n      'before-block-id': { type: 'string', required: false },\n      'at-start': { type: 'boolean', required: false },\n      'at-end': { type: 'boolean', required: false }\n    }),\n    oneOrMore('block')\n  ),\n\n  delete: terminal('delete', {\n    'block-id': { type: 'string', required: true }\n  }, 'none'),\n\n  replace: seq(\n    terminal('replace', {\n      'block-id': { type: 'string', required: true }\n    }),\n    oneOrMore('block')\n  ),\n\n  move: terminal('move', {\n    'block-id': { type: 'string', required: false },\n    'block-ids': { type: 'string', required: false },\n    'from-block-id': { type: 'string', required: false },\n    'to-block-id': { type: 'string', required: false },\n    'after-block-id': { type: 'string', required: false },\n    'before-block-id': { type: 'string', required: false },\n    'at-start': { type: 'boolean', required: false },\n    'at-end': { type: 'boolean', required: false }\n  }, 'none')\n};\n\n// Note: Diff grammar references 'rich-content', 'json-content', and 'block' \n// from document grammar. These will be resolved when grammars are combined","/**\n * Combined Grammar Index\n * \n * Exports all grammars and provides a unified grammar for parsing.\n */\n\nimport { Rule, choice } from './grammar-dsl';\nimport { DOCUMENT_GRAMMAR } from './document-grammar';\nimport { AGENT_GRAMMAR } from './agent-grammar';\nimport { DIFF_GRAMMAR } from './diff-grammar';\n\n// Combined grammar with all rules\nexport const GRAMMAR: Record<string, Rule> = {\n  // Root types\n  root: choice(\n    'document',\n    'agent', \n    'diff'\n  ),\n\n  // Merge all grammar rules\n  ...DOCUMENT_GRAMMAR,\n  ...AGENT_GRAMMAR,\n  ...DIFF_GRAMMAR\n};\n\n// Export individual grammars\nexport { DOCUMENT_GRAMMAR } from './document-grammar';\nexport { AGENT_GRAMMAR } from './agent-grammar';\nexport { DIFF_GRAMMAR } from './diff-grammar';\n\n// Export DSL\nexport * from './grammar-dsl';","/**\n * Grammar Compiler - Transforms grammar into usable structures\n * \n * This compiler takes our EBNF-style grammar and generates:\n * 1. Element-to-type mappings\n * 2. Validation functions\n * 3. AST type definitions\n * 4. Schema for backward compatibility\n */\n\nimport type { Rule, AttributeDef } from './grammar';\n\n// Define types locally since we removed schema.ts\nexport interface ElementSchema {\n  element: string;\n  type?: string;\n  block: boolean;\n  content?: 'text' | 'rich' | 'json' | 'none';\n  attributes?: Record<string, AttributeDef>;\n}\n\nexport interface ValidationError {\n  type: 'attribute' | 'content' | 'structure';\n  message: string;\n  path?: string;\n}\n\nexport interface CompiledGrammar {\n  // Element name -> AST type mapping\n  elementToType: Record<string, string>;\n  \n  // AST type -> element name(s) mapping\n  typeToElements: Record<string, string[]>;\n  \n  // Element name -> schema mapping (for compatibility)\n  elementSchemas: Record<string, ElementSchema>;\n  \n  // Validation functions\n  isValidElement: (element: string) => boolean;\n  isValidChild: (parentType: string, childElement: string) => boolean;\n  validateAttributes: (element: string, attrs: Record<string, unknown>) => ValidationError[];\n  \n  // Type information\n  blockTypes: Set<string>;\n  inlineElements: Set<string>;\n}\n\nexport class GrammarCompiler {\n  private grammar: Record<string, Rule>;\n  private compiled: CompiledGrammar | null = null;\n\n  constructor(grammar: Record<string, Rule>) {\n    this.grammar = grammar;\n  }\n\n  /**\n   * Compile the grammar into usable structures\n   */\n  compile(): CompiledGrammar {\n    if (this.compiled) return this.compiled;\n\n    const elementToType: Record<string, string> = {};\n    const typeToElements: Record<string, string[]> = {};\n    const elementSchemas: Record<string, ElementSchema> = {};\n    const blockTypes = new Set<string>();\n    const inlineElements = new Set<string>();\n\n    // First pass: collect all terminals and their types\n    const terminals = this.collectTerminals();\n    \n    // Build element mappings\n    for (const [ruleName, terminal] of terminals) {\n      const element = terminal.element;\n      if (element.startsWith('_')) continue; // Skip pseudo-elements\n\n      // Determine AST type\n      const astType = this.inferAstType(element, ruleName);\n      \n      // Element -> Type mapping\n      elementToType[element] = astType;\n      \n      // Type -> Elements mapping\n      if (!typeToElements[astType]) {\n        typeToElements[astType] = [];\n      }\n      typeToElements[astType].push(element);\n\n      // Build schema\n      elementSchemas[element] = {\n        element: element,\n        type: astType,\n        block: this.isBlockRule(ruleName),\n        attributes: terminal.attributes,\n        content: terminal.content as 'text' | 'rich' | 'json' | 'none' | undefined,\n      };\n\n      // Classify as block or inline\n      if (this.isBlockRule(ruleName)) {\n        blockTypes.add(astType);\n      } else if (this.isInlineRule(ruleName)) {\n        inlineElements.add(element);\n      }\n    }\n\n    // Build validation functions\n    const isValidElement = (element: string) => element in elementToType;\n    \n    const isValidChild = (parentType: string, childElement: string) => {\n      // Find rules that define valid children for this parent type\n      const rule = this.findRuleByType(parentType);\n      if (!rule) return false;\n      \n      return this.isValidInContext(rule, childElement);\n    };\n\n    const validateAttributes = (element: string, attrs: Record<string, unknown>) => {\n      const schema = elementSchemas[element];\n      if (!schema || !schema.attributes) return [];\n      \n      return this.validateAttrs(attrs, schema.attributes, element);\n    };\n\n    this.compiled = {\n      elementToType,\n      typeToElements,\n      elementSchemas,\n      isValidElement,\n      isValidChild,\n      validateAttributes,\n      blockTypes,\n      inlineElements,\n    };\n\n    return this.compiled;\n  }\n\n  /**\n   * Collect all terminal rules with their contexts\n   */\n  private collectTerminals(): Map<string, { element: string; attributes?: Record<string, AttributeDef>; content?: string }> {\n    const terminals = new Map();\n    const visited = new Set<string>();\n\n    const visit = (ruleName: string, rule: Rule) => {\n      // Avoid infinite recursion\n      const key = `${ruleName}:${JSON.stringify(rule)}`;\n      if (visited.has(key)) return;\n      visited.add(key);\n\n      switch (rule.type) {\n        case 'terminal':\n          terminals.set(ruleName, {\n            element: rule.element,\n            attributes: rule.attributes,\n            content: rule.content,\n          });\n          break;\n\n        case 'choice':\n        case 'sequence':\n          rule.rules.forEach((r, i) => {\n            if (r.type === 'ref') {\n              visit(r.name, this.grammar[r.name]);\n            } else {\n              visit(`${ruleName}[${i}]`, r);\n            }\n          });\n          break;\n\n        case 'repeat':\n        case 'optional':\n          if (rule.rule.type === 'ref') {\n            visit(rule.rule.name, this.grammar[rule.rule.name]);\n          } else {\n            visit(`${ruleName}:inner`, rule.rule);\n          }\n          break;\n\n        case 'ref':\n          if (this.grammar[rule.name]) {\n            visit(rule.name, this.grammar[rule.name]);\n          }\n          break;\n      }\n    };\n\n    // Start from all top-level rules\n    for (const [name, rule] of Object.entries(this.grammar)) {\n      visit(name, rule);\n    }\n\n    return terminals;\n  }\n\n  /**\n   * Infer AST type from element name and rule context\n   */\n  private inferAstType(element: string, ruleName: string): string {\n    // Special cases\n    const typeMap: Record<string, string> = {\n      'p': 'paragraph',\n      'paragraph': 'paragraph',\n      'h1': 'heading',\n      'h2': 'heading',\n      'h3': 'heading',\n      'h4': 'heading',\n      'h5': 'heading',\n      'h6': 'heading',\n      'heading': 'heading',\n      'fncall': 'function_call',\n      'bulletlistitem': 'bulletListItem',\n      'numberedlistitem': 'numberedListItem',\n      'checklistitem': 'checklistItem',\n      'tool:description': '_tool_description',\n      'tool:definition': '_tool_definition',\n    };\n\n    return typeMap[element] || element.replace(/[:-]/g, '_');\n  }\n\n  /**\n   * Check if a rule represents a block element\n   */\n  private isBlockRule(ruleName: string): boolean {\n    // Check if this rule is referenced by block-level rules\n    return ruleName.includes('block') || \n           ruleName === 'paragraph' ||\n           ruleName === 'heading' ||\n           ruleName === 'list' ||\n           ruleName === 'code' ||\n           ruleName === 'quote' ||\n           ruleName === 'separator' ||\n           ruleName === 'tool-block';\n  }\n\n  /**\n   * Check if a rule represents an inline element\n   */\n  private isInlineRule(ruleName: string): boolean {\n    return ruleName.includes('styled-text') ||\n           ruleName === 'mention' ||\n           ruleName === 'variable' ||\n           ruleName === 'link' ||\n           ruleName === 'text';\n  }\n\n  /**\n   * Find a rule that produces the given AST type\n   */\n  private findRuleByType(astType: string): Rule | null {\n    // This is a simplified version - in practice we'd need a more\n    // sophisticated mapping from AST types back to grammar rules\n    const ruleMap: Record<string, string> = {\n      'tool': 'tool-block',\n      'list': 'list',\n      'function_call': 'function-call',\n      'trigger': 'trigger',\n    };\n\n    const ruleName = ruleMap[astType];\n    return ruleName ? this.grammar[ruleName] : null;\n  }\n\n  /**\n   * Check if an element is valid in a given context\n   */\n  private isValidInContext(rule: Rule, element: string): boolean {\n    switch (rule.type) {\n      case 'terminal':\n        return rule.element === element;\n\n      case 'choice':\n        return rule.rules.some(r => this.isValidInContext(r, element));\n\n      case 'sequence':\n        // Check all parts of sequence\n        return rule.rules.some(r => this.isValidInContext(r, element));\n\n      case 'repeat':\n      case 'optional':\n        return this.isValidInContext(rule.rule, element);\n\n      case 'ref':\n        const referenced = this.grammar[rule.name];\n        return referenced ? this.isValidInContext(referenced, element) : false;\n\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Validate attributes against schema\n   */\n  private validateAttrs(\n    attrs: Record<string, unknown>,\n    schema: Record<string, AttributeDef>,\n    element: string\n  ): ValidationError[] {\n    const errors: ValidationError[] = [];\n\n    // Check required attributes\n    for (const [name, def] of Object.entries(schema)) {\n      if (def.required && !(name in attrs)) {\n        errors.push({\n          type: 'attribute',\n          path: `${element}@${name}`,\n          message: `Required attribute missing: ${name}`,\n        });\n      }\n    }\n\n    // Validate present attributes\n    for (const [name, value] of Object.entries(attrs)) {\n      const def = schema[name];\n      if (!def) continue; // Unknown attributes allowed\n\n      // Type validation\n      if (def.type === 'enum' && def.values && !def.values.includes(value as string)) {\n        errors.push({\n          type: 'attribute',\n          path: `${element}@${name}`,\n          message: `Invalid value: must be one of ${def.values.join(', ')}`,\n        });\n      }\n\n      // Pattern validation\n      if (def.pattern && typeof value === 'string' && !def.pattern.test(value)) {\n        errors.push({\n          type: 'attribute',\n          path: `${element}@${name}`,\n          message: `Invalid format for ${name}`,\n        });\n      }\n\n      // Custom validation\n      if (def.validate) {\n        const error = def.validate(value);\n        if (error) {\n          errors.push({\n            type: 'attribute',\n            path: `${element}@${name}`,\n            message: error,\n          });\n        }\n      }\n    }\n\n    return errors;\n  }\n\n  /**\n   * Generate TypeScript AST types from grammar\n   */\n  generateTypes(): string {\n    const compiled = this.compile();\n    const types: string[] = [];\n\n    // Generate block type union\n    const blockTypeNames = Array.from(compiled.blockTypes)\n      .map(t => `'${t}'`)\n      .join(' | ');\n    types.push(`export type BlockType = ${blockTypeNames};`);\n\n    // Generate element mappings\n    types.push('\\nexport const ELEMENT_TO_TYPE = {');\n    for (const [element, type] of Object.entries(compiled.elementToType)) {\n      types.push(`  '${element}': '${type}',`);\n    }\n    types.push('} as const;');\n\n    return types.join('\\n');\n  }\n}","/**\n * Document Executor for Idyllic Engine\n * \n * Handles execution of executable nodes within documents,\n * maintaining execution state and providing context to tools.\n */\n\nimport { z } from 'zod';\nimport type { \n  IdyllDocument, \n  Node, \n  Block, \n  ExecutableNode, \n  ExecutableBlock, \n  RichContent \n} from './ast';\nimport type {\n  ExecutionState,\n  ExecutionReport,\n  ExecutionOptions,\n  NodeExecutionResult,\n  BlockExecutionResult,\n  NodeExecutionContext,\n  BlockExecutionContext,\n  NodeExecutionError,\n  BlockExecutionError,\n  ExecutionMetadata,\n  ExecutionRequest,\n} from './execution-types';\n\nexport class DocumentExecutor<TApi = any> {\n  private options: ExecutionOptions<TApi>;\n  \n  constructor(options: ExecutionOptions<TApi>) {\n    this.options = {\n      stopOnError: false,\n      timeout: 30000,\n      ...options,\n    };\n  }\n  \n  /**\n   * Execute a single node or entire document\n   */\n  async execute(request: ExecutionRequest): Promise<ExecutionReport> {\n    if (request.mode === 'single') {\n      return this.executeSingleNode(request.document, (request as any).nodeId || (request as any).blockId!);\n    } else {\n      return this.executeDocument(request.document);\n    }\n  }\n  \n  /**\n   * Execute all executable nodes in a document\n   */\n  async executeDocument(document: IdyllDocument): Promise<ExecutionReport> {\n    const startTime = new Date();\n    const state: ExecutionState = new Map();\n    \n    // Find all executable nodes\n    const executableNodes = this.findExecutableNodes(document.nodes || (document as any).blocks);\n    const total = executableNodes.length;\n    \n    // Execute nodes sequentially\n    for (let i = 0; i < executableNodes.length; i++) {\n      const node = executableNodes[i];\n      \n      // Progress callback\n      this.options.onProgress?.(node.id, i + 1, total);\n      \n      // Create context for this node\n      const context: NodeExecutionContext & { api?: TApi } = {\n        currentNodeId: node.id,\n        previousResults: new Map(state), // Copy current state\n        document,\n        api: this.options.api,\n      };\n      \n      // Execute the node\n      const result = await this.executeNode(node, context);\n      state.set(node.id, result);\n      \n      // Stop on error if requested\n      if (!result.success && this.options.stopOnError) {\n        break;\n      }\n    }\n    \n    const endTime = new Date();\n    \n    // Calculate metadata\n    const metadata: ExecutionMetadata = {\n      startTime,\n      endTime,\n      totalDuration: endTime.getTime() - startTime.getTime(),\n      nodesExecuted: state.size,\n      nodesSucceeded: Array.from(state.values()).filter(r => r.success).length,\n      nodesFailed: Array.from(state.values()).filter(r => !r.success).length,\n    };\n    \n    return { nodes: state, metadata };\n  }\n  \n  /**\n   * Execute a single node by ID\n   */\n  async executeSingleNode(\n    document: IdyllDocument, \n    nodeId: string\n  ): Promise<ExecutionReport> {\n    const startTime = new Date();\n    const state: ExecutionState = new Map();\n    \n    // Find the node\n    const node = this.findNodeById(document.nodes || (document as any).blocks, nodeId);\n    if (!node) {\n      throw new Error(`Node with ID ${nodeId} not found`);\n    }\n    \n    if (!this.isExecutableNode(node)) {\n      throw new Error(`Node ${nodeId} is not executable`);\n    }\n    \n    // Build context with previous results (all nodes before this one)\n    const previousResults = this.getPreviousResults(document, nodeId);\n    \n    const context: NodeExecutionContext & { api?: TApi } = {\n      currentNodeId: nodeId,\n      previousResults,\n      document,\n      api: this.options.api,\n    };\n    \n    // Execute the node\n    const result = await this.executeNode(node as ExecutableNode, context);\n    state.set(nodeId, result);\n    \n    const endTime = new Date();\n    \n    const metadata: ExecutionMetadata = {\n      startTime,\n      endTime,\n      totalDuration: endTime.getTime() - startTime.getTime(),\n      nodesExecuted: 1,\n      nodesSucceeded: result.success ? 1 : 0,\n      nodesFailed: result.success ? 0 : 1,\n    };\n    \n    return { nodes: state, metadata };\n  }\n  \n  /**\n   * Execute a single executable node\n   */\n  private async executeNode(\n    node: ExecutableNode,\n    context: NodeExecutionContext & { api?: TApi }\n  ): Promise<NodeExecutionResult> {\n    const startTime = Date.now();\n    \n    try {\n      // Resolve the tool\n      const tool = this.options.tools[node.tool];\n      if (!tool) {\n        throw new Error(`Tool not found: ${node.tool}`);\n      }\n      \n      // Validate parameters\n      let validatedParams: any;\n      try {\n        validatedParams = tool.schema.parse(node.parameters);\n      } catch (error) {\n        if (error instanceof z.ZodError) {\n          throw new Error(`Invalid parameters: ${error.errors.map(e => e.message).join(', ')}`);\n        }\n        throw error;\n      }\n      \n      // Extract content as string\n      const content = this.extractContent(node.instructions);\n      \n      // Execute with timeout\n      const timeoutPromise = new Promise((_, reject) => {\n        setTimeout(() => reject(new Error('Execution timeout')), this.options.timeout);\n      });\n      \n      const data = await Promise.race([\n        tool.execute(validatedParams, content, context),\n        timeoutPromise,\n      ]);\n      \n      return {\n        success: true,\n        data,\n        duration: Date.now() - startTime,\n        timestamp: new Date(),\n      };\n      \n    } catch (error) {\n      const errorObj: NodeExecutionError = {\n        message: error instanceof Error ? error.message : String(error),\n        code: 'EXECUTION_ERROR',\n        details: error,\n      };\n      \n      return {\n        success: false,\n        error: errorObj,\n        duration: Date.now() - startTime,\n        timestamp: new Date(),\n      };\n    }\n  }\n  \n  /**\n   * Find all executable nodes in document\n   */\n  private findExecutableNodes(nodes: Node[]): ExecutableNode[] {\n    const executable: ExecutableNode[] = [];\n    \n    for (const node of nodes) {\n      if (this.isExecutableNode(node)) {\n        executable.push(node as ExecutableNode);\n      }\n      \n      // Check children recursively\n      if ('children' in node && node.children) {\n        executable.push(...this.findExecutableNodes(node.children));\n      }\n    }\n    \n    return executable;\n  }\n  \n  /**\n   * Find a node by ID\n   */\n  private findNodeById(nodes: Node[], id: string): Node | null {\n    for (const node of nodes) {\n      if (node.id === id) {\n        return node;\n      }\n      \n      // Check children\n      if ('children' in node && node.children) {\n        const found = this.findNodeById(node.children, id);\n        if (found) return found;\n      }\n    }\n    \n    return null;\n  }\n  \n  /**\n   * Get results from all nodes before the given node\n   */\n  private getPreviousResults(document: IdyllDocument, beforeNodeId: string): ExecutionState {\n    const results: ExecutionState = new Map();\n    const executableNodes = this.findExecutableNodes(document.nodes || (document as any).blocks);\n    \n    // Find all nodes before the target node\n    for (const node of executableNodes) {\n      if (node.id === beforeNodeId) {\n        break;\n      }\n      // Note: We don't have actual results in this case, \n      // this would be populated from prior execution\n      // For now, return empty state\n    }\n    \n    return results;\n  }\n  \n  /**\n   * Check if a node is executable\n   */\n  private isExecutableNode(node: Node): boolean {\n    return node.type === 'function_call' || node.type === 'trigger';\n  }\n  \n  /**\n   * Extract text content from rich content\n   */\n  private extractContent(content?: RichContent[]): string {\n    if (!content) return '';\n    \n    return content\n      .map(item => {\n        if ('text' in item) {\n          return item.text;\n        }\n        return '';\n      })\n      .join('');\n  }\n}","/**\n * Tool Registry for Idyllic Engine\n * \n * Provides utilities for managing and creating tool registries\n * with proper type safety and validation.\n */\n\nimport { z } from 'zod';\nimport type { ToolRegistry, ToolDefinition, BlockExecutionContext } from './execution-types';\n\n// Re-export types for external use\nexport type { ToolRegistry, ToolDefinition } from './execution-types';\n\n/**\n * Create a type-safe tool registry\n */\nexport function createToolRegistry<TApi = any>(\n  tools: ToolRegistry<TApi>\n): ToolRegistry<TApi> {\n  return tools;\n}\n\n/**\n * Define a single tool with type inference\n */\nexport function defineTool<TParams = any, TApi = any>(\n  definition: {\n    schema: z.ZodSchema<TParams>;\n    execute: (params: TParams, content: string, context: BlockExecutionContext & { api?: TApi }) => Promise<any> | any;\n    description?: string;\n  }\n): ToolDefinition<TParams, TApi> {\n  return definition;\n}\n\n/**\n * Merge multiple tool registries\n */\nexport function mergeToolRegistries<TApi = any>(\n  ...registries: ToolRegistry<TApi>[]\n): ToolRegistry<TApi> {\n  return registries.reduce((merged, registry) => {\n    return { ...merged, ...registry };\n  }, {} as ToolRegistry<TApi>);\n}\n\n/**\n * Create a tool registry from a simple function map\n * (for quick testing without schemas)\n */\nexport function createSimpleRegistry<TApi = any>(\n  tools: Record<string, (params: any, content: string, context?: BlockExecutionContext & { api?: TApi }) => any>\n): ToolRegistry<TApi> {\n  const registry: ToolRegistry<TApi> = {};\n  \n  for (const [name, fn] of Object.entries(tools)) {\n    registry[name] = {\n      schema: z.any(), // Accept any params\n      execute: (params, content, context) => fn(params, content, context),\n    };\n  }\n  \n  return registry;\n}","/**\n * Tool naming utilities for Idyll Engine\n * \n * Handles transformation between Idyll tool names (module:function) \n * and external platform requirements.\n */\n\n/**\n * Transform Idyll tool name to Azure function name\n * \"module:function\"  \"module--function\"\n * \"function\"  \"function\" (no module)\n */\nexport function toAzureFunctionName(idyllToolName: string): string {\n  return idyllToolName.replace(':', '--');\n}\n\n/**\n * Transform Azure function name back to Idyll tool name\n * \"module--function\"  \"module:function\"\n * \"function\"  \"function\" (no module)\n */\nexport function fromAzureFunctionName(azureFunctionName: string): string {\n  // Double hyphen is our separator\n  if (azureFunctionName.includes('--')) {\n    return azureFunctionName.replace('--', ':');\n  }\n  // No separator means no module namespace\n  return azureFunctionName;\n}\n\n/**\n * Validate that a tool name follows Idyll conventions\n * Must be valid JS identifiers: [module:]function\n */\nexport function validateToolName(toolName: string): { valid: boolean; error?: string } {\n  const pattern = /^([a-zA-Z_$][a-zA-Z0-9_$]*:)?[a-zA-Z_$][a-zA-Z0-9_$]*$/;\n  \n  if (!pattern.test(toolName)) {\n    return {\n      valid: false,\n      error: 'Tool name must be valid JS identifiers in format \"module:function\" or \"function\"'\n    };\n  }\n  \n  return { valid: true };\n}\n\n/**\n * Parse a tool name into module and function parts\n */\nexport function parseToolName(toolName: string): { module?: string; function: string } {\n  const colonIndex = toolName.indexOf(':');\n  \n  if (colonIndex === -1) {\n    return { function: toolName };\n  }\n  \n  return {\n    module: toolName.substring(0, colonIndex),\n    function: toolName.substring(colonIndex + 1)\n  };\n}\n\n/**\n * Build a tool name from module and function parts\n */\nexport function buildToolName(module: string | undefined, functionName: string): string {\n  return module ? `${module}:${functionName}` : functionName;\n}","/**\n * Document validation logic\n */\n\nimport {\n  Node,\n  Block,\n  IdyllDocument,\n  isExecutableNode,\n  isExecutableBlock,\n  extractMentions,\n  extractVariables,\n  traverseNodes,\n  traverseBlocks,\n} from './ast';\nimport { ValidationContext, ValidationError } from '../types';\n\n// ============================================\n// Validation Types\n// ============================================\n\nexport interface ValidationResult {\n  valid: boolean;\n  errors: ValidationIssue[];\n  warnings: ValidationIssue[];\n}\n\nexport interface ValidationIssue {\n  type: 'error' | 'warning';\n  code: string;\n  message: string;\n  nodeId?: string;\n  path?: string[];\n}\n\n// ============================================\n// Main Validation Function\n// ============================================\n\n/**\n * Validate a document structure and optionally its references\n */\nexport async function validateDocument(\n  document: IdyllDocument,\n  context?: ValidationContext\n): Promise<ValidationResult> {\n  const errors: ValidationIssue[] = [];\n  const warnings: ValidationIssue[] = [];\n  \n  // Phase 1: Structure validation\n  validateStructure(document, errors, warnings);\n  \n  // Phase 2: Reference validation (if context provided)\n  if (context) {\n    await validateReferences(document, context, errors, warnings);\n  }\n  \n  return {\n    valid: errors.length === 0,\n    errors,\n    warnings,\n  };\n}\n\n// ============================================\n// Structure Validation\n// ============================================\n\n/**\n * Validate document structure\n */\nfunction validateStructure(\n  document: IdyllDocument,\n  errors: ValidationIssue[],\n  warnings: ValidationIssue[]\n): void {\n  // Validate document has an ID\n  if (!document.id) {\n    errors.push({\n      type: 'error',\n      code: 'MISSING_DOCUMENT_ID',\n      message: 'Document must have an ID',\n    });\n  }\n  \n  // Validate document has nodes\n  if (!document.nodes || document.nodes.length === 0) {\n    warnings.push({\n      type: 'warning',\n      code: 'EMPTY_DOCUMENT',\n      message: 'Document has no content nodes',\n    });\n  }\n  \n  // Validate each node\n  const nodeIds = new Set<string>();\n  for (const node of traverseNodes(document.nodes)) {\n    validateNode(node, nodeIds, errors, warnings);\n  }\n}\n\n/**\n * Validate a single node\n */\nfunction validateNode(\n  node: Node,\n  nodeIds: Set<string>,\n  errors: ValidationIssue[],\n  warnings: ValidationIssue[]\n): void {\n  const nodeId = node.id || 'unknown';\n  \n  // Check for duplicate IDs\n  if (node.id && nodeIds.has(node.id)) {\n    errors.push({\n      type: 'error',\n      code: 'DUPLICATE_NODE_ID',\n      message: `Duplicate node ID: ${node.id}`,\n      nodeId: node.id,\n    });\n  }\n  if (node.id) {\n    nodeIds.add(node.id);\n  }\n  \n  // Validate node has required fields\n  if (!node.id) {\n    errors.push({\n      type: 'error',\n      code: 'MISSING_NODE_ID',\n      message: 'Node must have an ID',\n    });\n  }\n  \n  if (!node.type) {\n    errors.push({\n      type: 'error',\n      code: 'MISSING_NODE_TYPE',\n      message: 'Node must have a type',\n      nodeId,\n    });\n    return; // Can't validate further without type\n  }\n  \n  // Validate executable nodes\n  if (isExecutableNode(node)) {\n    if (!node.tool) {\n      errors.push({\n        type: 'error',\n        code: 'MISSING_TOOL',\n        message: 'Executable node must specify a tool',\n        nodeId,\n      });\n    }\n    \n    if (!node.parameters) {\n      warnings.push({\n        type: 'warning',\n        code: 'MISSING_PARAMETERS',\n        message: 'Executable node has no parameters',\n        nodeId,\n      });\n    }\n  }\n}\n\n// ============================================\n// Reference Validation\n// ============================================\n\n/**\n * Validate document references (mentions, variables, tools)\n */\nasync function validateReferences(\n  document: IdyllDocument,\n  context: ValidationContext,\n  errors: ValidationIssue[],\n  warnings: ValidationIssue[]\n): Promise<void> {\n  // Validate mentions\n  if (context.validateMention) {\n    const mentions = extractMentions(document.nodes);\n    for (const mention of mentions) {\n      if (!context.validateMention(mention)) {\n        errors.push({\n          type: 'error',\n          code: 'INVALID_MENTION',\n          message: `Invalid ${mention.mentionType} mention: ${mention.id}`,\n        });\n      }\n    }\n  }\n  \n  // Validate variables\n  if (context.validateVariable) {\n    const variables = extractVariables(document.nodes);\n    for (const variable of variables) {\n      const result = context.validateVariable(variable);\n      if (!result.valid) {\n        errors.push({\n          type: 'error',\n          code: 'INVALID_VARIABLE',\n          message: `Invalid variable: ${variable.name}`,\n        });\n      }\n    }\n  }\n  \n  // Validate tools\n  if (context.validateTool) {\n    for (const node of traverseNodes(document.nodes)) {\n      if (isExecutableNode(node) && node.tool) {\n        if (!context.validateTool(node.tool)) {\n          errors.push({\n            type: 'error',\n            code: 'INVALID_TOOL',\n            message: `Tool not found: ${node.tool}`,\n            nodeId: node.id || 'unknown',\n          });\n        }\n      }\n    }\n  }\n}\n\n// ============================================\n// Validation Utilities\n// ============================================\n\n/**\n * Create a validation error from issues\n */\nexport function createValidationError(result: ValidationResult): ValidationError {\n  const errorMessages = result.errors.map(e => e.message);\n  return new ValidationError(\n    `Document validation failed with ${result.errors.length} error(s)`,\n    errorMessages,\n    { issues: result.errors }\n  );\n}\n\n/**\n * Format validation issues for display\n */\nexport function formatValidationIssues(issues: ValidationIssue[]): string {\n  return issues\n    .map(issue => {\n      const prefix = issue.type === 'error' ? '' : '';\n      const location = issue.nodeId ? ` (node: ${issue.nodeId})` : '';\n      return `${prefix} ${issue.message}${location}`;\n    })\n    .join('\\n');\n}","/**\n * Variable Resolution System for Idyllic Engine\n * \n * Handles the resolution of variables in custom tools using AI interpolation\n */\n\nimport type { Block, RichContent, VariableElement } from './ast';\nimport { isVariable, traverseBlocks } from './ast';\n\n/**\n * Variable with metadata for resolution\n */\nexport interface VariableDefinition {\n  name: string;\n  prompt?: string;\n  firstOccurrenceBlockId: string;\n  firstOccurrenceIndex: number;\n}\n\n/**\n * Context for variable resolution\n */\nexport interface VariableResolutionContext {\n  /** Agent-provided context (rich content) */\n  agentContext: string;\n  \n  /** Document context (surrounding blocks) */\n  documentContext?: string;\n  \n  /** Inherited agent context/personality */\n  inheritedContext?: Record<string, unknown>;\n}\n\n/**\n * Variable resolution result\n */\nexport interface VariableResolutionResult {\n  /** Resolved variable values */\n  variables: Map<string, string>;\n  \n  /** Any errors during resolution */\n  errors?: Array<{ variable: string; error: string }>;\n}\n\n/**\n * Extract all unique variables from blocks\n * Follows declare-once, use-many pattern\n */\nexport function extractVariableDefinitions(blocks: Block[]): VariableDefinition[] {\n  const definitions = new Map<string, VariableDefinition>();\n  const seenNames = new Set<string>();\n  \n  let globalIndex = 0;\n  \n  for (const block of traverseBlocks(blocks)) {\n    if ('content' in block && Array.isArray(block.content)) {\n      processContent(block.content, block.id);\n    }\n    \n    // Check executable block instructions\n    if ('instructions' in block && block.instructions) {\n      processContent(block.instructions, block.id);\n    }\n  }\n  \n  function processContent(content: RichContent[], blockId: string) {\n    for (const item of content) {\n      if (isVariable(item)) {\n        // First occurrence declares the variable\n        if (!seenNames.has(item.name)) {\n          seenNames.add(item.name);\n          definitions.set(item.name, {\n            name: item.name,\n            prompt: item.prompt,\n            firstOccurrenceBlockId: blockId,\n            firstOccurrenceIndex: globalIndex++,\n          });\n        }\n      } else if ('content' in item && Array.isArray(item.content)) {\n        // Recurse into nested content\n        processContent(item.content, blockId);\n      }\n    }\n  }\n  \n  return Array.from(definitions.values());\n}\n\n/**\n * Check for variable redeclaration errors\n */\nexport function checkVariableRedeclaration(blocks: Block[]): Array<{ name: string; error: string }> {\n  const errors: Array<{ name: string; error: string }> = [];\n  const declarations = new Map<string, { blockId: string; prompt?: string }>();\n  \n  for (const block of traverseBlocks(blocks)) {\n    const variables = extractVariablesFromBlock(block);\n    \n    for (const variable of variables) {\n      const existing = declarations.get(variable.name);\n      \n      if (existing) {\n        // Check if it's a redeclaration (different prompt)\n        if (variable.prompt && existing.prompt !== variable.prompt) {\n          errors.push({\n            name: variable.name,\n            error: `Variable \"${variable.name}\" redeclared with different prompt. Original: \"${existing.prompt}\", New: \"${variable.prompt}\"`,\n          });\n        }\n      } else if (variable.prompt) {\n        // First declaration with prompt\n        declarations.set(variable.name, {\n          blockId: block.id,\n          prompt: variable.prompt,\n        });\n      }\n    }\n  }\n  \n  return errors;\n}\n\n/**\n * Extract variables from a single block\n */\nfunction extractVariablesFromBlock(block: Block): VariableElement[] {\n  const variables: VariableElement[] = [];\n  \n  function extractFromContent(content: RichContent[]) {\n    for (const item of content) {\n      if (isVariable(item)) {\n        variables.push(item);\n      } else if ('content' in item && Array.isArray(item.content)) {\n        extractFromContent(item.content);\n      }\n    }\n  }\n  \n  if ('content' in block && Array.isArray(block.content)) {\n    extractFromContent(block.content);\n  }\n  \n  if ('instructions' in block && block.instructions) {\n    extractFromContent(block.instructions);\n  }\n  \n  return variables;\n}\n\n/**\n * Resolve variables using AI interpolation or fallback to mock\n */\nexport async function resolveVariables(\n  definitions: VariableDefinition[],\n  context: VariableResolutionContext\n): Promise<VariableResolutionResult> {\n  // Use mock resolution (AI resolution removed - model should be provided externally if needed)\n  const variables = new Map<string, string>();\n  const errors: Array<{ variable: string; error: string }> = [];\n  \n  for (const def of definitions) {\n    try {\n      const resolvedValue = await mockResolveVariable(def, context);\n      variables.set(def.name, resolvedValue);\n    } catch (error) {\n      errors.push({\n        variable: def.name,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      });\n    }\n  }\n  \n  return { variables, errors: errors.length > 0 ? errors : undefined };\n}\n\n/**\n * Mock variable resolution for testing\n * Replace with actual AI implementation\n */\nasync function mockResolveVariable(\n  definition: VariableDefinition,\n  context: VariableResolutionContext\n): Promise<string> {\n  // Simulate AI resolution based on variable name and context\n  const contextLower = context.agentContext.toLowerCase();\n  \n  switch (definition.name) {\n    case 'searchQuery':\n      if (contextLower.includes('ai breakthroughs')) {\n        return 'AI breakthroughs 2024';\n      }\n      if (contextLower.includes('machine learning')) {\n        return 'machine learning advances';\n      }\n      return 'technology news';\n      \n    case 'timeframe':\n      if (contextLower.includes('past month') || contextLower.includes('last month')) {\n        return 'past month';\n      }\n      if (contextLower.includes('past week') || contextLower.includes('last week')) {\n        return 'past week';\n      }\n      return 'recent';\n      \n    case 'focusArea':\n      if (contextLower.includes('practical')) {\n        return 'practical applications';\n      }\n      if (contextLower.includes('research')) {\n        return 'research developments';\n      }\n      return 'general overview';\n      \n    default:\n      // Use prompt as hint for resolution\n      if (definition.prompt) {\n        return `Resolved: ${definition.name} (${definition.prompt})`;\n      }\n      return `Resolved: ${definition.name}`;\n  }\n}\n\n/**\n * Apply resolved variable values to blocks\n * Updates variable elements with resolvedValue\n */\nexport function applyResolvedVariables(\n  blocks: Block[],\n  resolvedVariables: Map<string, string>\n): Block[] {\n  // Deep clone blocks to avoid mutation\n  const clonedBlocks = JSON.parse(JSON.stringify(blocks)) as Block[];\n  \n  for (const block of traverseBlocks(clonedBlocks)) {\n    if ('content' in block && Array.isArray(block.content)) {\n      block.content = applyToContent(block.content);\n    }\n    \n    if ('instructions' in block && block.instructions) {\n      block.instructions = applyToContent(block.instructions);\n    }\n  }\n  \n  function applyToContent(content: RichContent[]): RichContent[] {\n    return content.map(item => {\n      if (isVariable(item)) {\n        const resolvedValue = resolvedVariables.get(item.name);\n        if (resolvedValue !== undefined) {\n          return {\n            ...item,\n            resolvedValue,\n          } as VariableElement;\n        }\n      } else if ('content' in item && Array.isArray(item.content)) {\n        return {\n          ...item,\n          content: applyToContent(item.content),\n        };\n      }\n      return item;\n    });\n  }\n  \n  return clonedBlocks;\n}\n\n/**\n * Get interpolated text content with variables replaced\n */\nexport function interpolateContent(\n  content: RichContent[],\n  resolvedVariables: Map<string, string>\n): string {\n  let result = '';\n  \n  for (const item of content) {\n    if (item.type === 'text') {\n      result += item.text;\n    } else if (isVariable(item)) {\n      const value = resolvedVariables.get(item.name);\n      result += value || `{{${item.name}}}`;\n    } else if ('content' in item && Array.isArray(item.content)) {\n      result += interpolateContent(item.content, resolvedVariables);\n    }\n  }\n  \n  return result;\n}","/**\n * Custom Tool Executor for Idyllic Engine\n * \n * Executes custom tools defined with <tool> blocks, handling\n * variable resolution and multi-step execution\n */\n\nimport type { \n  Node,\n  Block, \n  ContentNode,\n  ContentBlock, \n  ExecutableNode,\n  ExecutableBlock, \n  IdyllDocument \n} from './ast';\nimport { isExecutableNode, isExecutableBlock, getExecutableNodes, getExecutableBlocks } from './ast';\nimport type { \n  ToolExecutionContext, \n  ExecutionOptions,\n  NodeExecutionResult,\n  BlockExecutionResult \n} from './execution-types';\nimport { DocumentExecutor } from './executor';\nimport {\n  extractVariableDefinitions,\n  checkVariableRedeclaration,\n  resolveVariables,\n  applyResolvedVariables,\n  interpolateContent,\n  type VariableResolutionContext,\n} from './variable-resolution';\n\n/**\n * Options for custom tool execution\n */\nexport interface CustomToolExecutionOptions<TApi = any> extends ExecutionOptions<TApi> {\n  /** Agent context provided when invoking the tool */\n  agentContext: string;\n  \n  /** Inherited context from agent */\n  inheritedContext?: Record<string, unknown>;\n}\n\n/**\n * Execute a custom tool defined as a ContentNode\n */\nexport async function executeCustomTool<TApi = any>(\n  toolNode: ContentNode,\n  options: CustomToolExecutionOptions<TApi>\n): Promise<ToolExecutionContext> {\n  const startTime = Date.now();\n  \n  // Validate it's a tool node\n  if (toolNode.type !== 'tool') {\n    throw new Error('Node is not a tool');\n  }\n  \n  const toolName = (toolNode.props?.title as string) || 'Unnamed Tool';\n  \n  // Get tool definition nodes (children)\n  const definitionNodes = toolNode.children || [];\n  \n  // Check for variable redeclaration errors\n  const redeclarationErrors = checkVariableRedeclaration(definitionNodes);\n  if (redeclarationErrors.length > 0) {\n    throw new Error(\n      `Variable redeclaration errors: ${redeclarationErrors.map(e => e.error).join('; ')}`\n    );\n  }\n  \n  // Extract variable definitions\n  const variableDefinitions = extractVariableDefinitions(definitionNodes);\n  \n  // Resolve variables\n  const resolutionContext: VariableResolutionContext = {\n    agentContext: options.agentContext,\n    inheritedContext: options.inheritedContext,\n  };\n  \n  const resolutionResult = await resolveVariables(variableDefinitions, resolutionContext);\n  \n  if (resolutionResult.errors) {\n    console.warn('Variable resolution errors:', resolutionResult.errors);\n  }\n  \n  // Apply resolved variables to nodes\n  const nodesWithVariables = applyResolvedVariables(\n    definitionNodes,\n    resolutionResult.variables\n  );\n  \n  // Interpolate content in executable nodes\n  const interpolatedNodes = interpolateExecutableNodes(\n    nodesWithVariables,\n    resolutionResult.variables\n  );\n  \n  // Create a document for execution\n  const executionDocument: IdyllDocument = {\n    id: `tool-exec-${Date.now()}`,\n    nodes: interpolatedNodes,\n  };\n  \n  // Execute using DocumentExecutor\n  const executor = new DocumentExecutor(options);\n  const report = await executor.execute({\n    mode: 'document',\n    document: executionDocument,\n    options,\n  });\n  \n  // Build execution context\n  const executionContext: ToolExecutionContext = {\n    variables: resolutionResult.variables,\n    nodes: report.nodes,\n    metadata: {\n      toolName,\n      duration: Date.now() - startTime,\n      nodesExecuted: report.metadata.nodesExecuted,\n      nodesSucceeded: report.metadata.nodesSucceeded,\n      nodesFailed: report.metadata.nodesFailed,\n    },\n    toolDefinition: toolNode,\n  };\n  \n  return executionContext;\n}\n\n/**\n * Interpolate variables in executable node content\n */\nfunction interpolateExecutableNodes(\n  nodes: Node[],\n  resolvedVariables: Map<string, string>\n): Node[] {\n  return nodes.map(node => {\n    if (isExecutableNode(node) && node.instructions) {\n      // Interpolate the instructions to create the content string\n      const interpolatedContent = interpolateContent(\n        node.instructions,\n        resolvedVariables\n      );\n      \n      // Return a modified node with interpolated content\n      // Note: We're modifying the instructions to be a simple text content\n      // In a real implementation, we might want to preserve the structure\n      return {\n        ...node,\n        instructions: [{\n          type: 'text',\n          text: interpolatedContent,\n        }],\n      } as ExecutableNode;\n    }\n    \n    // Recursively handle children\n    if ('children' in node && node.children) {\n      return {\n        ...node,\n        children: interpolateExecutableNodes(node.children, resolvedVariables),\n      };\n    }\n    \n    return node;\n  });\n}\n\n/**\n * Extract relevant result from tool execution context\n * This would be used by the subprocess to return only what's needed\n */\nexport function extractRelevantResult(\n  context: ToolExecutionContext,\n  extractionHint?: string\n): unknown {\n  // Get the last successful result by default\n  const results = Array.from(context.nodes.values());\n  const lastSuccess = results\n    .reverse()\n    .find(r => r.success);\n  \n  if (lastSuccess) {\n    return lastSuccess.data;\n  }\n  \n  // If no successful results, return error summary\n  const errors = results\n    .filter(r => !r.success)\n    .map(r => r.error?.message || 'Unknown error');\n  \n  return {\n    success: false,\n    errors,\n    toolName: context.metadata.toolName,\n  };\n}\n\n/**\n * Parse custom tool from document\n */\nexport function parseCustomTool(document: IdyllDocument): ContentNode | null {\n  for (const node of document.nodes) {\n    if ('type' in node && node.type === 'tool') {\n      return node as ContentNode;\n    }\n  }\n  return null;\n}","/**\n * Diff Application Logic for Idyll Documents\n * \n * Applies edit operations to document nodes with proper error handling.\n */\n\nimport { \n  Node, \n  Block, \n  EditOperation, \n  EditAttrOperation,\n  EditContentOperation,\n  EditParamsOperation,\n  EditIdOperation,\n  InsertOperation,\n  DeleteOperation,\n  ReplaceOperation,\n  MoveOperation,\n  RichContent \n} from './ast';\nimport { v4 as uuidv4 } from 'uuid';\n\nexport interface DiffResult {\n  success: boolean;\n  nodes?: Node[];\n  error?: string;\n}\n\n/**\n * Apply a list of edit operations to document nodes\n */\nexport function applyDiff(nodes: Node[], operations: EditOperation[]): DiffResult {\n  try {\n    let result = [...nodes];\n\n    for (const operation of operations) {\n      switch (operation.type) {\n        case 'edit:attr':\n          result = applyEditAttr(result, operation);\n          break;\n\n        case 'edit:content':\n          result = applyEditContent(result, operation);\n          break;\n\n        case 'edit:params':\n          result = applyEditParams(result, operation);\n          break;\n\n        case 'edit:id':\n          result = applyEditId(result, operation);\n          break;\n\n        case 'insert':\n          result = applyInsert(result, operation);\n          break;\n\n        case 'delete':\n          result = applyDelete(result, operation);\n          break;\n\n        case 'replace':\n          result = applyReplace(result, operation);\n          break;\n\n        case 'move':\n          result = applyMove(result, operation);\n          break;\n\n        default:\n          throw new Error(`Unknown operation type: ${(operation as any).type}`);\n      }\n    }\n\n    return { success: true, nodes: result };\n  } catch (error) {\n    return { \n      success: false, \n      nodes,\n      error: error instanceof Error ? error.message : String(error) \n    };\n  }\n}\n\n// ============================================\n// Operation Application Functions\n// ============================================\n\nfunction applyEditAttr(nodes: Node[], op: EditAttrOperation): Node[] {\n  let found = false;\n  \n  // Handle backward compatibility\n  const nodeId = (op as any).nodeId || (op as any).blockId;\n  \n  const result = nodes.map(node => {\n    if (node.id === nodeId) {\n      found = true;\n      return { \n        ...node, \n        props: { ...((node as any).props || {}), [op.name]: op.value } \n      };\n    }\n    \n    // Search in children for nested nodes (even though we prefer flat structure)\n    if ('children' in node && node.children && node.children.length > 0) {\n      const updatedChildren = applyEditAttr(node.children, op);\n      if (!found && updatedChildren !== node.children) {\n        found = true;\n      }\n      return { ...node, children: updatedChildren };\n    }\n    \n    return node;\n  });\n  \n  if (!found) {\n    throw new Error(`Node not found: ${nodeId}`);\n  }\n  \n  return result;\n}\n\nfunction applyEditContent(nodes: Node[], op: EditContentOperation): Node[] {\n  let found = false;\n  \n  // Handle backward compatibility\n  const nodeId = (op as any).nodeId || (op as any).blockId;\n  \n  const result = nodes.map(node => {\n    if (node.id === nodeId) {\n      found = true;\n      // Only content nodes have content property\n      if ('content' in node) {\n        return { ...node, content: op.content };\n      } else {\n        throw new Error(`Node ${nodeId} is not a content node`);\n      }\n    }\n    \n    if ('children' in node && node.children && node.children.length > 0) {\n      const updatedChildren = applyEditContent(node.children, op);\n      if (!found && updatedChildren !== node.children) {\n        found = true;\n      }\n      return { ...node, children: updatedChildren };\n    }\n    \n    return node;\n  });\n  \n  if (!found) {\n    throw new Error(`Node not found: ${nodeId}`);\n  }\n  \n  return result;\n}\n\nfunction applyEditParams(nodes: Node[], op: EditParamsOperation): Node[] {\n  let found = false;\n  \n  // Handle backward compatibility\n  const nodeId = (op as any).nodeId || (op as any).blockId;\n  \n  const result = nodes.map(node => {\n    if (node.id === nodeId) {\n      found = true;\n      // Only executable nodes have parameters\n      if ('parameters' in node) {\n        return { ...node, parameters: op.params };\n      } else {\n        throw new Error(`Node ${nodeId} is not an executable node`);\n      }\n    }\n    \n    if ('children' in node && node.children && node.children.length > 0) {\n      const updatedChildren = applyEditParams(node.children, op);\n      if (!found && updatedChildren !== node.children) {\n        found = true;\n      }\n      return { ...node, children: updatedChildren };\n    }\n    \n    return node;\n  });\n  \n  if (!found) {\n    throw new Error(`Node not found: ${nodeId}`);\n  }\n  \n  return result;\n}\n\nfunction applyEditId(nodes: Node[], op: EditIdOperation): Node[] {\n  let found = false;\n  \n  // Handle backward compatibility\n  const nodeId = (op as any).nodeId || (op as any).blockId;\n  \n  const result = nodes.map(node => {\n    if (node.id === nodeId) {\n      found = true;\n      return { ...node, id: op.newId };\n    }\n    \n    if ('children' in node && node.children && node.children.length > 0) {\n      const updatedChildren = applyEditId(node.children, op);\n      if (!found && updatedChildren !== node.children) {\n        found = true;\n      }\n      return { ...node, children: updatedChildren };\n    }\n    \n    return node;\n  });\n  \n  if (!found) {\n    throw new Error(`Node not found: ${nodeId}`);\n  }\n  \n  return result;\n}\n\nfunction applyInsert(nodes: Node[], op: InsertOperation): Node[] {\n  // Handle backward compatibility\n  const afterNodeId = (op as any).afterNodeId || (op as any).afterBlockId;\n  const beforeNodeId = (op as any).beforeNodeId || (op as any).beforeBlockId;\n  \n  // Validate position specification\n  const positionCount = [op.atStart, op.atEnd, afterNodeId, beforeNodeId]\n    .filter(Boolean).length;\n  \n  if (positionCount !== 1) {\n    throw new Error('Insert operation must specify exactly one position');\n  }\n  \n  // Ensure all inserted nodes have IDs\n  const nodesToInsert = op.nodes.map(node => ({\n    ...node,\n    id: node.id || uuidv4(),\n  }));\n\n  if (op.atStart) {\n    return [...nodesToInsert, ...nodes];\n  }\n\n  if (op.atEnd) {\n    return [...nodes, ...nodesToInsert];\n  }\n\n  const result: Node[] = [];\n  let inserted = false;\n\n  for (const node of nodes) {\n    if (beforeNodeId && node.id === beforeNodeId) {\n      result.push(...nodesToInsert);\n      inserted = true;\n    }\n\n    result.push(node);\n\n    if (afterNodeId && node.id === afterNodeId) {\n      result.push(...nodesToInsert);\n      inserted = true;\n    }\n  }\n\n  if (!inserted) {\n    throw new Error(`Could not find anchor node for insert operation`);\n  }\n\n  return result;\n}\n\nfunction applyDelete(nodes: Node[], op: DeleteOperation): Node[] {\n  // Handle backward compatibility\n  const nodeId = (op as any).nodeId || (op as any).blockId;\n  \n  // Remove from top level and recursively from children\n  return nodes\n    .filter(node => node.id !== nodeId)\n    .map(node => {\n      if ('children' in node && node.children && node.children.length > 0) {\n        return { ...node, children: applyDelete(node.children, op) };\n      }\n      return node;\n    });\n}\n\nfunction applyReplace(nodes: Node[], op: ReplaceOperation): Node[] {\n  // Handle backward compatibility\n  const nodeId = (op as any).nodeId || (op as any).blockId;\n  \n  // When replacing with a single node, preserve the original ID\n  const replacementNodes = op.nodes.map((node, index) => {\n    const newId = op.nodes.length === 1 && index === 0 ? nodeId : (node.id || uuidv4());\n    return {\n      ...node,\n      id: newId,\n    };\n  });\n\n  const result: Node[] = [];\n  let replaced = false;\n\n  for (const node of nodes) {\n    if (node.id === nodeId) {\n      result.push(...replacementNodes);\n      replaced = true;\n    } else {\n      result.push(node);\n    }\n  }\n\n  if (!replaced) {\n    throw new Error(`Could not find node ${nodeId} to replace`);\n  }\n\n  return result;\n}\n\nfunction applyMove(nodes: Node[], op: MoveOperation): Node[] {\n  // Handle backward compatibility\n  const nodeId = (op as any).nodeId || (op as any).blockId;\n  const nodeIds = (op as any).nodeIds || (op as any).blockIds;\n  const fromNodeId = (op as any).fromNodeId || (op as any).fromBlockId;\n  const toNodeId = (op as any).toNodeId || (op as any).toBlockId;\n  const afterNodeId = (op as any).afterNodeId || (op as any).afterBlockId;\n  const beforeNodeId = (op as any).beforeNodeId || (op as any).beforeBlockId;\n  \n  // Determine what nodes to move\n  let nodesToMove: Node[] = [];\n  let remainingNodes: Node[] = [];\n\n  if (nodeId) {\n    // Single node move\n    const nodeToMove = findNodeById(nodes, nodeId);\n    if (!nodeToMove) {\n      throw new Error(`Node not found: ${nodeId}`);\n    }\n    nodesToMove = [nodeToMove];\n    remainingNodes = nodes.filter(n => n.id !== nodeId);\n  } else if (nodeIds) {\n    // Multiple nodes move\n    const ids = nodeIds;\n    for (const id of ids) {\n      const node = findNodeById(nodes, id);\n      if (!node) {\n        throw new Error(`Node not found: ${id}`);\n      }\n      nodesToMove.push(node);\n    }\n    remainingNodes = nodes.filter(n => !ids.includes(n.id));\n  } else if (fromNodeId && toNodeId) {\n    // Range move\n    const fromIndex = nodes.findIndex(n => n.id === fromNodeId);\n    const toIndex = nodes.findIndex(n => n.id === toNodeId);\n    \n    if (fromIndex === -1) {\n      throw new Error(`Node not found: ${fromNodeId}`);\n    }\n    if (toIndex === -1) {\n      throw new Error(`Node not found: ${toNodeId}`);\n    }\n    \n    const startIndex = Math.min(fromIndex, toIndex);\n    const endIndex = Math.max(fromIndex, toIndex);\n    \n    nodesToMove = nodes.slice(startIndex, endIndex + 1);\n    remainingNodes = [\n      ...nodes.slice(0, startIndex),\n      ...nodes.slice(endIndex + 1)\n    ];\n  } else {\n    throw new Error('Move operation must specify nodeId, nodeIds, or fromNodeId/toNodeId');\n  }\n\n  // Now insert the moved nodes at the new position\n  const insertOp: InsertOperation = {\n    type: 'insert',\n    afterNodeId: afterNodeId,\n    beforeNodeId: beforeNodeId,\n    atStart: op.atStart,\n    atEnd: op.atEnd,\n    nodes: nodesToMove\n  };\n\n  return applyInsert(remainingNodes, insertOp);\n}\n\n// ============================================\n// Helper Functions\n// ============================================\n\nfunction findNodeById(nodes: Node[], id: string): Node | null {\n  for (const node of nodes) {\n    if (node.id === id) {\n      return node;\n    }\n    \n    if ('children' in node && node.children) {\n      const found = findNodeById(node.children, id);\n      if (found) return found;\n    }\n  }\n  \n  return null;\n}\n\n// Re-export types for convenience\nexport type { EditOperation } from './ast';","/**\n * Bidirectional converter between BlockNote and Idyllic XML formats\n * \n * Provides isomorphic conversion that preserves all data and structure.\n * Note: BlockNote still uses 'block' terminology, so we maintain that in\n * interfaces specific to BlockNote while using 'node' for Idyllic AST.\n */\n\nimport type { \n  Node, \n  Block, \n  ContentNode, \n  ContentBlock, \n  ExecutableNode, \n  ExecutableBlock, \n  RichContent,\n  TextContent,\n  InlineElement,\n  ContentNodeType,\n  ContentBlockType,\n  ExecutableNodeType,\n  ExecutableBlockType\n} from './ast';\nimport { isContentNode, isExecutableNode, isContentBlock, isExecutableBlock } from './ast';\n\n// BlockNote type definitions (based on the kitchen sink example)\nexport interface BlockNoteBlock {\n  id: string;\n  type: string;\n  props: Record<string, any>;\n  content: BlockNoteContent[] | BlockNoteTableContent;\n  children: BlockNoteBlock[];\n}\n\nexport interface BlockNoteContent {\n  type: string;\n  text?: string;\n  styles?: Record<string, any>;\n  props?: Record<string, any>;\n}\n\nexport interface BlockNoteTableContent {\n  type: 'tableContent';\n  rows: Array<{\n    cells: Array<{\n      type: 'tableCell';\n      props: Record<string, any>;\n      content: BlockNoteContent[];\n    }>;\n  }>;\n  columnWidths: (number | null)[];\n}\n\n/**\n * Convert BlockNote document to Idyllic nodes\n */\nexport function blockNoteToIdyllic(blockNoteBlocks: BlockNoteBlock[]): Node[] {\n  return blockNoteBlocks.map(convertBlockNoteBlock);\n}\n\n/**\n * Convert Idyllic nodes to BlockNote document\n */\nexport function idyllicToBlockNote(idyllicNodes: Node[]): BlockNoteBlock[] {\n  return idyllicNodes.map(convertIdyllicNode);\n}\n\n// ============================================\n// BlockNote to Idyllic Conversion\n// ============================================\n\nfunction convertBlockNoteBlock(bnBlock: BlockNoteBlock): Node {\n  const { id, type, props, content, children } = bnBlock;\n\n  // Handle executable blocks\n  if (type === 'trigger') {\n    return {\n      id,\n      type: 'trigger',\n      tool: props.trigger || '',\n      parameters: props.params ? JSON.parse(props.params) : {},\n      instructions: Array.isArray(content) ? convertBlockNoteContent(content) : [],\n      metadata: {\n        enabled: props.enabled,\n        modelId: props.modelId,\n      }\n    } as ExecutableNode;\n  }\n\n  if (type === 'tool') {\n    // Tool blocks in BlockNote map to a special content node in Idyllic\n    return {\n      id,\n      type: 'tool',\n      content: [], // Tool description would go here\n      props: {\n        title: props.title,\n        icon: props.icon,\n        toolDefinition: props.toolDefinition\n      },\n      children: children.map(convertBlockNoteBlock)\n    } as ContentNode;\n  }\n\n  // Handle table specially\n  if (type === 'table') {\n    return {\n      id,\n      type: 'data', // Tables map to data nodes in Idyllic\n      content: [{ type: 'text', text: JSON.stringify(content) }],\n      props: {\n        title: 'Table',\n        originalType: 'table',\n        ...props\n      },\n      children: []\n    } as ContentNode;\n  }\n\n  // Handle functionCall blocks\n  if (type === 'functionCall') {\n    return {\n      id,\n      type: 'function_call',\n      tool: props.tool || '',\n      parameters: props.params ? JSON.parse(props.params) : {},\n      result: {\n        success: !props.error,\n        data: props.response || undefined,\n        error: props.error || undefined\n      },\n      instructions: Array.isArray(content) && content.length > 0 \n        ? convertBlockNoteContent(content) \n        : [],\n      metadata: {\n        modelId: props.modelId\n      }\n    } as ExecutableNode;\n  }\n\n  // Map BlockNote types to Idyllic types\n  const typeMapping: Record<string, ContentNodeType> = {\n    'paragraph': 'paragraph',\n    'heading': 'heading',\n    'bulletListItem': 'bulletListItem',\n    'numberedListItem': 'numberedListItem',\n    'checkListItem': 'checklistItem',\n    'quote': 'quote',\n    'codeBlock': 'code',\n    'separator': 'separator',\n  };\n\n  const idyllicType = typeMapping[type] || 'paragraph';\n\n  // Handle content - ensure at least one empty text node\n  const idyllicContent = Array.isArray(content) && content.length > 0\n    ? convertBlockNoteContent(content)\n    : [{ type: 'text', text: '' } as TextContent];\n\n  // Build the content node\n  const node: ContentNode = {\n    id,\n    type: idyllicType,\n    content: idyllicContent,\n    children: children.map(convertBlockNoteBlock)\n  };\n\n  // Add props if they exist\n  if (Object.keys(props).length > 0) {\n    node.props = { ...props };\n  }\n\n  return node;\n}\n\nfunction convertBlockNoteContent(content: BlockNoteContent[]): RichContent[] {\n  return content.map(item => {\n    if (item.type === 'text') {\n      const textContent: TextContent = {\n        type: 'text',\n        text: item.text || ''\n      };\n\n      // Convert BlockNote styles to Idyllic styles\n      if (item.styles && Object.keys(item.styles).length > 0) {\n        const styles = [];\n        if (item.styles.bold) styles.push('bold');\n        if (item.styles.italic) styles.push('italic');\n        if (item.styles.underline) styles.push('underline');\n        if (item.styles.strikethrough) styles.push('strikethrough');\n        if (item.styles.code) styles.push('code');\n        \n        if (styles.length > 0) {\n          textContent.styles = styles as any;\n        }\n      }\n\n      return textContent;\n    }\n\n    if (item.type === 'mention' && item.props) {\n      const mention: InlineElement = {\n        type: 'mention',\n        mentionType: mapMentionType(item.props.mentionType),\n        id: item.props.id,\n        label: item.props.label\n      };\n      return mention;\n    }\n\n    if (item.type === 'link' && item.props) {\n      const link: InlineElement = {\n        type: 'link',\n        href: item.props.href || '',\n        content: item.props.content ? convertBlockNoteContent(item.props.content) : []\n      };\n      return link;\n    }\n\n    // Fallback to text\n    return {\n      type: 'text',\n      text: JSON.stringify(item)\n    };\n  });\n}\n\nfunction mapMentionType(bnType: string): 'user' | 'document' | 'agent' | 'custom' {\n  switch (bnType) {\n    case 'user': return 'user';\n    case 'document': return 'document';\n    case 'agent': return 'agent';\n    case 'tool': return 'custom'; // Tools are custom mentions in Idyllic\n    default: return 'custom';\n  }\n}\n\n// ============================================\n// Idyllic to BlockNote Conversion\n// ============================================\n\nfunction convertIdyllicNode(node: Node): BlockNoteBlock {\n  const { id } = node;\n\n  if (isExecutableNode(node)) {\n    if (node.type === 'trigger') {\n      return {\n        id,\n        type: 'trigger',\n        props: {\n          trigger: node.tool,\n          params: JSON.stringify(node.parameters),\n          enabled: node.metadata?.enabled ?? true,\n          modelId: node.metadata?.modelId\n        },\n        content: node.instructions && node.instructions.length > 0 \n          ? convertIdyllicContent(node.instructions) \n          : [{ type: 'text', text: '', styles: {} }],\n        children: []\n      };\n    }\n\n    if (node.type === 'function_call') {\n      return {\n        id,\n        type: 'functionCall',\n        props: {\n          tool: node.tool,\n          params: JSON.stringify(node.parameters),\n          response: node.result?.data ? JSON.stringify(node.result.data) : '',\n          error: node.result?.error ? JSON.stringify(node.result.error) : '',\n          modelId: node.metadata?.modelId\n        },\n        content: node.instructions && node.instructions.length > 0 \n          ? convertIdyllicContent(node.instructions) \n          : [{ type: 'text', text: '', styles: {} }],\n        children: []\n      };\n    }\n  }\n\n  // Handle content nodes\n  const contentNode = node as ContentNode;\n  \n  // Special handling for tool nodes\n  if (contentNode.type === 'tool') {\n    return {\n      id,\n      type: 'tool',\n      props: {\n        title: contentNode.props?.title || 'Tool',\n        icon: contentNode.props?.icon || '',\n        toolDefinition: contentNode.props?.toolDefinition || ''\n      },\n      content: [],\n      children: contentNode.children ? contentNode.children.map(convertIdyllicNode) : []\n    };\n  }\n\n  // Special handling for data nodes that were originally tables\n  if (contentNode.type === 'data' && contentNode.props?.originalType === 'table') {\n    try {\n      const firstContent = contentNode.content[0];\n      const tableData = JSON.parse(\n        firstContent && firstContent.type === 'text' ? firstContent.text : '{}'\n      );\n      return {\n        id,\n        type: 'table',\n        props: { textColor: contentNode.props.textColor || 'default' },\n        content: tableData,\n        children: []\n      };\n    } catch {\n      // Fall through to regular conversion\n    }\n  }\n\n  // Map Idyllic types back to BlockNote\n  const typeMapping: Record<string, string> = {\n    'paragraph': 'paragraph',\n    'heading': 'heading',\n    'bulletListItem': 'bulletListItem',\n    'numberedListItem': 'numberedListItem',\n    'checklistItem': 'checkListItem',\n    'quote': 'quote',\n    'code': 'codeBlock',\n    'separator': 'separator',\n    'data': 'paragraph', // Generic data nodes become paragraphs\n  };\n\n  const bnType = typeMapping[contentNode.type] || 'paragraph';\n\n  // Build BlockNote props\n  const bnProps: Record<string, any> = {};\n  \n  // Standard props\n  if (bnType !== 'separator' && bnType !== 'codeBlock') {\n    bnProps.textColor = contentNode.props?.textColor || 'default';\n    bnProps.textAlignment = contentNode.props?.textAlignment || 'left';\n    bnProps.backgroundColor = contentNode.props?.backgroundColor || 'default';\n  }\n\n  // Type-specific props\n  if (contentNode.type === 'heading') {\n    bnProps.level = contentNode.props?.level || 1;\n  } else if (contentNode.type === 'checklistItem') {\n    bnProps.checked = contentNode.props?.checked || false;\n  } else if (contentNode.type === 'code') {\n    bnProps.language = contentNode.props?.language || 'text';\n  } else if (contentNode.type === 'separator') {\n    bnProps.text = contentNode.props?.text || '';\n  }\n\n  // Copy any additional props\n  if (contentNode.props) {\n    Object.keys(contentNode.props).forEach(key => {\n      if (!bnProps[key]) {\n        bnProps[key] = contentNode.props![key];\n      }\n    });\n  }\n\n  // Ensure content is never empty for BlockNote\n  const bnContent = convertIdyllicContent(contentNode.content);\n  const finalContent = bnContent.length > 0 ? bnContent : [{ type: 'text', text: '', styles: {} }];\n\n  return {\n    id,\n    type: bnType,\n    props: bnProps,\n    content: finalContent,\n    children: contentNode.children ? contentNode.children.map(convertIdyllicNode) : []\n  };\n}\n\nfunction convertIdyllicContent(content: RichContent[]): BlockNoteContent[] {\n  return content.map(item => {\n    if (item.type === 'text') {\n      const bnContent: BlockNoteContent = {\n        type: 'text',\n        text: item.text,\n        styles: {}\n      };\n\n      // Convert styles\n      if (item.styles) {\n        item.styles.forEach(style => {\n          bnContent.styles![style] = true;\n        });\n      }\n\n      return bnContent;\n    }\n\n    if (item.type === 'mention') {\n      return {\n        type: 'mention',\n        props: {\n          id: item.id,\n          label: item.label || '',\n          iconUrl: '',\n          mentionId: generateMentionId(),\n          parameters: '',\n          mentionType: item.mentionType === 'custom' ? 'tool' : item.mentionType\n        }\n      };\n    }\n\n    if (item.type === 'link') {\n      return {\n        type: 'link',\n        props: {\n          href: item.href,\n          content: convertIdyllicContent(item.content)\n        }\n      };\n    }\n\n    if (item.type === 'variable') {\n      // Variables become special mentions\n      return {\n        type: 'mention',\n        props: {\n          id: `var:${item.name}`,\n          label: item.name,\n          iconUrl: '',\n          mentionId: generateMentionId(),\n          parameters: '',\n          mentionType: 'custom'\n        }\n      };\n    }\n\n    if (item.type === 'annotation') {\n      // Annotations become styled text\n      const annotatedContent = convertIdyllicContent(item.content);\n      return {\n        type: 'text',\n        text: annotatedContent.map(c => c.text).join(''),\n        styles: { backgroundColor: 'yellow' }\n      };\n    }\n\n    // Fallback\n    return {\n      type: 'text',\n      text: `[${(item as any).type || 'unknown'}]`,\n      styles: {}\n    };\n  });\n}\n\nfunction generateMentionId(): string {\n  return `${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;\n}\n\n// ============================================\n// Validation and Testing\n// ============================================\n\n/**\n * Test if conversion is truly isomorphic by round-tripping\n */\nexport function testIsomorphism(original: BlockNoteBlock[]): {\n  isIsomorphic: boolean;\n  differences?: string[];\n} {\n  // Convert to Idyllic and back\n  const idyllic = blockNoteToIdyllic(original);\n  const roundTripped = idyllicToBlockNote(idyllic);\n  \n  // Compare\n  const differences: string[] = [];\n  \n  if (original.length !== roundTripped.length) {\n    differences.push(`Block count mismatch: ${original.length} vs ${roundTripped.length}`);\n  }\n  \n  // Deep comparison would go here\n  // For now, just check count\n  \n  return {\n    isIsomorphic: differences.length === 0,\n    differences\n  };\n}","/**\n * Lightweight Agent implementation for idyll-engine\n *\n * This is a clean implementation inspired by the app's Agent class\n * but without the database dependencies and app-specific logic.\n */\n\nimport { generateText, streamText, Message, CoreTool, LanguageModel } from \"ai\";\nimport {\n  AgentConfig,\n  AgentDefinition,\n  AgentContext,\n  AgentExecuteOptions,\n  AgentExecuteResult,\n  AgentActivity,\n} from \"./types\";\nimport type { AgentDocument, Block } from '../document/ast';\nimport { ActivityMemory } from \"./memory\";\nimport { ToolRegistry } from \"../document/tool-registry\";\nimport { NodeExecutionContext, BlockExecutionContext } from \"../document/execution-types\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { buildDetailedSystemPrompt } from \"./system-prompt\";\nimport { extractCustomTools } from \"./custom-tools\";\nimport { mergeToolRegistries } from \"../document/tool-registry\";\nimport { compressToolResponse } from \"./response-compressor\";\nimport {\n  toAzureFunctionName,\n  fromAzureFunctionName,\n} from \"../document/tool-naming\";\n\n/**\n * Agent class for executing conversations with tools\n */\nexport class Agent {\n  private program: AgentDefinition;\n  private model: LanguageModel;\n  private tools: ToolRegistry;\n  private memory: ActivityMemory;\n  private context: AgentContext;\n  private aiTools: Record<string, CoreTool> = {};\n  private currentMessages: Message[] = [];\n\n  constructor(config: AgentConfig) {\n    this.program = config.program;\n    this.model = config.model;\n    this.tools = config.tools;\n\n    this.memory = new ActivityMemory();\n    this.context = {\n      agentId: this.program.id,\n      activities: [],\n    };\n\n    // Initialize AI tools from registry\n    this.initializeTools();\n  }\n\n  /**\n   * Initialize tools for AI SDK\n   */\n  private initializeTools() {\n    // Extract custom tools from agent program\n    const customTools = extractCustomTools(\n      this.program,\n      this.tools,\n      () => {\n        // Get the last user message as agent context\n        const lastUserMessage = this.currentMessages\n          .filter((m) => m.role === \"user\")\n          .pop();\n        return typeof lastUserMessage?.content === \"string\"\n          ? lastUserMessage.content\n          : JSON.stringify(lastUserMessage?.content || \"\");\n      }\n    );\n\n    // Merge base tools with custom tools\n    const allTools = mergeToolRegistries(this.tools, customTools);\n\n    // Convert all tools to AI SDK format\n    for (const [name, tool] of Object.entries(allTools)) {\n      // Transform tool name to be OpenAI-compatible using Azure adapter pattern\n      const aiToolName = toAzureFunctionName(name);\n\n      // Create AI SDK tool wrapper\n      this.aiTools[aiToolName] = {\n        description: tool.description,\n        parameters: tool.schema,\n        execute: async (params: any) => {\n          console.log(` Executing tool: ${name}`);\n\n          // Create execution context\n          const context: NodeExecutionContext = {\n            currentNodeId: uuidv4(),\n            previousResults: new Map(),\n            document: { id: this.program.id, nodes: this.program.nodes } as any,\n          };\n\n          try {\n            // Execute tool\n            const content = params.content || \"\";\n            delete params.content; // Remove content from params\n\n            const result = await tool.execute(params, content, context);\n\n            // Compress response for custom tools\n            const isCustomTool = name.startsWith(\"custom:\");\n            const finalResult = isCustomTool\n              ? await compressToolResponse({\n                  toolName: name,\n                  toolParams: params,\n                  toolContent: content,\n                  rawResponse: result,\n                  recentMessages: this.currentMessages.slice(-3),\n                })\n              : result;\n\n            if (isCustomTool) {\n              console.log(` Custom tool ${name} executed and compressed`);\n            }\n\n            // Track tool call\n            this.memory.add({\n              type: \"tool\",\n              toolCalls: [\n                {\n                  name,\n                  args: params,\n                  result: finalResult,\n                },\n              ],\n            });\n\n            return finalResult;\n          } catch (error) {\n            const errorMessage =\n              error instanceof Error ? error.message : \"Unknown error\";\n\n            // Track error\n            this.memory.add({\n              type: \"tool\",\n              toolCalls: [\n                {\n                  name,\n                  args: params,\n                },\n              ],\n              error: errorMessage,\n            });\n\n            throw error;\n          }\n        },\n      };\n    }\n  }\n\n  /**\n   * Get the system prompt with memory injection\n   */\n  private getSystemPrompt(): string {\n    const memoryContext = this.memory.formatForPrompt();\n    const toolNames = Object.keys(this.aiTools);\n\n    return buildDetailedSystemPrompt(\n      this.program,\n      toolNames,\n      memoryContext\n    );\n  }\n\n  /**\n   * Execute a chat message (non-streaming)\n   */\n  async chat(\n    messages: Message[],\n    options?: AgentExecuteOptions\n  ): Promise<AgentExecuteResult> {\n    // Store current messages for context\n    this.currentMessages = messages;\n\n    const userMessage = messages[messages.length - 1]?.content;\n\n    try {\n      // Add to memory\n      const activity = this.memory.add({\n        type: \"chat\",\n        userMessage:\n          typeof userMessage === \"string\"\n            ? userMessage\n            : JSON.stringify(userMessage),\n      });\n\n      const result = await generateText({\n        model: this.model,\n        system: this.getSystemPrompt(),\n        messages,\n        tools: this.aiTools,\n        toolChoice: \"auto\",\n        maxSteps: options?.maxSteps ?? 10,\n        temperature: options?.temperature ?? 0.7,\n      });\n\n      // Update activity with response\n      activity.assistantMessage = result.text;\n      activity.usage = result.usage;\n      if (result.toolCalls && result.toolCalls.length > 0) {\n        activity.toolCalls = result.toolCalls.map((tc) => ({\n          name: tc.toolName,\n          args: tc.args as Record<string, any>,\n        }));\n      }\n\n      return {\n        message: {\n          id: uuidv4(),\n          role: \"assistant\",\n          content: result.text,\n          createdAt: new Date(),\n        },\n        usage: result.usage,\n        finishReason: result.finishReason,\n      };\n    } catch (error) {\n      // Track error\n      this.memory.add({\n        type: \"chat\",\n        userMessage:\n          typeof userMessage === \"string\"\n            ? userMessage\n            : JSON.stringify(userMessage),\n        error: error instanceof Error ? error.message : \"Unknown error\",\n      });\n\n      throw error;\n    }\n  }\n\n  /**\n   * Execute a chat message (streaming)\n   * Returns streamText result that can be used with toDataStreamResponse()\n   */\n  async chatStream(\n    messages: Message[],\n    options?: AgentExecuteOptions & {\n      onChunk?: (chunk: string) => void;\n      onToolCall?: (toolName: string, args: any) => void;\n    }\n  ) {\n    const userMessage = messages[messages.length - 1]?.content;\n\n    try {\n      // Add to memory\n      const activity = this.memory.add({\n        type: \"chat\",\n        userMessage:\n          typeof userMessage === \"string\"\n            ? userMessage\n            : JSON.stringify(userMessage),\n      });\n\n      const result = await streamText({\n        model: this.model,\n        system: this.getSystemPrompt(),\n        messages,\n        tools: this.aiTools,\n        maxSteps: options?.maxSteps ?? 10,\n        temperature: options?.temperature ?? 0.7,\n        onChunk: async ({ chunk }) => {\n          if (chunk.type === \"text-delta\" && options?.onChunk) {\n            options.onChunk(chunk.textDelta);\n          }\n          if (chunk.type === \"tool-call\" && options?.onToolCall) {\n            // Transform tool name back from AI format to original format\n            const originalToolName = fromAzureFunctionName(chunk.toolName);\n            options.onToolCall(originalToolName, chunk.args);\n          }\n        },\n        onFinish: async ({ text, toolCalls, usage, finishReason }) => {\n          // Update activity when stream finishes\n          activity.assistantMessage = text;\n          if (toolCalls && toolCalls.length > 0) {\n            activity.toolCalls = toolCalls.map((tc) => ({\n              name: fromAzureFunctionName(tc.toolName),\n              args: tc.args,\n            }));\n          }\n          \n          // Call the external onFinish callback if provided\n          if (options?.onFinish) {\n            await options.onFinish({\n              text,\n              toolCalls: toolCalls?.map((tc) => ({\n                ...tc,\n                toolName: fromAzureFunctionName(tc.toolName),\n              })),\n              usage,\n              finishReason,\n            });\n          }\n        },\n      });\n\n      return result;\n    } catch (error) {\n      // Track error\n      this.memory.add({\n        type: \"chat\",\n        userMessage:\n          typeof userMessage === \"string\"\n            ? userMessage\n            : JSON.stringify(userMessage),\n        error: error instanceof Error ? error.message : \"Unknown error\",\n      });\n\n      throw error;\n    }\n  }\n\n  /**\n   * Get memory/activity history\n   */\n  getMemory(): ActivityMemory {\n    return this.memory;\n  }\n\n  /**\n   * Get agent context\n   */\n  getContext(): AgentContext {\n    return {\n      ...this.context,\n      activities: this.memory.toJSON(),\n    };\n  }\n\n  /**\n   * Clear memory\n   */\n  clearMemory(): void {\n    this.memory.clear();\n  }\n}\n","/**\n * In-memory activity tracking for agents\n */\n\nimport { formatDistanceToNow } from 'date-fns';\nimport { AgentActivity } from './types';\n\n/**\n * Simple in-memory activity store\n */\nexport class ActivityMemory {\n  private activities: AgentActivity[] = [];\n  private maxSize: number;\n\n  constructor(maxSize = 20) {\n    this.maxSize = maxSize;\n  }\n\n  /**\n   * Add an activity record\n   */\n  add(activity: Omit<AgentActivity, 'id' | 'timestamp'>): AgentActivity {\n    const record: AgentActivity = {\n      ...activity,\n      id: crypto.randomUUID(),\n      timestamp: new Date(),\n    };\n\n    this.activities.unshift(record);\n    \n    // Keep only maxSize records\n    if (this.activities.length > this.maxSize) {\n      this.activities = this.activities.slice(0, this.maxSize);\n    }\n\n    return record;\n  }\n\n  /**\n   * Get recent activities\n   */\n  getRecent(limit?: number): AgentActivity[] {\n    return limit ? this.activities.slice(0, limit) : this.activities;\n  }\n\n  /**\n   * Clear all activities\n   */\n  clear(): void {\n    this.activities = [];\n  }\n\n  /**\n   * Format activities as memory context for agent\n   */\n  formatForPrompt(limit = 10): string {\n    const recent = this.getRecent(limit);\n    \n    if (recent.length === 0) {\n      return '';\n    }\n\n    const formatted = recent.map(activity => {\n      const timeAgo = formatDistanceToNow(activity.timestamp, { addSuffix: true });\n      const parts = [`[${timeAgo}] ${activity.type}`];\n      \n      if (activity.userMessage) {\n        parts.push(`User: \"${activity.userMessage.substring(0, 100)}${activity.userMessage.length > 100 ? '...' : ''}\"`);\n      }\n      \n      if (activity.assistantMessage) {\n        parts.push(`Assistant: \"${activity.assistantMessage.substring(0, 100)}${activity.assistantMessage.length > 100 ? '...' : ''}\"`);\n      }\n      \n      if (activity.toolCalls && activity.toolCalls.length > 0) {\n        parts.push(`Tools: ${activity.toolCalls.map(tc => tc.name).join(', ')}`);\n      }\n      \n      if (activity.error) {\n        parts.push(`Error: ${activity.error}`);\n      }\n      \n      return parts.join(' | ');\n    }).join('\\n');\n\n    return `<recent_activity>\n${formatted}\n</recent_activity>`;\n  }\n\n  /**\n   * Get activities as JSON\n   */\n  toJSON(): AgentActivity[] {\n    return this.activities;\n  }\n}","/**\n * System prompt builder for agents\n * \n * Converts AgentDocument to a proper system prompt with:\n * - Background context\n * - Tool definitions\n * - Custom instructions from nodes\n */\n\nimport { AgentDocument, Node, Block, isExecutableNode, isExecutableBlock, isTextContent } from '../document/ast';\nimport { serializeToXML } from '../document/parser-grammar';\n\n/**\n * Build system prompt from agent document\n */\nexport function buildSystemPrompt(agent: AgentDocument, availableTools: string[]): string {\n  const sections: string[] = [];\n  \n  // Agent identity\n  sections.push(`You are ${agent.name || 'an AI assistant'}.`);\n  if (agent.description) {\n    sections.push(agent.description);\n  }\n  \n  // Model info\n  sections.push(`\\nModel: ${agent.model || 'default'}`);\n  \n  // Available tools\n  if (availableTools.length > 0) {\n    sections.push(`\\nAvailable tools:\\n${availableTools.map(t => `- ${t}`).join('\\n')}`);\n  }\n  \n  // Process blocks for custom instructions and tool definitions\n  const instructions: string[] = [];\n  const customTools: string[] = [];\n  const triggers: string[] = [];\n  \n  for (const node of agent.nodes) {\n    if (node.type === 'tool') {\n      // Extract tool definition\n      const title = node.props?.title as string || 'Untitled Tool';\n      customTools.push(`Custom tool: ${title}`);\n    } else if (node.type === 'trigger') {\n      // Note triggers\n      const trigger = node.props?.trigger as string;\n      if (trigger) {\n        triggers.push(`Trigger: ${trigger}`);\n      }\n    } else if ('content' in node && node.content) {\n      // Extract text content as instructions\n      const text = extractTextFromBlock(node);\n      if (text) {\n        instructions.push(text);\n      }\n    }\n  }\n  \n  // Add custom tools section\n  if (customTools.length > 0) {\n    sections.push(`\\nCustom tools defined:\\n${customTools.join('\\n')}`);\n  }\n  \n  // Add triggers section\n  if (triggers.length > 0) {\n    sections.push(`\\nTriggers configured:\\n${triggers.join('\\n')}`);\n  }\n  \n  // Add instructions\n  if (instructions.length > 0) {\n    sections.push(`\\nInstructions:\\n${instructions.join('\\n\\n')}`);\n  }\n  \n  // Add XML context for understanding the format\n  sections.push(`\\nWhen working with documents, use the Idyllic XML format.`);\n  \n  return sections.join('\\n');\n}\n\n/**\n * Extract plain text from a node\n */\nfunction extractTextFromBlock(node: Node): string {\n  if (!('content' in node) || !node.content) {\n    return '';\n  }\n  \n  const texts: string[] = [];\n  \n  for (const content of node.content) {\n    if (isTextContent(content)) {\n      texts.push(content.text);\n    }\n  }\n  \n  return texts.join('');\n}\n\n/**\n * Create a more detailed prompt with XML examples\n */\nexport function buildDetailedSystemPrompt(\n  agent: AgentDocument, \n  availableTools: string[],\n  includeMemory?: string\n): string {\n  let prompt = buildSystemPrompt(agent, availableTools);\n  \n  // Add memory if provided\n  if (includeMemory) {\n    prompt = `${prompt}\\n\\n${includeMemory}`;\n  }\n  \n  // Add document structure explanation\n  prompt += `\\n\\n<document_format>\nDocuments are structured using XML with blocks like:\n- <p> for paragraphs\n- <h1>, <h2>, etc. for headings\n- <fncall idyll-tool=\"...\"> for tool execution\n- <variable name=\"...\" /> for variables\n- <mention:type id=\"...\">label</mention:type> for references\n</document_format>`;\n  \n  return prompt;\n}","/**\n * Custom tool extraction and execution for agents\n * \n * Extracts tool definitions from agent system prompts and\n * creates executable tools that use the custom tool executor.\n */\n\nimport { z } from 'zod';\nimport { AgentDocument, Block, ContentBlock } from '../document/ast';\nimport { ToolDefinition, ToolRegistry } from '../document/tool-registry';\nimport { executeCustomTool, parseCustomTool } from '../document/custom-tool-executor';\nimport { parseXML } from '../document/parser-grammar';\n\n/**\n * Extract custom tools from agent document\n */\nexport function extractCustomTools(\n  agentDoc: AgentDocument,\n  baseTools: ToolRegistry,\n  getAgentContext?: () => string\n): ToolRegistry {\n  const customTools: ToolRegistry = {};\n  \n  console.log(' Extracting custom tools from agent document...');\n  \n  // Find all tool blocks\n  for (const block of agentDoc.blocks) {\n    if (block.type === 'tool' && 'props' in block) {\n      console.log(' Found tool block:', JSON.stringify(block, null, 2));\n      const title = block.props?.title as string || 'Untitled Tool';\n      const icon = block.props?.icon as string;\n      \n      // Extract description from content\n      const description = extractTextContent(block);\n      \n      // Extract tool definition blocks from children\n      const definitionBlocks = extractToolDefinitionBlocks(block);\n      \n      if (definitionBlocks.length === 0) {\n        console.warn(`Tool \"${title}\" has no definition blocks`);\n        continue;\n      }\n      \n      // Convert title to valid tool name (snake_case)\n      const toolName = title\n        .toLowerCase()\n        .replace(/[^a-z0-9]+/g, '_')\n        .replace(/^_+|_+$/g, '');\n      \n      // Create the custom tool\n      customTools[`custom:${toolName}`] = {\n        description: description || `Custom tool: ${title}`,\n        schema: z.object({\n          context: z.string()\n            .describe('Relevant context to help resolve any variables in the tool')\n            .optional(),\n        }),\n        execute: async (params, content, context) => {\n          console.log(` Executing custom tool: ${title}`);\n          \n          // Create a virtual document with the tool definition\n          const toolDoc = {\n            id: `custom-tool-${toolName}`,\n            blocks: definitionBlocks,\n          };\n          \n          // Create custom tool block for execution\n          const customToolBlock: ContentBlock = {\n            id: context.currentBlockId || 'custom-tool-exec',\n            type: 'tool',\n            content: [],\n            children: definitionBlocks,\n            props: { title, icon },\n          };\n          \n          // Build agent context from params and content\n          // The AI typically passes context in params.context or uses content\n          let agentContext = '';\n          if (params.context) {\n            agentContext = params.context;\n          } else if (content) {\n            agentContext = content;\n          } else if (getAgentContext) {\n            // Use the agent context getter if provided\n            agentContext = getAgentContext();\n          } else {\n            // Try to infer from the execution context\n            agentContext = `Tool invoked: ${title}`;\n          }\n          \n          console.log(` Agent context for variable resolution: \"${agentContext}\"`);\n          console.log(` Params:`, params);\n          console.log(` Content:`, content);\n          console.log(` GetAgentContext available:`, !!getAgentContext);\n          \n          try {\n            // Execute the custom tool\n            const executionContext = await executeCustomTool(customToolBlock, {\n              tools: baseTools,\n              agentContext: agentContext,\n            });\n            \n            // Extract the final result\n            const lastBlockId = Array.from(executionContext.blocks.keys()).pop();\n            const lastResult = lastBlockId ? executionContext.blocks.get(lastBlockId) : undefined;\n            \n            console.log(` Execution complete. Last block ID: ${lastBlockId}`);\n            console.log(` Last result:`, lastResult);\n            console.log(` All blocks:`, Array.from(executionContext.blocks.entries()));\n            \n            // Check if we have any successful results\n            const results = Array.from(executionContext.blocks.values());\n            const successfulResults = results.filter(r => r.success);\n            const failedResults = results.filter(r => !r.success);\n            \n            console.log(` Execution summary: ${successfulResults.length} successful, ${failedResults.length} failed`);\n            \n            // If we have successful results, return the full context for compression\n            if (successfulResults.length > 0) {\n              console.log(` Returning full ToolExecutionContext for compression`);\n              return executionContext;\n            }\n            \n            // If everything failed, throw the last error\n            if (lastResult && !lastResult.success) {\n              const errorMsg = typeof lastResult.error === 'string' \n                ? lastResult.error \n                : JSON.stringify(lastResult.error) || 'Tool execution failed';\n              throw new Error(errorMsg);\n            }\n            \n            // Fallback\n            return executionContext;\n          } catch (error) {\n            console.error(` Custom tool \"${title}\" failed:`, error);\n            throw error;\n          }\n        },\n      };\n    }\n  }\n  \n  return customTools;\n}\n\n/**\n * Extract text content from a block\n */\nfunction extractTextContent(block: Block): string {\n  if (!('content' in block) || !block.content) {\n    return '';\n  }\n  \n  const texts: string[] = [];\n  for (const content of block.content) {\n    if (content.type === 'text') {\n      texts.push(content.text);\n    }\n  }\n  \n  return texts.join('').trim();\n}\n\n/**\n * Extract tool definition blocks from a tool block\n * \n * Tool blocks have a structure like:\n * <tool>\n *   <tool:description>text content</tool:description>\n *   <tool:definition>\n *     <p>...</p>\n *     <fncall>...</fncall>\n *   </tool:definition>\n * </tool>\n */\nfunction extractToolDefinitionBlocks(toolBlock: Block): Block[] {\n  if (!('children' in toolBlock) || !toolBlock.children) {\n    return [];\n  }\n  \n  const definitionBlocks: Block[] = [];\n  \n  for (const child of toolBlock.children) {\n    // Look for blocks with specific types from our parser\n    if ('type' in child) {\n      // The parser converts <tool:definition> to a block with type 'tool:definition'\n      // But we need to check the actual parsed structure\n      if (child.type === 'paragraph' || child.type === 'function_call') {\n        definitionBlocks.push(child);\n      } else if ('children' in child && child.children) {\n        // Recursively extract from nested structures\n        definitionBlocks.push(...extractToolDefinitionBlocks(child));\n      }\n    }\n  }\n  \n  return definitionBlocks;\n}","/**\n * Response compression for verbose tool outputs\n * \n * Uses a mini model to intelligently extract relevant information\n * from complex tool execution contexts.\n */\n\nimport { Message } from 'ai';\nimport { ToolExecutionContext } from '../document/execution-types';\n\nexport interface CompressionContext {\n  toolName: string;\n  toolParams: Record<string, any>;\n  toolContent?: string;\n  rawResponse: any;\n  recentMessages: Message[];\n}\n\n/**\n * Compress verbose tool responses using AI\n */\nexport async function compressToolResponse(\n  context: CompressionContext\n): Promise<any> {\n  // For non-complex responses, return as-is\n  if (!isComplexResponse(context.rawResponse)) {\n    console.log(` Response compressor: ${context.toolName} - No compression needed (simple response)`);\n    return context.rawResponse;\n  }\n  \n  console.log(`  Response compressor: ${context.toolName} - Compressing verbose response...`);\n  \n  // Build context summary\n  const conversationContext = context.recentMessages\n    .slice(-3) // Last 3 messages\n    .map(m => `${m.role}: ${typeof m.content === 'string' ? m.content : JSON.stringify(m.content)}`)\n    .join('\\n');\n  \n  // Format the raw response for the AI\n  const responseStr = formatResponse(context.rawResponse);\n  \n  // For now, just do simple truncation/summarization without AI calls\n  // This prevents the double response issue\n  const originalSize = JSON.stringify(context.rawResponse).length;\n  \n  if (typeof context.rawResponse === 'string') {\n    // Check if this looks like a conversational response\n    const isConversational = context.rawResponse.includes('?') || \n                             context.rawResponse.includes('I') ||\n                             context.rawResponse.includes('you') ||\n                             context.rawResponse.length > 50;\n    \n    if (isConversational) {\n      // For conversational responses, just return them as-is\n      // The AI should understand this is the complete response\n      const response = context.rawResponse.length > 1000 \n        ? context.rawResponse.substring(0, 1000) + '... [truncated]'\n        : context.rawResponse;\n      \n      console.log(` Conversational response detected: ${originalSize} chars`);\n      return response;\n    }\n    \n    // Regular compression for non-conversational strings\n    const compressed = context.rawResponse.length > 1000 \n      ? context.rawResponse.substring(0, 1000) + '... [truncated]'\n      : context.rawResponse;\n    \n    console.log(` Response compressed: ${originalSize}  ${compressed.length} chars`);\n    return compressed;\n  }\n  \n  if (context.rawResponse && typeof context.rawResponse === 'object') {\n    // For objects, extract key fields or summarize\n    if ('variables' in context.rawResponse && 'blocks' in context.rawResponse) {\n      // ToolExecutionContext - extract summary\n      const ctx = context.rawResponse as any;\n      const summary = {\n        success: ctx.metadata?.blocksSucceeded > 0,\n        blocksExecuted: ctx.metadata?.blocksExecuted || 0,\n        variables: Object.fromEntries(ctx.variables || new Map()),\n        errors: ctx.metadata?.blocksFailed > 0 ? 'Some blocks failed' : null\n      };\n      \n      console.log(` Response compressed: ${originalSize}  ${JSON.stringify(summary).length} chars`);\n      return summary;\n    }\n    \n    // For other objects, return as-is but log\n    console.log(` Response kept as-is: ${originalSize} chars (not complex enough)`);\n    return context.rawResponse;\n  }\n  \n  // Default: return as-is\n  return context.rawResponse;\n}\n\n/**\n * Check if a response is complex enough to need compression\n */\nfunction isComplexResponse(response: unknown): boolean {\n  // Simple strings don't need compression\n  if (typeof response === 'string') {\n    return response.length > 2000; // Only compress very long strings\n  }\n  \n  // ToolExecutionContext is always complex\n  if (response && typeof response === 'object') {\n    if ('variables' in response && 'blocks' in response && 'metadata' in response) {\n      return true;\n    }\n  }\n  \n  // Large responses need compression\n  const size = JSON.stringify(response).length;\n  return size > 2000; // Increased threshold to avoid compressing simple responses\n}\n\n/**\n * Format response for AI consumption\n */\nfunction formatResponse(response: unknown): string {\n  // Special handling for ToolExecutionContext\n  if (response && typeof response === 'object' && 'blocks' in response) {\n    const ctx = response as ToolExecutionContext;\n    const parts: string[] = [];\n    \n    // Variables\n    if (ctx.variables.size > 0) {\n      parts.push('Variables resolved:');\n      ctx.variables.forEach((value, key) => {\n        parts.push(`  ${key}: ${value}`);\n      });\n    }\n    \n    // Block results\n    if (ctx.blocks.size > 0) {\n      parts.push('\\nBlock executions:');\n      ctx.blocks.forEach((result, blockId) => {\n        if (result.success) {\n          parts.push(`   ${blockId}: ${JSON.stringify(result.data)}`);\n        } else {\n          parts.push(`   ${blockId}: ${result.error}`);\n        }\n      });\n    }\n    \n    // Metadata\n    if (ctx.metadata) {\n      parts.push(`\\nExecution summary:`);\n      parts.push(`  Tool: ${ctx.metadata.toolName}`);\n      parts.push(`  Blocks executed: ${ctx.metadata.blocksExecuted}`);\n      parts.push(`  Succeeded: ${ctx.metadata.blocksSucceeded}`);\n      parts.push(`  Failed: ${ctx.metadata.blocksFailed}`);\n    }\n    \n    return parts.join('\\n');\n  }\n  \n  // Default formatting\n  return JSON.stringify(response, null, 2);\n}"],"mappings":"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","names":["terminal","compiled","z","uuidv4","uuidv4","z","extractTextContent","z","uuidv4"]}