{"version":3,"sources":["../document/ast.ts","../document/parser-grammar.ts","../types.ts","../document/grammars/grammar-dsl.ts","../document/grammars/document-grammar.ts","../document/grammars/agent-grammar.ts","../document/grammars/diff-grammar.ts","../document/grammars/index.ts","../document/grammar-compiler.ts","../document/executor.ts","../document/tool-registry.ts","../document/tool-naming.ts","../document/validator.ts","../document/variable-resolution.ts","../document/custom-tool-executor.ts","../document/diff-applier.ts","../agent/agent.ts","../agent/memory.ts","../agent/system-prompt.ts","../agent/custom-tools.ts","../agent/response-pipeline.ts"],"sourcesContent":["/**\n * Core AST types for Idyllic documents\n * \n * This defines the semantic model for documents, independent of:\n * - BlockNote editor representation\n * - XML serialization format\n * - Specific tool implementations\n */\n\n// ============================================\n// Core Document Types\n// ============================================\n\n/**\n * The root document structure\n */\nexport interface IdyllDocument {\n  id: string;\n  nodes: Node[];\n  metadata?: DocumentMetadata;\n}\n\n\n/**\n * Agent system prompt document\n */\nexport interface AgentDocument {\n  type: 'agent';\n  id: string;\n  name?: string;\n  description?: string;\n  model?: string;\n  nodes: Node[];\n}\n\n/**\n * Diff document for edit operations\n */\nexport interface DiffDocument {\n  type: 'diff';\n  targetDocument?: string;\n  timestamp: Date;\n  operations: EditOperation[];\n}\n\n/**\n * Edit operation types\n */\nexport type EditOperation = \n  | EditAttrOperation\n  | EditContentOperation\n  | EditParamsOperation\n  | EditIdOperation\n  | InsertOperation\n  | DeleteOperation\n  | ReplaceOperation\n  | MoveOperation;\n\nexport interface EditAttrOperation {\n  type: 'edit:attr';\n  blockId: string;\n  name: string;\n  value: string;\n}\n\nexport interface EditContentOperation {\n  type: 'edit:content';\n  blockId: string;\n  content: RichContent[];\n}\n\nexport interface EditParamsOperation {\n  type: 'edit:params';\n  blockId: string;\n  params: Record<string, unknown>;\n}\n\nexport interface EditIdOperation {\n  type: 'edit:id';\n  blockId: string;\n  newId: string;\n}\n\nexport interface InsertOperation {\n  type: 'insert';\n  afterBlockId?: string;\n  beforeBlockId?: string;\n  atStart?: boolean;\n  atEnd?: boolean;\n  blocks: Node[];\n}\n\nexport interface DeleteOperation {\n  type: 'delete';\n  blockId: string;\n}\n\nexport interface ReplaceOperation {\n  type: 'replace';\n  blockId: string;\n  blocks: Node[];\n}\n\nexport interface MoveOperation {\n  type: 'move';\n  blockId?: string;\n  blockIds?: string[];\n  fromBlockId?: string;\n  toBlockId?: string;\n  afterBlockId?: string;\n  beforeBlockId?: string;\n  atStart?: boolean;\n  atEnd?: boolean;\n}\n\nexport interface DocumentMetadata {\n  version?: string;\n  created?: Date;\n  modified?: Date;\n  [key: string]: unknown;\n}\n\n/**\n * A node can be either content (text, headings, etc) or executable\n */\nexport type Node = ContentNode | ExecutableNode;\n\n\n// ============================================\n// Content Nodes\n// ============================================\n\nexport interface ContentNode {\n  id: string;\n  type: ContentNodeType;\n  content: RichContent[];\n  children?: Node[];\n  props?: Record<string, unknown>;\n}\n\n// Define node types directly\nexport type NodeType = \n  | 'p' | 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6'\n  | 'ul' | 'ol' | 'li'\n  | 'blockquote' | 'code' | 'pre'\n  | 'hr' | 'br'\n  | 'function_call' | 'trigger' | '_params' | '_content' | '_result'\n  | 'heading' | 'paragraph';  // Added for compatibility\n\n// ContentNodeType includes all content-related types\nexport type ContentNodeType = \n  | 'paragraph' | 'heading'\n  | 'bulletListItem' | 'numberedListItem' | 'checklistItem'\n  | 'code' | 'quote' | 'separator' | 'data' | 'tool';\n\n// ============================================\n// Executable Nodes\n// ============================================\n\nexport interface ExecutableNode {\n  id: string;\n  type: ExecutableNodeType;\n  tool: string; // e.g., \"documents:create\", \"ai:generate-text\"\n  parameters: Record<string, unknown>;\n  content?: RichContent[]; // Natural language content/instructions\n  result?: ExecutionResult;\n  metadata?: ExecutableMetadata;\n  props?: Record<string, unknown>; // Additional properties for compatibility\n}\n\nexport type ExecutableNodeType = 'function_call' | 'trigger';\n\n\nexport interface ExecutableMetadata {\n  enabled?: boolean; // For triggers\n  modelId?: string; // For AI operations\n  [key: string]: unknown;\n}\n\nexport interface ExecutionResult {\n  success: boolean;\n  data?: unknown;\n  error?: ExecutionError;\n  timestamp?: Date;\n}\n\nexport interface ExecutionError {\n  code: string;\n  message: string;\n  details?: unknown;\n}\n\n// ============================================\n// Rich Content Types\n// ============================================\n\n/**\n * Rich content represents inline formatted text and elements\n */\nexport type RichContent = TextContent | InlineElement;\n\nexport interface TextContent {\n  type: 'text';\n  text: string;\n  styles?: TextStyle[];\n}\n\nexport type TextStyle = \n  | 'bold'\n  | 'italic'\n  | 'underline'\n  | 'strikethrough'\n  | 'code';\n\nexport type InlineElement = \n  | MentionElement\n  | VariableElement\n  | LinkElement\n  | AnnotationElement;\n\nexport interface MentionElement {\n  type: 'mention';\n  mentionType: 'user' | 'document' | 'agent' | 'custom';\n  id: string;\n  label?: string;\n}\n\nexport interface VariableElement {\n  type: 'variable';\n  name: string; // e.g., \"previousResult\", \"currentDate\"\n  prompt?: string; // Optional prompt for user input\n  value?: string; // Optional resolved value\n}\n\nexport interface LinkElement {\n  type: 'link';\n  href: string;\n  content: RichContent[];\n}\n\nexport interface AnnotationElement {\n  type: 'annotation';\n  content: RichContent[];\n  annotation: {\n    title?: string;\n    comment?: string;\n    confidence?: number;\n    [key: string]: unknown;\n  };\n}\n\n// ============================================\n// Utility Types\n// ============================================\n\n/**\n * Type guards for runtime type checking\n */\nexport function isContentNode(node: Node): node is ContentNode {\n  return !isExecutableNode(node);\n}\n\n\nexport function isExecutableNode(node: Node): node is ExecutableNode {\n  return node.type === 'function_call' || node.type === 'trigger';\n}\n\n\nexport function isTextContent(content: RichContent): content is TextContent {\n  return content.type === 'text';\n}\n\nexport function isMention(content: RichContent): content is MentionElement {\n  return content.type === 'mention';\n}\n\nexport function isVariable(content: RichContent): content is VariableElement {\n  return content.type === 'variable';\n}\n\n// ============================================\n// Document Traversal Utilities\n// ============================================\n\n/**\n * Traverse all nodes in a document (including nested children)\n */\nexport function* traverseNodes(nodes: Node[]): Generator<Node> {\n  for (const node of nodes) {\n    yield node;\n    if ('children' in node && node.children) {\n      yield* traverseNodes(node.children);\n    }\n  }\n}\n\n\n/**\n * Find a node by ID\n */\nexport function findNode(nodes: Node[], id: string): Node | undefined {\n  for (const node of traverseNodes(nodes)) {\n    if (node.id === id) {\n      return node;\n    }\n  }\n  return undefined;\n}\n\n\n/**\n * Get all executable nodes\n */\nexport function getExecutableNodes(nodes: Node[]): ExecutableNode[] {\n  const executable: ExecutableNode[] = [];\n  for (const node of traverseNodes(nodes)) {\n    if (isExecutableNode(node)) {\n      executable.push(node);\n    }\n  }\n  return executable;\n}\n\n\n/**\n * Extract all mentions from a document\n */\nexport function extractMentions(nodes: Node[]): MentionElement[] {\n  const mentions: MentionElement[] = [];\n  \n  function extractFromContent(content: RichContent[]) {\n    for (const item of content) {\n      if (isMention(item)) {\n        mentions.push(item);\n      } else if ('content' in item && Array.isArray(item.content)) {\n        extractFromContent(item.content);\n      }\n    }\n  }\n  \n  for (const node of traverseNodes(nodes)) {\n    if ('content' in node && Array.isArray(node.content)) {\n      extractFromContent(node.content);\n    }\n    if (isExecutableNode(node) && node.content) {\n      extractFromContent(node.content);\n    }\n  }\n  \n  return mentions;\n}\n\n/**\n * Extract all variables from a document\n */\nexport function extractVariables(nodes: Node[]): VariableElement[] {\n  const variables: VariableElement[] = [];\n  \n  function extractFromContent(content: RichContent[]) {\n    for (const item of content) {\n      if (isVariable(item)) {\n        variables.push(item);\n      } else if ('content' in item && Array.isArray(item.content)) {\n        extractFromContent(item.content);\n      }\n    }\n  }\n  \n  for (const node of traverseNodes(nodes)) {\n    if ('content' in node && Array.isArray(node.content)) {\n      extractFromContent(node.content);\n    }\n    if (isExecutableNode(node) && node.content) {\n      extractFromContent(node.content);\n    }\n  }\n  \n  return variables;\n}","/**\n * Grammar-based XML parser for Idyllic documents\n *\n * This parser uses the grammar as the single source of truth\n * for parsing, validation, and AST construction\n */\n\nimport * as xml2js from \"xml-js\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport {\n  IdyllDocument,\n  AgentDocument,\n  DiffDocument,\n  EditOperation,\n  Node,\n  ContentNode,\n  ExecutableNode,\n  RichContent,\n  TextContent,\n  TextStyle,\n  MentionElement,\n  VariableElement,\n  LinkElement,\n  AnnotationElement,\n  ContentNodeType,\n  isExecutableNode,\n  isTextContent,\n} from \"./ast\";\nimport { ParseError } from \"../types\";\nimport { GRAMMAR } from \"./grammar\";\nimport { GrammarCompiler } from \"./grammar-compiler\";\n\n// Initialize grammar compiler\nconst compiler = new GrammarCompiler(GRAMMAR);\nconst compiled = compiler.compile();\n\n// ============================================\n// XML to AST Parsing\n// ============================================\n\n/**\n * Parse XML string into AST - determines document type automatically\n */\nexport function parseXmlToAst(\n  xmlString: string\n): IdyllDocument | AgentDocument | DiffDocument {\n  if (!xmlString || !xmlString.trim()) {\n    throw new ParseError(\"Empty XML content provided\");\n  }\n\n  // Parse XML\n  const options: xml2js.Options.XML2JS = {\n    compact: false,\n    textKey: \"text\",\n    ignoreDeclaration: true,\n    ignoreInstruction: true,\n    ignoreComment: true,\n    ignoreDoctype: true,\n    ignoreText: false,\n    trim: false,\n    sanitize: false,\n    nativeType: false,\n  };\n\n  let result: xml2js.Element;\n  try {\n    result = xml2js.xml2js(xmlString, options) as xml2js.Element;\n  } catch (error) {\n    throw new ParseError(\n      `Invalid XML format: ${\n        error instanceof Error ? error.message : \"Failed to parse XML\"\n      }`\n    );\n  }\n\n  // Determine root type and parse accordingly\n  const rootElement = result.elements?.[0];\n  if (!rootElement || rootElement.type !== \"element\") {\n    throw new ParseError(\"No root element found\");\n  }\n\n  switch (rootElement.name) {\n    case \"document\":\n      return parseDocument(rootElement);\n    case \"agent\":\n      return parseAgent(rootElement);\n    case \"diff\":\n      return parseDiff(rootElement);\n    default:\n      throw new ParseError(\n        `Unknown root element: ${rootElement.name}. Expected: document, agent, or diff`\n      );\n  }\n}\n\n/**\n * Parse document root\n */\nfunction parseDocument(documentElement: xml2js.Element): IdyllDocument {\n  // Validate document element\n  const attrs = documentElement.attributes || {};\n  const validationErrors = compiled.validateAttributes(\"document\", attrs);\n  if (validationErrors.length > 0) {\n    throw new ParseError(\n      `Document validation failed: ${validationErrors[0].message}`\n    );\n  }\n\n  const documentId = (attrs.id as string) || uuidv4();\n\n  // Parse nodes\n  const nodes: Node[] = [];\n  const childElements = documentElement.elements || [];\n\n  for (const element of childElements) {\n    if (element.type === \"element\" && element.name) {\n      const node = parseNode(element);\n      if (node) {\n        nodes.push(node);\n      }\n    }\n  }\n\n  return {\n    id: documentId,\n    nodes: nodes.length > 0 ? nodes : [createEmptyParagraph()],\n    metadata: extractMetadata(attrs),\n  };\n}\n\n/**\n * Parse agent root\n */\nfunction parseAgent(agentElement: xml2js.Element): AgentDocument {\n  const attrs = agentElement.attributes || {};\n  const validationErrors = compiled.validateAttributes(\"agent\", attrs);\n  if (validationErrors.length > 0) {\n    throw new ParseError(\n      `Agent validation failed: ${validationErrors[0].message}`\n    );\n  }\n\n  const agentId = (attrs.id as string) || uuidv4();\n\n  // Parse nodes (same as document)\n  const nodes: Node[] = [];\n  const childElements = agentElement.elements || [];\n\n  for (const element of childElements) {\n    if (element.type === \"element\" && element.name) {\n      const node = parseNode(element);\n      if (node) {\n        nodes.push(node);\n      }\n    }\n  }\n\n  return {\n    type: \"agent\",\n    id: agentId,\n    name: attrs.name as string,\n    description: attrs.description as string,\n    model: attrs.model as string,\n    nodes,\n  };\n}\n\n/**\n * Parse diff root\n */\nfunction parseDiff(diffElement: xml2js.Element): DiffDocument {\n  const attrs = diffElement.attributes || {};\n  const validationErrors = compiled.validateAttributes(\"diff\", attrs);\n  if (validationErrors.length > 0) {\n    throw new ParseError(\n      `Diff validation failed: ${validationErrors[0].message}`\n    );\n  }\n\n  // Parse edit operations\n  const operations: EditOperation[] = [];\n  const childElements = diffElement.elements || [];\n\n  for (const element of childElements) {\n    if (element.type === \"element\" && element.name) {\n      const operation = parseEditOperation(element);\n      if (operation) {\n        operations.push(operation);\n      }\n    }\n  }\n\n  return {\n    type: \"diff\",\n    targetDocument: attrs.targetDocument as string,\n    timestamp: attrs.timestamp\n      ? new Date(attrs.timestamp as string)\n      : new Date(),\n    operations,\n  };\n}\n\n/**\n * Parse edit operation\n */\nfunction parseEditOperation(element: xml2js.Element): EditOperation | null {\n  if (!element.name) return null;\n\n  const attrs = element.attributes || {};\n\n  switch (element.name) {\n    case \"edit:prop\":\n      return {\n        type: \"edit:attr\",\n        blockId: attrs[\"block-id\"] as string,\n        name: attrs.name as string,\n        value: attrs.value as string,\n      };\n\n    case \"edit:content\":\n      return {\n        type: \"edit:content\",\n        blockId: attrs[\"block-id\"] as string,\n        content: parseRichContent(element),\n      };\n\n    case \"insert\":\n      const insertNodes: Node[] = [];\n      for (const child of element.elements || []) {\n        if (child.type === \"element\" && child.name) {\n          const node = parseNode(child);\n          if (node) {\n            insertNodes.push(node);\n          }\n        }\n      }\n      return {\n        type: \"insert\",\n        afterBlockId: attrs[\"after-block-id\"] as string,\n        beforeBlockId: attrs[\"before-block-id\"] as string,\n        atStart: attrs[\"at-start\"] === \"true\",\n        atEnd: attrs[\"at-end\"] === \"true\",\n        blocks: insertNodes,\n      };\n\n    case \"delete\":\n      return {\n        type: \"delete\",\n        blockId: attrs[\"block-id\"] as string,\n      };\n\n    case \"replace\":\n      const replaceNodes: Node[] = [];\n      for (const child of element.elements || []) {\n        if (child.type === \"element\" && child.name) {\n          const node = parseNode(child);\n          if (node) {\n            replaceNodes.push(node);\n          }\n        }\n      }\n      return {\n        type: \"replace\",\n        blockId: attrs[\"block-id\"] as string,\n        blocks: replaceNodes,\n      };\n\n    default:\n      console.warn(`Unknown edit operation: ${element.name}`);\n      return null;\n  }\n}\n\n/**\n * Parse a node element using grammar rules\n */\nfunction parseNode(element: xml2js.Element): Node | null {\n  if (!element.name) return null;\n\n  const elementType = compiled.elementToType[element.name];\n  if (!elementType) {\n    return null;\n  }\n\n  const id = (element.attributes?.id as string) || uuidv4();\n  const attrs = element.attributes || {};\n\n  // Validate attributes\n  const errors = compiled.validateAttributes(element.name, attrs);\n  if (errors.length > 0) {\n    throw new ParseError(\n      `Invalid attributes for ${element.name}: ${errors[0].message}`\n    );\n  }\n\n  // Route based on element type\n  switch (elementType) {\n    case \"function_call\":\n      return parseFunctionCall(element, id, attrs);\n    case \"trigger\":\n      return parseTrigger(element, id, attrs);\n    case \"tool\":\n      return parseTool(element, id, attrs);\n    default:\n      return parseContentNode(element, id, attrs, elementType);\n  }\n}\n\n/**\n * Parse function call block\n */\nfunction parseFunctionCall(\n  element: xml2js.Element,\n  id: string,\n  attrs: Record<string, unknown>\n): ExecutableNode {\n  const tool = attrs[\"idyll-tool\"] as string;\n\n  let parameters: Record<string, unknown> = {};\n  let content: RichContent[] = [];\n  let result: unknown;\n\n  // Parse child elements according to grammar\n  for (const child of element.elements || []) {\n    if (child.type === \"element\" && child.name) {\n      switch (child.name) {\n        case \"params\":\n          const paramsText = extractTextContent(child);\n          if (paramsText) {\n            try {\n              parameters = JSON.parse(paramsText);\n            } catch {\n              throw new ParseError(`Invalid JSON in params: ${paramsText}`);\n            }\n          }\n          break;\n\n        case \"content\":\n          content = parseRichContent(child);\n          break;\n\n        case \"result\":\n          const resultText = extractTextContent(child);\n          if (resultText) {\n            try {\n              result = JSON.parse(resultText);\n            } catch {\n              result = resultText;\n            }\n          }\n          break;\n      }\n    }\n  }\n\n  return {\n    id,\n    type: \"function_call\",\n    tool,\n    parameters,\n    content: content.length > 0 ? content : undefined,\n    result: result ? { success: true, data: result } : undefined,\n    metadata: {\n      modelId: attrs.modelId as string,\n    },\n  };\n}\n\n/**\n * Parse trigger block\n */\nfunction parseTrigger(\n  element: xml2js.Element,\n  id: string,\n  attrs: Record<string, unknown>\n): ExecutableNode {\n  const tool = attrs[\"idyll-trigger\"] as string;\n  const enabled = attrs.enabled !== false;\n\n  let parameters: Record<string, unknown> = {};\n  let content: RichContent[] = [];\n\n  for (const child of element.elements || []) {\n    if (child.type === \"element\" && child.name) {\n      switch (child.name) {\n        case \"params\":\n          const paramsText = extractTextContent(child);\n          if (paramsText) {\n            try {\n              parameters = JSON.parse(paramsText);\n            } catch {\n              throw new ParseError(`Invalid JSON in params: ${paramsText}`);\n            }\n          }\n          break;\n\n        case \"content\":\n          content = parseRichContent(child);\n          break;\n      }\n    }\n  }\n\n  return {\n    id,\n    type: \"trigger\",\n    tool,\n    parameters,\n    content: content.length > 0 ? content : undefined,\n    metadata: { enabled },\n  };\n}\n\n/**\n * Parse tool block\n */\nfunction parseTool(\n  element: xml2js.Element,\n  id: string,\n  attrs: Record<string, unknown>\n): ContentNode {\n  // Tools are stored as content blocks with special props\n  const title = attrs.title as string;\n  const icon = attrs.icon as string;\n\n  let description = \"\";\n  let definition: Node[] = [];\n\n  for (const child of element.elements || []) {\n    if (child.type === \"element\" && child.name) {\n      switch (child.name) {\n        case \"tool:description\":\n          description = extractTextContent(child);\n          break;\n\n        case \"tool:definition\":\n          // Parse blocks within tool definition\n          for (const defChild of child.elements || []) {\n            if (defChild.type === \"element\" && defChild.name) {\n              // Check that it's not another tool (grammar constraint)\n              if (compiled.elementToType[defChild.name] === \"tool\") {\n                throw new ParseError(\"Tools cannot contain other tools\");\n              }\n\n              const node = parseNode(defChild);\n              if (node) {\n                definition.push(node);\n              }\n            }\n          }\n          break;\n      }\n    }\n  }\n\n  return {\n    id,\n    type: \"tool\" as ContentNodeType,\n    content: [{ type: \"text\", text: description }],\n    children: definition.length > 0 ? definition : undefined,\n    props: { title, icon },\n  };\n}\n\n/**\n * Parse content block\n */\nfunction parseContentNode(\n  element: xml2js.Element,\n  id: string,\n  attrs: Record<string, unknown>,\n  blockType: string\n): ContentNode {\n  const content = parseRichContent(element);\n\n  // Parse children for nested blocks\n  const children: Node[] = [];\n  for (const child of element.elements || []) {\n    if (child.type === \"element\" && child.name) {\n      const childType = compiled.elementToType[child.name];\n      if (childType && compiled.blockTypes.has(childType)) {\n        const childNode = parseNode(child);\n        if (childNode) {\n          children.push(childNode);\n        }\n      }\n    }\n  }\n\n  // Handle heading level\n  if (blockType === \"heading\") {\n    if (element.name === \"heading\") {\n      // Already has level attribute\n    } else if (element.name) {\n      const match = element.name.match(/^h(\\d)$/);\n      if (match) {\n        attrs.level = parseInt(match[1], 10);\n      }\n    }\n  }\n\n  return {\n    id,\n    type: blockType as ContentNodeType,\n    content,\n    children: children.length > 0 ? children : undefined,\n    props: attrs,\n  };\n}\n\n/**\n * Parse rich content using grammar rules\n */\nfunction parseRichContent(element: xml2js.Element): RichContent[] {\n  const content: RichContent[] = [];\n\n  if (!element.elements) return content;\n\n  for (const child of element.elements) {\n    if (child.type === \"text\" && child.text) {\n      content.push({\n        type: \"text\",\n        text: child.text as string,\n      });\n    } else if (child.type === \"element\" && child.name) {\n      const inlineElement = parseInlineElement(child);\n      if (inlineElement) {\n        if (Array.isArray(inlineElement)) {\n          // Filter out any null values from the array\n          content.push(...inlineElement.filter(item => item != null));\n        } else {\n          content.push(inlineElement);\n        }\n      }\n    }\n  }\n\n  return content;\n}\n\n/**\n * Parse inline element\n */\nfunction parseInlineElement(\n  element: xml2js.Element\n): RichContent | RichContent[] | null {\n  if (!element.name) return null;\n\n  // Check if it's a mention\n  if (element.name.startsWith(\"mention:\")) {\n    const mentionType = element.name.substring(8) as any;\n    const id = element.attributes?.id as string;\n    const label =\n      (element.attributes?.label as string) || extractTextContent(element);\n\n    return {\n      type: \"mention\",\n      mentionType,\n      id,\n      label,\n    } as MentionElement;\n  }\n\n  // Check if it's a variable\n  if (element.name === \"variable\") {\n    const name = element.attributes?.name as string;\n    const prompt = element.attributes?.prompt as string;\n    const value = element.attributes?.value as string;\n    \n    // Variable must have a name\n    if (!name) {\n      console.warn('Variable element missing required \"name\" attribute');\n      return null;\n    }\n    \n    return {\n      type: \"variable\",\n      name,\n      ...(prompt && { prompt }),\n      ...(value && { value }),\n    } as VariableElement;\n  }\n\n  // Check if it's a link\n  if (element.name === \"a\") {\n    const href = element.attributes?.href as string;\n    return {\n      type: \"link\",\n      href,\n      content: parseRichContent(element),\n    } as LinkElement;\n  }\n\n  // Check if it's an annotation\n  if (element.name === \"annotation\") {\n    return {\n      type: \"annotation\",\n      content: parseRichContent(element),\n      annotation: (element.attributes as any) || {},\n    } as AnnotationElement;\n  }\n\n  // Check if it's annotated text\n  if (element.name === \"annotatedtext\") {\n    const annotation = element.attributes?.annotation as string;\n    return {\n      type: \"annotation\",\n      content: parseRichContent(element),\n      annotation: { title: annotation },\n    } as AnnotationElement;\n  }\n\n  // Check if it's AI edit response\n  if (element.name === \"aieditresponse\") {\n    const status = element.attributes?.status as string;\n    return {\n      type: \"annotation\",\n      content: parseRichContent(element),\n      annotation: { type: \"ai-edit\", status },\n    } as AnnotationElement;\n  }\n\n  // Check if it's a style element\n  const styleMap: Record<string, TextStyle> = {\n    strong: \"bold\",\n    b: \"bold\",\n    em: \"italic\",\n    i: \"italic\",\n    u: \"underline\",\n    underline: \"underline\",\n    s: \"strikethrough\",\n    strike: \"strikethrough\",\n    del: \"strikethrough\",\n    code: \"code\",\n    tt: \"code\",\n  };\n\n  const style = styleMap[element.name];\n  if (style) {\n    const innerContent = parseRichContent(element);\n    return innerContent.map((item) => {\n      if (isTextContent(item)) {\n        return {\n          ...item,\n          styles: [...(item.styles || []), style],\n        } as TextContent;\n      }\n      return item;\n    });\n  }\n\n  return null;\n}\n\n// ============================================\n// AST to XML Serialization\n// ============================================\n\n/**\n * Serialize AST document to XML string\n */\nexport function serializeAstToXml(\n  document: IdyllDocument | AgentDocument | DiffDocument\n): string {\n  let root: xml2js.Element;\n\n  if (\"type\" in document) {\n    if (document.type === \"agent\") {\n      root = serializeAgentDocument(document);\n    } else if (document.type === \"diff\") {\n      root = serializeDiffDocument(document);\n    } else {\n      throw new Error(`Unknown document type`);\n    }\n  } else {\n    root = serializeIdyllDocument(document);\n  }\n\n  const options: xml2js.Options.JS2XML = {\n    compact: false,\n    spaces: 2,\n    textKey: \"text\",\n  };\n\n  // xml2js expects the root element to be wrapped in an object with elements array\n  const wrapped = {\n    elements: [root]\n  };\n\n  return `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n${xml2js.js2xml(\n    wrapped,\n    options\n  )}`;\n}\n\n/**\n * Serialize IdyllDocument\n */\nfunction serializeIdyllDocument(document: IdyllDocument): xml2js.Element {\n  return {\n    type: \"element\",\n    name: \"document\",\n    attributes: {\n      id: document.id,\n      ...serializeMetadata(document.metadata),\n    },\n    elements: document.nodes.map(serializeNode),\n  };\n}\n\n/**\n * Serialize AgentDocument\n */\nfunction serializeAgentDocument(document: AgentDocument): xml2js.Element {\n  return {\n    type: \"element\",\n    name: \"agent\",\n    attributes: {\n      id: document.id,\n      ...(document.name && { name: document.name }),\n      ...(document.description && { description: document.description }),\n      ...(document.model && { model: document.model }),\n    },\n    elements: document.nodes.map(serializeNode),\n  };\n}\n\n/**\n * Serialize DiffDocument\n */\nfunction serializeDiffDocument(document: DiffDocument): xml2js.Element {\n  return {\n    type: \"element\",\n    name: \"diff\",\n    attributes: {\n      ...(document.targetDocument && {\n        targetDocument: document.targetDocument,\n      }),\n      timestamp: document.timestamp.toISOString(),\n    },\n    elements: document.operations.map(serializeEditOperation),\n  };\n}\n\n/**\n * Serialize a block to XML element\n */\nfunction serializeNode(node: Node): xml2js.Element {\n  if (isExecutableNode(node)) {\n    return serializeExecutableNode(node);\n  }\n\n  // Special handling for tool nodes\n  if (node.type === \"tool\") {\n    return serializeToolNode(node);\n  }\n\n  return serializeContentNode(node);\n}\n\n/**\n * Serialize executable block\n */\nfunction serializeExecutableNode(node: ExecutableNode): xml2js.Element {\n  const elements: xml2js.Element[] = [];\n\n  // Add params\n  if (Object.keys(node.parameters).length > 0) {\n    elements.push({\n      type: \"element\",\n      name: \"params\",\n      elements: [\n        {\n          type: \"cdata\",\n          cdata: JSON.stringify(node.parameters),\n        },\n      ],\n    });\n  }\n\n  // Add content\n  if (node.content && node.content.length > 0) {\n    elements.push({\n      type: \"element\",\n      name: \"content\",\n      elements: serializeRichContent(node.content),\n    });\n  }\n\n  if (node.type === \"function_call\") {\n    // Add result\n    if (node.result) {\n      elements.push({\n        type: \"element\",\n        name: \"result\",\n        elements: [\n          {\n            type: \"cdata\",\n            cdata: JSON.stringify(node.result.data || node.result),\n          },\n        ],\n      });\n    }\n\n    return {\n      type: \"element\",\n      name: \"fncall\",\n      attributes: {\n        id: node.id,\n        \"idyll-tool\": node.tool,\n        ...(node.metadata?.modelId && { modelId: node.metadata.modelId }),\n      },\n      elements,\n    };\n  } else {\n    return {\n      type: \"element\",\n      name: \"trigger\",\n      attributes: {\n        id: node.id,\n        \"idyll-trigger\": node.tool,\n        enabled: String(node.metadata?.enabled !== false),\n      },\n      elements,\n    };\n  }\n}\n\n/**\n * Serialize tool block\n */\nfunction serializeToolNode(node: ContentNode): xml2js.Element {\n  const elements: xml2js.Element[] = [];\n\n  // Add description\n  const description = node.content\n    .map((c) => (isTextContent(c) ? c.text : \"\"))\n    .join(\"\");\n\n  elements.push({\n    type: \"element\",\n    name: \"tool:description\",\n    elements: [{ type: \"text\", text: description }],\n  });\n\n  // Add definition\n  if (node.children && node.children.length > 0) {\n    elements.push({\n      type: \"element\",\n      name: \"tool:definition\",\n      elements: node.children.map(serializeNode),\n    });\n  }\n\n  const attributes: Record<string, string> = {\n    id: node.id,\n    title: node.props?.title as string,\n  };\n\n  if (node.props?.icon) {\n    attributes.icon = node.props.icon as string;\n  }\n\n  return {\n    type: \"element\",\n    name: \"tool\",\n    attributes,\n    elements,\n  };\n}\n\n/**\n * Serialize content block\n */\nfunction serializeContentNode(node: ContentNode): xml2js.Element {\n  const elements = [\n    ...serializeRichContent(node.content),\n    ...(node.children || []).map(serializeNode),\n  ];\n\n  // Get element name from type\n  const typeToElement = Object.entries(compiled.elementToType).reduce(\n    (acc, [elem, type]) => {\n      if (!acc[type]) acc[type] = [];\n      acc[type].push(elem);\n      return acc;\n    },\n    {} as Record<string, string[]>\n  );\n\n  let elementName = typeToElement[node.type]?.[0] || \"p\";\n\n  // Special handling for headings\n  if (node.type === \"heading\" && node.props?.level) {\n    elementName = `h${node.props.level}`;\n  }\n\n  return {\n    type: \"element\",\n    name: elementName,\n    attributes: {\n      id: node.id,\n      ...cleanProps(node.props),\n    },\n    elements: elements.length > 0 ? elements : undefined,\n  };\n}\n\n/**\n * Serialize rich content\n */\nfunction serializeRichContent(\n  content: RichContent[]\n): (xml2js.Element | { type: \"text\"; text: string })[] {\n  return content.map((item) => {\n    if (isTextContent(item)) {\n      if (item.styles && item.styles.length > 0) {\n        // Map styles to elements\n        const styleToElement: Record<TextStyle, string> = {\n          bold: \"strong\",\n          italic: \"em\",\n          underline: \"u\",\n          strikethrough: \"s\",\n          code: \"code\",\n        };\n\n        // Wrap in style elements\n        let element: xml2js.Element = {\n          type: \"element\",\n          name: styleToElement[item.styles[0]],\n          elements: [{ type: \"text\", text: item.text }],\n        };\n\n        // Nest additional styles\n        for (let i = 1; i < item.styles.length; i++) {\n          element = {\n            type: \"element\",\n            name: styleToElement[item.styles[i]],\n            elements: [element],\n          };\n        }\n\n        return element;\n      }\n      return { type: \"text\", text: item.text };\n    }\n\n    // Handle other inline elements\n    switch (item.type) {\n      case \"mention\":\n        return {\n          type: \"element\",\n          name: `mention:${item.mentionType}`,\n          attributes: {\n            id: item.id,\n            ...(item.label && { label: item.label }),\n          },\n          elements: item.label\n            ? undefined\n            : [{ type: \"text\", text: item.label || \"\" }],\n        };\n\n      case \"variable\":\n        return {\n          type: \"element\",\n          name: \"variable\",\n          attributes: {\n            name: item.name,\n            ...(item.prompt && { prompt: item.prompt }),\n            ...(item.value && { value: item.value }),\n          },\n        };\n\n      case \"link\":\n        return {\n          type: \"element\",\n          name: \"a\",\n          attributes: { href: item.href },\n          elements: serializeRichContent(item.content),\n        };\n\n      case \"annotation\":\n        return {\n          type: \"element\",\n          name: \"annotation\",\n          attributes: {\n            ...(item.annotation.title && { title: String(item.annotation.title) }),\n            ...(item.annotation.comment && { comment: String(item.annotation.comment) }),\n            ...(item.annotation.confidence !== undefined && { confidence: String(item.annotation.confidence) }),\n          },\n          elements: serializeRichContent(item.content),\n        };\n\n      default:\n        return { type: \"text\", text: \"\" };\n    }\n  });\n}\n\n// ============================================\n// Utility Functions\n// ============================================\n\nfunction extractTextContent(element: xml2js.Element): string {\n  let text = \"\";\n\n  if (element.elements) {\n    for (const child of element.elements) {\n      if (child.type === \"text\" && child.text) {\n        text += child.text;\n      } else if (child.type === \"cdata\" && child.cdata) {\n        text += child.cdata;\n      } else if (child.type === \"element\") {\n        text += extractTextContent(child);\n      }\n    }\n  }\n\n  return text;\n}\n\nfunction createEmptyParagraph(): ContentNode {\n  return {\n    id: uuidv4(),\n    type: \"paragraph\",\n    content: [],\n  };\n}\n\nfunction extractMetadata(\n  attrs: Record<string, unknown>\n): Record<string, unknown> | undefined {\n  const metadata: Record<string, unknown> = {};\n\n  if (attrs.version) metadata.version = attrs.version;\n  if (attrs.created) metadata.created = new Date(attrs.created as string);\n  if (attrs.modified) metadata.modified = new Date(attrs.modified as string);\n\n  return Object.keys(metadata).length > 0 ? metadata : undefined;\n}\n\nfunction serializeMetadata(\n  metadata?: Record<string, unknown>\n): Record<string, string> {\n  if (!metadata) return {};\n\n  const result: Record<string, string> = {};\n\n  if (metadata.version) result.version = String(metadata.version);\n  if (metadata.created instanceof Date)\n    result.created = metadata.created.toISOString();\n  if (metadata.modified instanceof Date)\n    result.modified = metadata.modified.toISOString();\n\n  return result;\n}\n\n/**\n * Clean props by removing default/empty values to reduce XML verbosity\n */\nfunction cleanProps(props?: Record<string, unknown>): Record<string, unknown> {\n  if (!props) return {};\n\n  const cleaned: Record<string, unknown> = {};\n  \n  // Default values to exclude\n  const defaultValues = new Set([\n    'default',\n    'left',     // default text alignment\n    'normal',   // default font weight, etc.\n    '',         // empty strings\n    null,\n    undefined\n  ]);\n\n  for (const [key, value] of Object.entries(props)) {\n    // Skip default values\n    if (defaultValues.has(value as any)) {\n      continue;\n    }\n    \n    // Skip empty arrays and objects\n    if (Array.isArray(value) && value.length === 0) {\n      continue;\n    }\n    if (value && typeof value === 'object' && Object.keys(value).length === 0) {\n      continue;\n    }\n    \n    // Keep non-default values\n    cleaned[key] = value;\n  }\n\n  return cleaned;\n}\n\n/**\n * Serialize edit operation\n */\nfunction serializeEditOperation(operation: EditOperation): xml2js.Element {\n  switch (operation.type) {\n    case \"edit:attr\":\n      return {\n        type: \"element\",\n        name: \"edit:prop\",\n        attributes: {\n          \"block-id\": operation.blockId,\n          name: operation.name,\n          value: operation.value,\n        },\n      };\n\n    case \"edit:content\":\n      return {\n        type: \"element\",\n        name: \"edit:content\",\n        attributes: {\n          \"block-id\": operation.blockId,\n        },\n        elements: serializeRichContent(operation.content),\n      };\n\n    case \"insert\":\n      return {\n        type: \"element\",\n        name: \"insert\",\n        attributes: {\n          ...(operation.afterBlockId && {\n            \"after-block-id\": operation.afterBlockId,\n          }),\n          ...(operation.beforeBlockId && {\n            \"before-block-id\": operation.beforeBlockId,\n          }),\n          ...(operation.atStart && { \"at-start\": \"true\" }),\n          ...(operation.atEnd && { \"at-end\": \"true\" }),\n        },\n        elements: operation.blocks.map(serializeNode),\n      };\n\n    case \"delete\":\n      return {\n        type: \"element\",\n        name: \"delete\",\n        attributes: {\n          \"block-id\": operation.blockId,\n        },\n      };\n\n    case \"replace\":\n      return {\n        type: \"element\",\n        name: \"replace\",\n        attributes: {\n          \"block-id\": operation.blockId,\n        },\n        elements: operation.blocks.map(serializeNode),\n      };\n\n    default:\n      throw new Error(`Unknown operation type`);\n  }\n}\n\n","/**\n * Consolidated type definitions for Idyll Engine\n */\n\nimport type { MentionElement, VariableElement } from './document/ast';\n\n// ============================================\n// Validation Context\n// ============================================\n\n/**\n * Context for validating document references\n */\nexport interface ValidationContext {\n  /**\n   * Validate that a mention reference exists\n   * @param mention The mention to validate\n   * @returns True if valid, false otherwise\n   */\n  validateMention?(mention: MentionElement): boolean;\n  \n  /**\n   * Validate that a variable exists and optionally get its value\n   * @param variable The variable to validate\n   * @returns Validation result with optional value\n   */\n  validateVariable?(variable: VariableElement): {\n    valid: boolean;\n    value?: unknown;\n  };\n  \n  /**\n   * Validate that a tool exists\n   * @param toolName The tool name to validate\n   * @returns True if tool exists, false otherwise\n   */\n  validateTool?(toolName: string): boolean;\n}\n\n// ============================================\n// Execution Context\n// ============================================\n\n/**\n * Runtime context for document/agent execution\n */\nexport interface ExecutionContext {\n  /**\n   * User performing the execution\n   */\n  user: {\n    id: string;\n    name?: string;\n    email?: string;\n  };\n  \n  /**\n   * Available variables during execution\n   */\n  variables: Record<string, unknown>;\n  \n  /**\n   * Resolve a mention to its value\n   * @param mention The mention to resolve\n   * @returns The resolved value or undefined\n   */\n  resolveMention?(mention: MentionElement): unknown;\n  \n  /**\n   * Resolve a variable to its value\n   * @param variable The variable to resolve\n   * @returns The resolved value or undefined\n   */\n  resolveVariable?(variable: VariableElement): unknown;\n  \n  /**\n   * Additional metadata\n   */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Context specific to document execution\n */\nexport interface DocumentExecutionContext extends ExecutionContext {\n  /**\n   * Document being executed\n   */\n  documentId: string;\n  \n  /**\n   * Whether the user can edit the document\n   */\n  canEdit: boolean;\n}\n\n/**\n * Context specific to agent execution\n */\nexport interface AgentExecutionContext extends ExecutionContext {\n  /**\n   * Agent performing the execution\n   */\n  agentId: string;\n  \n  /**\n   * Thread ID if in a conversation\n   */\n  threadId?: string;\n  \n  /**\n   * Conversation history if available\n   */\n  messages?: Array<{\n    role: 'user' | 'assistant' | 'system';\n    content: string;\n  }>;\n}\n\n// ============================================\n// Tool Definition\n// ============================================\n\n/**\n * Definition of a tool that can be executed\n */\nexport interface ToolDefinition {\n  /**\n   * Unique tool identifier (e.g., \"documents:create\")\n   */\n  name: string;\n  \n  /**\n   * Human-readable title\n   */\n  title?: string;\n  \n  /**\n   * Tool description\n   */\n  description?: string;\n  \n  /**\n   * Whether the tool requires content/instructions\n   */\n  contentRequirement?: 'required' | 'optional' | 'disabled';\n  \n  /**\n   * Validate parameters before execution\n   * @param params The parameters to validate\n   * @returns Validation result\n   */\n  validate(params: unknown): ToolValidationResult;\n}\n\nexport type ToolValidationResult = \n  | { success: true }\n  | { success: false; errors: string[] };\n\n// ============================================\n// Tool Resolution & Execution\n// ============================================\n\n/**\n * Interface for resolving tool definitions\n */\nexport interface ToolResolver {\n  /**\n   * Resolve a tool by name\n   * @param name Tool identifier\n   * @returns Tool definition or null if not found\n   */\n  resolve(name: string): ToolDefinition | null;\n  \n  /**\n   * List all available tools\n   * @returns Array of tool names\n   */\n  list?(): string[];\n}\n\n/**\n * Interface for executing tools\n */\nexport interface ToolExecutor {\n  /**\n   * Execute a tool with given parameters\n   * @param tool Tool name\n   * @param params Tool parameters (already validated)\n   * @param context Execution context\n   * @returns Tool execution result\n   */\n  execute(\n    tool: string, \n    params: Record<string, unknown>, \n    context: ToolExecutionContext\n  ): Promise<ToolResult>;\n}\n\n/**\n * Context provided during tool execution\n */\nexport interface ToolExecutionContext {\n  /**\n   * Execution mode - where the tool is being executed from\n   */\n  mode: 'document' | 'agent';\n  \n  /**\n   * User executing the tool\n   */\n  user: {\n    id: string;\n    name?: string;\n    email?: string;\n  };\n  \n  /**\n   * Instructions/content provided with the tool call\n   */\n  instructions?: string;\n  \n  /**\n   * Document-specific context\n   */\n  document?: {\n    id: string;\n    nodeId: string;\n  };\n  \n  /**\n   * Agent-specific context\n   */\n  agent?: {\n    id: string;\n    threadId?: string;\n  };\n  \n  /**\n   * Additional metadata\n   */\n  metadata?: Record<string, unknown>;\n}\n\n// ============================================\n// Tool Results\n// ============================================\n\n/**\n * Result from tool execution\n */\nexport interface ToolResult {\n  success: boolean;\n  data?: unknown;\n  error?: ToolError;\n  /**\n   * Human-readable message about the result\n   */\n  message?: string;\n}\n\nexport interface ToolError {\n  code: string;\n  message: string;\n  details?: unknown;\n}\n\n/**\n * Helper class for creating tool results\n */\nexport class ToolResponse {\n  static success(data: unknown, message?: string): ToolResult {\n    return {\n      success: true,\n      data,\n      message,\n    };\n  }\n  \n  static error(error: string | ToolError, details?: unknown): ToolResult {\n    if (typeof error === 'string') {\n      return {\n        success: false,\n        error: {\n          code: 'TOOL_ERROR',\n          message: error,\n          details,\n        },\n      };\n    }\n    return {\n      success: false,\n      error,\n    };\n  }\n  \n  static empty(): ToolResult {\n    return {\n      success: true,\n    };\n  }\n}\n\n// ============================================\n// Error Types\n// ============================================\n\n/**\n * Base error class for all engine errors\n */\nexport class IdyllEngineError extends Error {\n  constructor(\n    message: string,\n    public code: string,\n    public details?: unknown\n  ) {\n    super(message);\n    this.name = 'IdyllEngineError';\n  }\n}\n\n/**\n * Error during document parsing\n */\nexport class ParseError extends IdyllEngineError {\n  constructor(message: string, details?: unknown) {\n    super(message, 'PARSE_ERROR', details);\n    this.name = 'ParseError';\n  }\n}\n\n/**\n * Error during document validation\n */\nexport class ValidationError extends IdyllEngineError {\n  constructor(\n    message: string,\n    public errors: string[],\n    details?: unknown\n  ) {\n    super(message, 'VALIDATION_ERROR', details);\n    this.name = 'ValidationError';\n  }\n}\n\n/**\n * Error during tool execution\n */\nexport class ToolExecutionError extends IdyllEngineError {\n  constructor(\n    message: string,\n    public toolName: string,\n    public nodeId?: string,\n    details?: unknown\n  ) {\n    super(message, 'TOOL_EXECUTION_ERROR', details);\n    this.name = 'ToolExecutionError';\n  }\n}\n\n/**\n * Error when a tool is not found\n */\nexport class ToolNotFoundError extends IdyllEngineError {\n  constructor(toolName: string) {\n    super(`Tool not found: ${toolName}`, 'TOOL_NOT_FOUND', { toolName });\n    this.name = 'ToolNotFoundError';\n  }\n}\n\n/**\n * Error during agent execution\n */\nexport class AgentExecutionError extends IdyllEngineError {\n  constructor(\n    message: string,\n    public agentId: string,\n    details?: unknown\n  ) {\n    super(message, 'AGENT_EXECUTION_ERROR', details);\n    this.name = 'AgentExecutionError';\n  }\n}\n\n// ============================================\n// Error Utilities\n// ============================================\n\n/**\n * Check if an error is an engine error\n */\nexport function isIdyllEngineError(error: unknown): error is IdyllEngineError {\n  return error instanceof IdyllEngineError;\n}\n\n/**\n * Format error for display\n */\nexport function formatError(error: unknown): string {\n  if (isIdyllEngineError(error)) {\n    return `${error.code}: ${error.message}`;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return String(error);\n}","/**\n * Grammar DSL Types and Builder Functions\n * \n * Provides the core types and helper functions for building grammars.\n */\n\n// ============================================\n// DSL Types\n// ============================================\n\nexport type Rule = \n  | TerminalRule\n  | SequenceRule\n  | ChoiceRule\n  | RepeatRule\n  | OptionalRule\n  | RefRule;\n\ninterface TerminalRule {\n  type: 'terminal';\n  element: string;\n  attributes?: Record<string, AttributeDef>;\n  content?: 'text' | 'rich' | 'json' | 'none';\n}\n\ninterface SequenceRule {\n  type: 'sequence';\n  rules: Rule[];\n}\n\ninterface ChoiceRule {\n  type: 'choice';\n  rules: Rule[];\n}\n\ninterface RepeatRule {\n  type: 'repeat';\n  rule: Rule;\n  min: number;\n  max: number | null; // null = unbounded\n}\n\ninterface OptionalRule {\n  type: 'optional';\n  rule: Rule;\n}\n\ninterface RefRule {\n  type: 'ref';\n  name: string;\n}\n\nexport interface AttributeDef {\n  type: 'string' | 'number' | 'boolean' | 'enum';\n  required?: boolean;\n  values?: readonly string[];\n  pattern?: RegExp;\n  validate?: (value: unknown) => string | null;\n  default?: any;\n}\n\n// ============================================\n// DSL Builder Functions\n// ============================================\n\nexport function terminal(element: string, attrs?: Record<string, AttributeDef>, content?: 'text' | 'rich' | 'json' | 'none'): TerminalRule {\n  return { type: 'terminal', element, attributes: attrs, content };\n}\n\nexport function seq(...rules: (Rule | string)[]): SequenceRule {\n  return { \n    type: 'sequence', \n    rules: rules.map(r => typeof r === 'string' ? ref(r) : r)\n  };\n}\n\nexport function choice(...rules: (Rule | string)[]): ChoiceRule {\n  return { \n    type: 'choice', \n    rules: rules.map(r => typeof r === 'string' ? ref(r) : r)\n  };\n}\n\nexport function repeat(rule: Rule | string, min = 0, max: number | null = null): RepeatRule {\n  return { \n    type: 'repeat', \n    rule: typeof rule === 'string' ? ref(rule) : rule,\n    min, \n    max \n  };\n}\n\nexport function optional(rule: Rule | string): OptionalRule {\n  return { \n    type: 'optional', \n    rule: typeof rule === 'string' ? ref(rule) : rule\n  };\n}\n\nexport function ref(name: string): RefRule {\n  return { type: 'ref', name };\n}\n\n// Shorthand helpers\nexport const zeroOrMore = (rule: Rule | string) => repeat(rule, 0, null);\nexport const oneOrMore = (rule: Rule | string) => repeat(rule, 1, null);\nexport const zeroOrOne = optional;","/**\n * Document Grammar for Idyll Documents\n * \n * Defines the structure for content documents with blocks and rich text.\n */\n\nimport { Rule, terminal, seq, choice, repeat, optional, ref, oneOrMore, zeroOrMore } from './grammar-dsl';\n\nexport const DOCUMENT_GRAMMAR: Record<string, Rule> = {\n  // Document root\n  document: seq(\n    terminal('document', { \n      id: { type: 'string', required: false },\n      version: { type: 'string', required: false },\n      created: { type: 'string', required: false },\n      modified: { type: 'string', required: false }\n    }),\n    zeroOrMore('block')\n  ),\n\n  // Blocks\n  block: choice(\n    'content-block',\n    'executable-block', \n    'tool-block'\n  ),\n\n  'content-block': choice(\n    'paragraph',\n    'heading',\n    'bullet-list-item',\n    'numbered-list-item',\n    'checklist-item',\n    'code',\n    'quote',\n    'separator',\n    'data'\n  ),\n\n  'executable-block': choice(\n    'function-call',\n    'trigger'\n  ),\n\n  // Content blocks\n  paragraph: choice(\n    terminal('p', {}, 'rich'),\n    terminal('paragraph', {}, 'rich') // legacy support\n  ),\n  \n  heading: choice(\n    terminal('h1', {}, 'rich'),\n    terminal('h2', {}, 'rich'),\n    terminal('h3', {}, 'rich'),\n    terminal('h4', {}, 'rich'),\n    terminal('h5', {}, 'rich'),\n    terminal('h6', {}, 'rich'),\n    terminal('heading', { // legacy support\n      level: { type: 'number', required: true, validate: (v: unknown) => {\n        const num = Number(v);\n        return num >= 1 && num <= 6 ? null : 'Level must be 1-6';\n      }}\n    }, 'rich')\n  ),\n\n  // List items (individual blocks, no containers)\n  'bullet-list-item': terminal('bulletlistitem', {}, 'rich'),\n  \n  'numbered-list-item': terminal('numberedlistitem', {}, 'rich'),\n  \n  'checklist-item': terminal('checklistitem', {\n    checked: { type: 'boolean', required: true }\n  }, 'rich'),\n\n  code: terminal('code', { \n    language: { type: 'string', required: false } \n  }, 'text'),\n\n  quote: terminal('quote', {\n    author: { type: 'string', required: false },\n    source: { type: 'string', required: false }\n  }, 'rich'),\n\n  separator: terminal('separator', {}, 'none'),\n  \n  data: terminal('data', {\n    title: { type: 'string', required: false }\n  }, 'text'),\n\n  // Executable blocks\n  'function-call': seq(\n    terminal('fncall', {\n      'idyll-tool': {\n        type: 'string',\n        required: true,\n        // Format: \\\"module:function\\\" or just \\\"function\\\" (e.g., \\\"demo:echo\\\", \\\"ai:analyzeText\\\", \\\"echo\\\")\n        // Module and function names MUST be valid JS identifiers\n        // For Azure Functions compatibility, transform at adapter layer:\n        // \\\"module:function\\\"  \\\"module--function\\\" (double hyphen separator)\n        pattern: /^([a-zA-Z_$][a-zA-Z0-9_$]*:)?[a-zA-Z_$][a-zA-Z0-9_$]*$/\n      },\n      modelId: { type: 'string', required: false }\n    }),\n    optional('params'),\n    optional('content'),\n    optional('result')\n  ),\n\n  trigger: seq(\n    terminal('trigger', {\n      'idyll-trigger': {\n        type: 'string',\n        required: true,\n        // Format: \\\"module:trigger\\\" or just \\\"trigger\\\" (e.g., \\\"time:schedule\\\", \\\"webhook:receive\\\", \\\"daily\\\")\n        // Module and trigger names MUST be valid JS identifiers\n        // For Azure Functions compatibility, transform at adapter layer:\n        // \\\"module:trigger\\\"  \\\"module--trigger\\\" (double hyphen separator)\n        pattern: /^([a-zA-Z_$][a-zA-Z0-9_$]*:)?[a-zA-Z_$][a-zA-Z0-9_$]*$/\n      },\n      enabled: { type: 'boolean', default: true }\n    }),\n    optional('params'),\n    optional('content')\n  ),\n\n  // Tool blocks\n  'tool-block': seq(\n    terminal('tool', {\n      title: { type: 'string', required: true },\n      icon: { type: 'string', required: false }\n    }),\n    ref('tool-description'),\n    ref('tool-definition')\n  ),\n\n  'tool-description': terminal('tool:description', {}, 'text'),\n\n  'tool-definition': seq(\n    terminal('tool:definition'),\n    zeroOrMore(choice('content-block', 'executable-block')) // no nested tools!\n  ),\n\n  // Function call children\n  params: seq(\n    terminal('params'),\n    ref('json-content')\n  ),\n\n  content: seq(\n    terminal('content'),\n    ref('rich-content')\n  ),\n\n  result: seq(\n    terminal('result'),\n    ref('json-content')\n  ),\n\n  // Content types\n  'rich-content': zeroOrMore(choice(\n    'text',\n    'styled-text',\n    'mention',\n    'variable',\n    'link',\n    'annotation',\n    'annotated-text',\n    'ai-edit-response'\n  )),\n\n  'text-content': terminal('_text', {}, 'text'), // pseudo-element for plain text\n  'json-content': terminal('_json', {}, 'json'), // pseudo-element for JSON\n\n  // Inline elements\n  'styled-text': choice(\n    seq(choice(terminal('strong'), terminal('b')), ref('rich-content')),\n    seq(choice(terminal('em'), terminal('i')), ref('rich-content')),\n    seq(choice(terminal('u'), terminal('underline')), ref('rich-content')),\n    seq(choice(terminal('s'), terminal('strike'), terminal('del')), ref('rich-content')),\n    seq(choice(terminal('code'), terminal('tt')), ref('rich-content'))\n  ),\n  \n  annotation: seq(\n    terminal('annotation', {\n      title: { type: 'string', required: false },\n      comment: { type: 'string', required: false },\n      confidence: { type: 'number', required: false }\n    }),\n    ref('rich-content')\n  ),\n\n  mention: choice(\n    terminal('mention:user', { \n      id: { type: 'string', required: true },\n      label: { type: 'string', required: false }\n    }, 'text'),\n    terminal('mention:document', { \n      id: { type: 'string', required: true },\n      label: { type: 'string', required: false }\n    }, 'text'),\n    terminal('mention:agent', { \n      id: { type: 'string', required: true },\n      label: { type: 'string', required: false }\n    }, 'text'),\n    terminal('mention:custom', {\n      id: { type: 'string', required: true },\n      type: { type: 'string', required: true },\n      label: { type: 'string', required: false }\n    }, 'text')\n  ),\n\n  variable: terminal('variable', { \n    name: { type: 'string', required: true },\n    prompt: { type: 'string', required: false },\n    value: { type: 'string', required: false }\n  }, 'none'),\n\n  link: seq(\n    terminal('a', { \n      href: { type: 'string', required: true, pattern: /^https?:\\/\\/.+/ } \n    }),\n    ref('rich-content')\n  ),\n  \n  'annotated-text': seq(\n    terminal('annotatedtext', {\n      annotation: { type: 'string', required: true }\n    }),\n    ref('rich-content')\n  ),\n  \n  'ai-edit-response': seq(\n    terminal('aieditresponse', {\n      status: { type: 'enum', values: ['pending', 'accepted', 'rejected'] as const, required: true }\n    }),\n    ref('rich-content')\n  ),\n\n  text: terminal('_text', {}, 'text'), // Raw text node\n};","/**\n * Agent Grammar for Idyll System Prompts\n * \n * Defines the structure for agent documents containing system prompts.\n */\n\nimport { Rule, terminal, seq, zeroOrMore } from './grammar-dsl';\n\nexport const AGENT_GRAMMAR: Record<string, Rule> = {\n  // Agent system prompt root\n  agent: seq(\n    terminal('agent', {\n      id: { type: 'string', required: false },\n      name: { type: 'string', required: false },\n      description: { type: 'string', required: false },\n      model: { type: 'string', required: false }\n    }),\n    zeroOrMore('block')\n  )\n};\n\n// Note: Agent grammar references 'block' from document grammar\n// This will be resolved when grammars are combined","/**\n * Diff Grammar for Idyll Document Transformations\n * \n * Defines the structure for diff operations that modify documents.\n */\n\nimport { Rule, terminal, seq, oneOrMore, choice, ref } from './grammar-dsl';\n\nexport const DIFF_GRAMMAR: Record<string, Rule> = {\n  // Diff operations root\n  diff: seq(\n    terminal('diff', {\n      targetDocument: { type: 'string', required: false },\n      timestamp: { type: 'string', required: false }\n    }),\n    oneOrMore('edit-operation')\n  ),\n\n  // Edit operations\n  'edit-operation': choice(\n    'edit-attr',\n    'edit-content',\n    'edit-params',\n    'edit-id',\n    'insert',\n    'delete',\n    'replace',\n    'move'\n  ),\n\n  'edit-attr': terminal('edit:attr', {\n    'block-id': { type: 'string', required: true },\n    name: { type: 'string', required: true },\n    value: { type: 'string', required: true }\n  }, 'none'),\n\n  'edit-content': seq(\n    terminal('edit:content', {\n      'block-id': { type: 'string', required: true }\n    }),\n    ref('rich-content')\n  ),\n\n  'edit-params': seq(\n    terminal('edit:params', {\n      'block-id': { type: 'string', required: true }\n    }),\n    ref('json-content')\n  ),\n\n  'edit-id': terminal('edit:id', {\n    'block-id': { type: 'string', required: true },\n    value: { type: 'string', required: true }\n  }, 'none'),\n\n  insert: seq(\n    terminal('insert', {\n      'after-block-id': { type: 'string', required: false },\n      'before-block-id': { type: 'string', required: false },\n      'at-start': { type: 'boolean', required: false },\n      'at-end': { type: 'boolean', required: false }\n    }),\n    oneOrMore('block')\n  ),\n\n  delete: terminal('delete', {\n    'block-id': { type: 'string', required: true }\n  }, 'none'),\n\n  replace: seq(\n    terminal('replace', {\n      'block-id': { type: 'string', required: true }\n    }),\n    oneOrMore('block')\n  ),\n\n  move: terminal('move', {\n    'block-id': { type: 'string', required: false },\n    'block-ids': { type: 'string', required: false },\n    'from-block-id': { type: 'string', required: false },\n    'to-block-id': { type: 'string', required: false },\n    'after-block-id': { type: 'string', required: false },\n    'before-block-id': { type: 'string', required: false },\n    'at-start': { type: 'boolean', required: false },\n    'at-end': { type: 'boolean', required: false }\n  }, 'none')\n};\n\n// Note: Diff grammar references 'rich-content', 'json-content', and 'block' \n// from document grammar. These will be resolved when grammars are combined","/**\n * Combined Grammar Index\n * \n * Exports all grammars and provides a unified grammar for parsing.\n */\n\nimport { Rule, choice } from './grammar-dsl';\nimport { DOCUMENT_GRAMMAR } from './document-grammar';\nimport { AGENT_GRAMMAR } from './agent-grammar';\nimport { DIFF_GRAMMAR } from './diff-grammar';\n\n// Combined grammar with all rules\nexport const GRAMMAR: Record<string, Rule> = {\n  // Root types\n  root: choice(\n    'document',\n    'agent', \n    'diff'\n  ),\n\n  // Merge all grammar rules\n  ...DOCUMENT_GRAMMAR,\n  ...AGENT_GRAMMAR,\n  ...DIFF_GRAMMAR\n};\n\n// Export individual grammars\nexport { DOCUMENT_GRAMMAR } from './document-grammar';\nexport { AGENT_GRAMMAR } from './agent-grammar';\nexport { DIFF_GRAMMAR } from './diff-grammar';\n\n// Export DSL\nexport * from './grammar-dsl';","/**\n * Grammar Compiler - Transforms grammar into usable structures\n * \n * This compiler takes our EBNF-style grammar and generates:\n * 1. Element-to-type mappings\n * 2. Validation functions\n * 3. AST type definitions\n * 4. Schema for backward compatibility\n */\n\nimport type { Rule, AttributeDef } from './grammar';\n\n// Define types locally since we removed schema.ts\nexport interface ElementSchema {\n  element: string;\n  type?: string;\n  block: boolean;\n  content?: 'text' | 'rich' | 'json' | 'none';\n  attributes?: Record<string, AttributeDef>;\n}\n\nexport interface ValidationError {\n  type: 'attribute' | 'content' | 'structure';\n  message: string;\n  path?: string;\n}\n\nexport interface CompiledGrammar {\n  // Element name -> AST type mapping\n  elementToType: Record<string, string>;\n  \n  // AST type -> element name(s) mapping\n  typeToElements: Record<string, string[]>;\n  \n  // Element name -> schema mapping (for compatibility)\n  elementSchemas: Record<string, ElementSchema>;\n  \n  // Validation functions\n  isValidElement: (element: string) => boolean;\n  isValidChild: (parentType: string, childElement: string) => boolean;\n  validateAttributes: (element: string, attrs: Record<string, unknown>) => ValidationError[];\n  \n  // Type information\n  blockTypes: Set<string>;\n  inlineElements: Set<string>;\n}\n\nexport class GrammarCompiler {\n  private grammar: Record<string, Rule>;\n  private compiled: CompiledGrammar | null = null;\n\n  constructor(grammar: Record<string, Rule>) {\n    this.grammar = grammar;\n  }\n\n  /**\n   * Compile the grammar into usable structures\n   */\n  compile(): CompiledGrammar {\n    if (this.compiled) return this.compiled;\n\n    const elementToType: Record<string, string> = {};\n    const typeToElements: Record<string, string[]> = {};\n    const elementSchemas: Record<string, ElementSchema> = {};\n    const blockTypes = new Set<string>();\n    const inlineElements = new Set<string>();\n\n    // First pass: collect all terminals and their types\n    const terminals = this.collectTerminals();\n    \n    // Build element mappings\n    for (const [ruleName, terminal] of terminals) {\n      const element = terminal.element;\n      if (element.startsWith('_')) continue; // Skip pseudo-elements\n\n      // Determine AST type\n      const astType = this.inferAstType(element, ruleName);\n      \n      // Element -> Type mapping\n      elementToType[element] = astType;\n      \n      // Type -> Elements mapping\n      if (!typeToElements[astType]) {\n        typeToElements[astType] = [];\n      }\n      typeToElements[astType].push(element);\n\n      // Build schema\n      elementSchemas[element] = {\n        element: element,\n        type: astType,\n        block: this.isBlockRule(ruleName),\n        attributes: terminal.attributes,\n        content: terminal.content as 'text' | 'rich' | 'json' | 'none' | undefined,\n      };\n\n      // Classify as block or inline\n      if (this.isBlockRule(ruleName)) {\n        blockTypes.add(astType);\n      } else if (this.isInlineRule(ruleName)) {\n        inlineElements.add(element);\n      }\n    }\n\n    // Build validation functions\n    const isValidElement = (element: string) => element in elementToType;\n    \n    const isValidChild = (parentType: string, childElement: string) => {\n      // Find rules that define valid children for this parent type\n      const rule = this.findRuleByType(parentType);\n      if (!rule) return false;\n      \n      return this.isValidInContext(rule, childElement);\n    };\n\n    const validateAttributes = (element: string, attrs: Record<string, unknown>) => {\n      const schema = elementSchemas[element];\n      if (!schema || !schema.attributes) return [];\n      \n      return this.validateAttrs(attrs, schema.attributes, element);\n    };\n\n    this.compiled = {\n      elementToType,\n      typeToElements,\n      elementSchemas,\n      isValidElement,\n      isValidChild,\n      validateAttributes,\n      blockTypes,\n      inlineElements,\n    };\n\n    return this.compiled;\n  }\n\n  /**\n   * Collect all terminal rules with their contexts\n   */\n  private collectTerminals(): Map<string, { element: string; attributes?: Record<string, AttributeDef>; content?: string }> {\n    const terminals = new Map();\n    const visited = new Set<string>();\n\n    const visit = (ruleName: string, rule: Rule) => {\n      // Avoid infinite recursion\n      const key = `${ruleName}:${JSON.stringify(rule)}`;\n      if (visited.has(key)) return;\n      visited.add(key);\n\n      switch (rule.type) {\n        case 'terminal':\n          terminals.set(ruleName, {\n            element: rule.element,\n            attributes: rule.attributes,\n            content: rule.content,\n          });\n          break;\n\n        case 'choice':\n        case 'sequence':\n          rule.rules.forEach((r, i) => {\n            if (r.type === 'ref') {\n              visit(r.name, this.grammar[r.name]);\n            } else {\n              visit(`${ruleName}[${i}]`, r);\n            }\n          });\n          break;\n\n        case 'repeat':\n        case 'optional':\n          if (rule.rule.type === 'ref') {\n            visit(rule.rule.name, this.grammar[rule.rule.name]);\n          } else {\n            visit(`${ruleName}:inner`, rule.rule);\n          }\n          break;\n\n        case 'ref':\n          if (this.grammar[rule.name]) {\n            visit(rule.name, this.grammar[rule.name]);\n          }\n          break;\n      }\n    };\n\n    // Start from all top-level rules\n    for (const [name, rule] of Object.entries(this.grammar)) {\n      visit(name, rule);\n    }\n\n    return terminals;\n  }\n\n  /**\n   * Infer AST type from element name and rule context\n   */\n  private inferAstType(element: string, ruleName: string): string {\n    // Special cases\n    const typeMap: Record<string, string> = {\n      'p': 'paragraph',\n      'paragraph': 'paragraph',\n      'h1': 'heading',\n      'h2': 'heading',\n      'h3': 'heading',\n      'h4': 'heading',\n      'h5': 'heading',\n      'h6': 'heading',\n      'heading': 'heading',\n      'fncall': 'function_call',\n      'bulletlistitem': 'bulletListItem',\n      'numberedlistitem': 'numberedListItem',\n      'checklistitem': 'checklistItem',\n      'tool:description': '_tool_description',\n      'tool:definition': '_tool_definition',\n    };\n\n    return typeMap[element] || element.replace(/[:-]/g, '_');\n  }\n\n  /**\n   * Check if a rule represents a block element\n   */\n  private isBlockRule(ruleName: string): boolean {\n    // Check if this rule is referenced by block-level rules\n    return ruleName.includes('block') || \n           ruleName === 'paragraph' ||\n           ruleName === 'heading' ||\n           ruleName === 'list' ||\n           ruleName === 'code' ||\n           ruleName === 'quote' ||\n           ruleName === 'separator' ||\n           ruleName === 'tool-block';\n  }\n\n  /**\n   * Check if a rule represents an inline element\n   */\n  private isInlineRule(ruleName: string): boolean {\n    return ruleName.includes('styled-text') ||\n           ruleName === 'mention' ||\n           ruleName === 'variable' ||\n           ruleName === 'link' ||\n           ruleName === 'text';\n  }\n\n  /**\n   * Find a rule that produces the given AST type\n   */\n  private findRuleByType(astType: string): Rule | null {\n    // This is a simplified version - in practice we'd need a more\n    // sophisticated mapping from AST types back to grammar rules\n    const ruleMap: Record<string, string> = {\n      'tool': 'tool-block',\n      'list': 'list',\n      'function_call': 'function-call',\n      'trigger': 'trigger',\n    };\n\n    const ruleName = ruleMap[astType];\n    return ruleName ? this.grammar[ruleName] : null;\n  }\n\n  /**\n   * Check if an element is valid in a given context\n   */\n  private isValidInContext(rule: Rule, element: string): boolean {\n    switch (rule.type) {\n      case 'terminal':\n        return rule.element === element;\n\n      case 'choice':\n        return rule.rules.some(r => this.isValidInContext(r, element));\n\n      case 'sequence':\n        // Check all parts of sequence\n        return rule.rules.some(r => this.isValidInContext(r, element));\n\n      case 'repeat':\n      case 'optional':\n        return this.isValidInContext(rule.rule, element);\n\n      case 'ref':\n        const referenced = this.grammar[rule.name];\n        return referenced ? this.isValidInContext(referenced, element) : false;\n\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Validate attributes against schema\n   */\n  private validateAttrs(\n    attrs: Record<string, unknown>,\n    schema: Record<string, AttributeDef>,\n    element: string\n  ): ValidationError[] {\n    const errors: ValidationError[] = [];\n\n    // Check required attributes\n    for (const [name, def] of Object.entries(schema)) {\n      if (def.required && !(name in attrs)) {\n        errors.push({\n          type: 'attribute',\n          path: `${element}@${name}`,\n          message: `Required attribute missing: ${name}`,\n        });\n      }\n    }\n\n    // Validate present attributes\n    for (const [name, value] of Object.entries(attrs)) {\n      const def = schema[name];\n      if (!def) continue; // Unknown attributes allowed\n\n      // Type validation\n      if (def.type === 'enum' && def.values && !def.values.includes(value as string)) {\n        errors.push({\n          type: 'attribute',\n          path: `${element}@${name}`,\n          message: `Invalid value: must be one of ${def.values.join(', ')}`,\n        });\n      }\n\n      // Pattern validation\n      if (def.pattern && typeof value === 'string' && !def.pattern.test(value)) {\n        errors.push({\n          type: 'attribute',\n          path: `${element}@${name}`,\n          message: `Invalid format for ${name}`,\n        });\n      }\n\n      // Custom validation\n      if (def.validate) {\n        const error = def.validate(value);\n        if (error) {\n          errors.push({\n            type: 'attribute',\n            path: `${element}@${name}`,\n            message: error,\n          });\n        }\n      }\n    }\n\n    return errors;\n  }\n\n  /**\n   * Generate TypeScript AST types from grammar\n   */\n  generateTypes(): string {\n    const compiled = this.compile();\n    const types: string[] = [];\n\n    // Generate block type union\n    const blockTypeNames = Array.from(compiled.blockTypes)\n      .map(t => `'${t}'`)\n      .join(' | ');\n    types.push(`export type BlockType = ${blockTypeNames};`);\n\n    // Generate element mappings\n    types.push('\\nexport const ELEMENT_TO_TYPE = {');\n    for (const [element, type] of Object.entries(compiled.elementToType)) {\n      types.push(`  '${element}': '${type}',`);\n    }\n    types.push('} as const;');\n\n    return types.join('\\n');\n  }\n}","/**\n * Document Executor for Idyllic Engine\n * \n * Handles execution of executable nodes within documents,\n * maintaining execution state and providing context to tools.\n */\n\nimport { z } from 'zod';\nimport type { \n  IdyllDocument, \n  Node, \n  ExecutableNode, \n  RichContent \n} from './ast';\nimport type {\n  ExecutionState,\n  ExecutionReport,\n  ExecutionOptions,\n  NodeExecutionResult,\n  BlockExecutionResult,\n  NodeExecutionContext,\n  BlockExecutionContext,\n  NodeExecutionError,\n  BlockExecutionError,\n  ExecutionMetadata,\n  ExecutionRequest,\n} from './execution-types';\n\nexport class DocumentExecutor<TApi = any> {\n  private options: ExecutionOptions<TApi>;\n  \n  constructor(options: ExecutionOptions<TApi>) {\n    this.options = {\n      stopOnError: false,\n      timeout: 30000,\n      ...options,\n    };\n  }\n  \n  /**\n   * Execute a single node or entire document\n   */\n  async execute(request: ExecutionRequest): Promise<ExecutionReport> {\n    if (request.mode === 'single') {\n      return this.executeSingleNode(request.document, (request as any).nodeId || (request as any).blockId!);\n    } else {\n      return this.executeDocument(request.document);\n    }\n  }\n  \n  /**\n   * Execute all executable nodes in a document\n   */\n  async executeDocument(document: IdyllDocument): Promise<ExecutionReport> {\n    const startTime = new Date();\n    const state: ExecutionState = new Map();\n    \n    // Find all executable nodes\n    const executableNodes = this.findExecutableNodes(document.nodes || (document as any).blocks);\n    const total = executableNodes.length;\n    \n    // Execute nodes sequentially\n    for (let i = 0; i < executableNodes.length; i++) {\n      const node = executableNodes[i];\n      \n      // Progress callback\n      this.options.onProgress?.(node.id, i + 1, total);\n      \n      // Create context for this node\n      const context: NodeExecutionContext & { api?: TApi } = {\n        currentNodeId: node.id,\n        previousResults: new Map(state), // Copy current state\n        document,\n        api: this.options.api,\n      };\n      \n      // Execute the node\n      const result = await this.executeNode(node, context);\n      state.set(node.id, result);\n      \n      // Stop on error if requested\n      if (!result.success && this.options.stopOnError) {\n        break;\n      }\n    }\n    \n    const endTime = new Date();\n    \n    // Calculate metadata\n    const metadata: ExecutionMetadata = {\n      startTime,\n      endTime,\n      totalDuration: endTime.getTime() - startTime.getTime(),\n      nodesExecuted: state.size,\n      nodesSucceeded: Array.from(state.values()).filter(r => r.success).length,\n      nodesFailed: Array.from(state.values()).filter(r => !r.success).length,\n    };\n    \n    return { nodes: state, metadata };\n  }\n  \n  /**\n   * Execute a single node by ID\n   */\n  async executeSingleNode(\n    document: IdyllDocument, \n    nodeId: string\n  ): Promise<ExecutionReport> {\n    const startTime = new Date();\n    const state: ExecutionState = new Map();\n    \n    // Find the node\n    const node = this.findNodeById(document.nodes || (document as any).blocks, nodeId);\n    if (!node) {\n      throw new Error(`Node with ID ${nodeId} not found`);\n    }\n    \n    if (!this.isExecutableNode(node)) {\n      throw new Error(`Node ${nodeId} is not executable`);\n    }\n    \n    // Build context with previous results (all nodes before this one)\n    const previousResults = this.getPreviousResults(document, nodeId);\n    \n    const context: NodeExecutionContext & { api?: TApi } = {\n      currentNodeId: nodeId,\n      previousResults,\n      document,\n      api: this.options.api,\n    };\n    \n    // Execute the node\n    const result = await this.executeNode(node as ExecutableNode, context);\n    state.set(nodeId, result);\n    \n    const endTime = new Date();\n    \n    const metadata: ExecutionMetadata = {\n      startTime,\n      endTime,\n      totalDuration: endTime.getTime() - startTime.getTime(),\n      nodesExecuted: 1,\n      nodesSucceeded: result.success ? 1 : 0,\n      nodesFailed: result.success ? 0 : 1,\n    };\n    \n    return { nodes: state, metadata };\n  }\n  \n  /**\n   * Execute a single executable node\n   */\n  private async executeNode(\n    node: ExecutableNode,\n    context: NodeExecutionContext & { api?: TApi }\n  ): Promise<NodeExecutionResult> {\n    const startTime = Date.now();\n    \n    try {\n      // Resolve the tool\n      const tool = this.options.tools[node.tool];\n      if (!tool) {\n        throw new Error(`Tool not found: ${node.tool}`);\n      }\n      \n      // Validate parameters\n      let validatedParams: any;\n      try {\n        validatedParams = tool.schema.parse(node.parameters);\n      } catch (error) {\n        if (error instanceof z.ZodError) {\n          throw new Error(`Invalid parameters: ${error.errors.map(e => e.message).join(', ')}`);\n        }\n        throw error;\n      }\n      \n      // Extract content as string\n      const content = this.extractContent(node.content);\n      \n      // Execute with timeout\n      const timeoutPromise = new Promise((_, reject) => {\n        setTimeout(() => reject(new Error('Execution timeout')), this.options.timeout);\n      });\n      \n      const data = await Promise.race([\n        tool.execute(validatedParams, content, context),\n        timeoutPromise,\n      ]);\n      \n      return {\n        success: true,\n        data,\n        duration: Date.now() - startTime,\n        timestamp: new Date(),\n      };\n      \n    } catch (error) {\n      const errorObj: NodeExecutionError = {\n        message: error instanceof Error ? error.message : String(error),\n        code: 'EXECUTION_ERROR',\n        details: error,\n      };\n      \n      return {\n        success: false,\n        error: errorObj,\n        duration: Date.now() - startTime,\n        timestamp: new Date(),\n      };\n    }\n  }\n  \n  /**\n   * Find all executable nodes in document\n   */\n  private findExecutableNodes(nodes: Node[]): ExecutableNode[] {\n    const executable: ExecutableNode[] = [];\n    \n    for (const node of nodes) {\n      if (this.isExecutableNode(node)) {\n        executable.push(node as ExecutableNode);\n      }\n      \n      // Check children recursively\n      if ('children' in node && node.children) {\n        executable.push(...this.findExecutableNodes(node.children));\n      }\n    }\n    \n    return executable;\n  }\n  \n  /**\n   * Find a node by ID\n   */\n  private findNodeById(nodes: Node[], id: string): Node | null {\n    for (const node of nodes) {\n      if (node.id === id) {\n        return node;\n      }\n      \n      // Check children\n      if ('children' in node && node.children) {\n        const found = this.findNodeById(node.children, id);\n        if (found) return found;\n      }\n    }\n    \n    return null;\n  }\n  \n  /**\n   * Get results from all nodes before the given node\n   */\n  private getPreviousResults(document: IdyllDocument, beforeNodeId: string): ExecutionState {\n    const results: ExecutionState = new Map();\n    const executableNodes = this.findExecutableNodes(document.nodes || (document as any).blocks);\n    \n    // Find all nodes before the target node\n    for (const node of executableNodes) {\n      if (node.id === beforeNodeId) {\n        break;\n      }\n      // Note: We don't have actual results in this case, \n      // this would be populated from prior execution\n      // For now, return empty state\n    }\n    \n    return results;\n  }\n  \n  /**\n   * Check if a node is executable\n   */\n  private isExecutableNode(node: Node): boolean {\n    return node.type === 'function_call' || node.type === 'trigger';\n  }\n  \n  /**\n   * Extract text content from rich content\n   */\n  private extractContent(content?: RichContent[]): string {\n    if (!content) return '';\n    \n    return content\n      .map(item => {\n        if ('text' in item) {\n          return item.text;\n        }\n        return '';\n      })\n      .join('');\n  }\n}","/**\n * Tool Registry for Idyllic Engine\n * \n * Provides utilities for managing and creating tool registries\n * with proper type safety and validation.\n */\n\nimport { z } from 'zod';\nimport type { ToolRegistry, ToolDefinition, BlockExecutionContext } from './execution-types';\n\n// Re-export types for external use\nexport type { ToolRegistry, ToolDefinition } from './execution-types';\n\n/**\n * Create a type-safe tool registry\n */\nexport function createToolRegistry<TApi = any>(\n  tools: ToolRegistry<TApi>\n): ToolRegistry<TApi> {\n  return tools;\n}\n\n/**\n * Define a single tool with type inference\n */\nexport function defineTool<TParams = any, TApi = any>(\n  definition: {\n    schema: z.ZodSchema<TParams>;\n    execute: (params: TParams, content: string, context: BlockExecutionContext & { api?: TApi }) => Promise<any> | any;\n    description?: string;\n  }\n): ToolDefinition<TParams, TApi> {\n  return definition;\n}\n\n/**\n * Merge multiple tool registries\n */\nexport function mergeToolRegistries<TApi = any>(\n  ...registries: ToolRegistry<TApi>[]\n): ToolRegistry<TApi> {\n  return registries.reduce((merged, registry) => {\n    return { ...merged, ...registry };\n  }, {} as ToolRegistry<TApi>);\n}\n\n/**\n * Create a tool registry from a simple function map\n * (for quick testing without schemas)\n */\nexport function createSimpleRegistry<TApi = any>(\n  tools: Record<string, (params: any, content: string, context?: BlockExecutionContext & { api?: TApi }) => any>\n): ToolRegistry<TApi> {\n  const registry: ToolRegistry<TApi> = {};\n  \n  for (const [name, fn] of Object.entries(tools)) {\n    registry[name] = {\n      schema: z.any(), // Accept any params\n      execute: (params, content, context) => fn(params, content, context),\n    };\n  }\n  \n  return registry;\n}","/**\n * Tool naming utilities for Idyll Engine\n * \n * Handles transformation between Idyll tool names (module:function) \n * and external platform requirements.\n */\n\n/**\n * Transform Idyll tool name to Azure function name\n * \"module:function\"  \"module--function\"\n * \"function\"  \"function\" (no module)\n */\nexport function toAzureFunctionName(idyllToolName: string): string {\n  return idyllToolName.replace(':', '--');\n}\n\n/**\n * Transform Azure function name back to Idyll tool name\n * \"module--function\"  \"module:function\"\n * \"function\"  \"function\" (no module)\n */\nexport function fromAzureFunctionName(azureFunctionName: string): string {\n  // Double hyphen is our separator\n  if (azureFunctionName.includes('--')) {\n    return azureFunctionName.replace('--', ':');\n  }\n  // No separator means no module namespace\n  return azureFunctionName;\n}\n\n/**\n * Validate that a tool name follows Idyll conventions\n * Must be valid JS identifiers: [module:]function\n */\nexport function validateToolName(toolName: string): { valid: boolean; error?: string } {\n  const pattern = /^([a-zA-Z_$][a-zA-Z0-9_$]*:)?[a-zA-Z_$][a-zA-Z0-9_$]*$/;\n  \n  if (!pattern.test(toolName)) {\n    return {\n      valid: false,\n      error: 'Tool name must be valid JS identifiers in format \"module:function\" or \"function\"'\n    };\n  }\n  \n  return { valid: true };\n}\n\n/**\n * Parse a tool name into module and function parts\n */\nexport function parseToolName(toolName: string): { module?: string; function: string } {\n  const colonIndex = toolName.indexOf(':');\n  \n  if (colonIndex === -1) {\n    return { function: toolName };\n  }\n  \n  return {\n    module: toolName.substring(0, colonIndex),\n    function: toolName.substring(colonIndex + 1)\n  };\n}\n\n/**\n * Build a tool name from module and function parts\n */\nexport function buildToolName(module: string | undefined, functionName: string): string {\n  return module ? `${module}:${functionName}` : functionName;\n}","/**\n * Document validation logic\n */\n\nimport {\n  Node,\n  IdyllDocument,\n  isExecutableNode,\n  extractMentions,\n  extractVariables,\n  traverseNodes,\n} from './ast';\nimport { ValidationContext, ValidationError } from '../types';\n\n// ============================================\n// Validation Types\n// ============================================\n\nexport interface ValidationResult {\n  valid: boolean;\n  errors: ValidationIssue[];\n  warnings: ValidationIssue[];\n}\n\nexport interface ValidationIssue {\n  type: 'error' | 'warning';\n  code: string;\n  message: string;\n  nodeId?: string;\n  path?: string[];\n}\n\n// ============================================\n// Main Validation Function\n// ============================================\n\n/**\n * Validate a document structure and optionally its references\n */\nexport async function validateDocument(\n  document: IdyllDocument,\n  context?: ValidationContext\n): Promise<ValidationResult> {\n  const errors: ValidationIssue[] = [];\n  const warnings: ValidationIssue[] = [];\n  \n  // Phase 1: Structure validation\n  validateStructure(document, errors, warnings);\n  \n  // Phase 2: Reference validation (if context provided)\n  if (context) {\n    await validateReferences(document, context, errors, warnings);\n  }\n  \n  return {\n    valid: errors.length === 0,\n    errors,\n    warnings,\n  };\n}\n\n// ============================================\n// Structure Validation\n// ============================================\n\n/**\n * Validate document structure\n */\nfunction validateStructure(\n  document: IdyllDocument,\n  errors: ValidationIssue[],\n  warnings: ValidationIssue[]\n): void {\n  // Validate document has an ID\n  if (!document.id) {\n    errors.push({\n      type: 'error',\n      code: 'MISSING_DOCUMENT_ID',\n      message: 'Document must have an ID',\n    });\n  }\n  \n  // Validate document has nodes\n  if (!document.nodes || document.nodes.length === 0) {\n    warnings.push({\n      type: 'warning',\n      code: 'EMPTY_DOCUMENT',\n      message: 'Document has no content nodes',\n    });\n  }\n  \n  // Validate each node\n  const nodeIds = new Set<string>();\n  for (const node of traverseNodes(document.nodes)) {\n    validateNode(node, nodeIds, errors, warnings);\n  }\n}\n\n/**\n * Validate a single node\n */\nfunction validateNode(\n  node: Node,\n  nodeIds: Set<string>,\n  errors: ValidationIssue[],\n  warnings: ValidationIssue[]\n): void {\n  const nodeId = node.id || 'unknown';\n  \n  // Check for duplicate IDs\n  if (node.id && nodeIds.has(node.id)) {\n    errors.push({\n      type: 'error',\n      code: 'DUPLICATE_NODE_ID',\n      message: `Duplicate node ID: ${node.id}`,\n      nodeId: node.id,\n    });\n  }\n  if (node.id) {\n    nodeIds.add(node.id);\n  }\n  \n  // Validate node has required fields\n  if (!node.id) {\n    errors.push({\n      type: 'error',\n      code: 'MISSING_NODE_ID',\n      message: 'Node must have an ID',\n    });\n  }\n  \n  if (!node.type) {\n    errors.push({\n      type: 'error',\n      code: 'MISSING_NODE_TYPE',\n      message: 'Node must have a type',\n      nodeId,\n    });\n    return; // Can't validate further without type\n  }\n  \n  // Validate executable nodes\n  if (isExecutableNode(node)) {\n    if (!node.tool) {\n      errors.push({\n        type: 'error',\n        code: 'MISSING_TOOL',\n        message: 'Executable node must specify a tool',\n        nodeId,\n      });\n    }\n    \n    if (!node.parameters) {\n      warnings.push({\n        type: 'warning',\n        code: 'MISSING_PARAMETERS',\n        message: 'Executable node has no parameters',\n        nodeId,\n      });\n    }\n  }\n}\n\n// ============================================\n// Reference Validation\n// ============================================\n\n/**\n * Validate document references (mentions, variables, tools)\n */\nasync function validateReferences(\n  document: IdyllDocument,\n  context: ValidationContext,\n  errors: ValidationIssue[],\n  warnings: ValidationIssue[]\n): Promise<void> {\n  // Validate mentions\n  if (context.validateMention) {\n    const mentions = extractMentions(document.nodes);\n    for (const mention of mentions) {\n      if (!context.validateMention(mention)) {\n        errors.push({\n          type: 'error',\n          code: 'INVALID_MENTION',\n          message: `Invalid ${mention.mentionType} mention: ${mention.id}`,\n        });\n      }\n    }\n  }\n  \n  // Validate variables\n  if (context.validateVariable) {\n    const variables = extractVariables(document.nodes);\n    for (const variable of variables) {\n      const result = context.validateVariable(variable);\n      if (!result.valid) {\n        errors.push({\n          type: 'error',\n          code: 'INVALID_VARIABLE',\n          message: `Invalid variable: ${variable.name}`,\n        });\n      }\n    }\n  }\n  \n  // Validate tools\n  if (context.validateTool) {\n    for (const node of traverseNodes(document.nodes)) {\n      if (isExecutableNode(node) && node.tool) {\n        if (!context.validateTool(node.tool)) {\n          errors.push({\n            type: 'error',\n            code: 'INVALID_TOOL',\n            message: `Tool not found: ${node.tool}`,\n            nodeId: node.id || 'unknown',\n          });\n        }\n      }\n    }\n  }\n}\n\n// ============================================\n// Validation Utilities\n// ============================================\n\n/**\n * Create a validation error from issues\n */\nexport function createValidationError(result: ValidationResult): ValidationError {\n  const errorMessages = result.errors.map(e => e.message);\n  return new ValidationError(\n    `Document validation failed with ${result.errors.length} error(s)`,\n    errorMessages,\n    { issues: result.errors }\n  );\n}\n\n/**\n * Format validation issues for display\n */\nexport function formatValidationIssues(issues: ValidationIssue[]): string {\n  return issues\n    .map(issue => {\n      const prefix = issue.type === 'error' ? '' : '';\n      const location = issue.nodeId ? ` (node: ${issue.nodeId})` : '';\n      return `${prefix} ${issue.message}${location}`;\n    })\n    .join('\\n');\n}","/**\n * Variable Resolution System for Idyllic Engine\n * \n * Handles the resolution of variables in custom tools using AI interpolation\n */\n\nimport type { Node, RichContent, VariableElement } from './ast';\nimport { isVariable, traverseNodes } from './ast';\n\n/**\n * Variable with metadata for resolution\n */\nexport interface VariableDefinition {\n  name: string;\n  prompt?: string;\n  firstOccurrenceBlockId: string;\n  firstOccurrenceIndex: number;\n}\n\n/**\n * Context for variable resolution\n */\nexport interface VariableResolutionContext {\n  /** Agent-provided context (rich content) */\n  agentContext: string;\n  \n  /** Document context (surrounding blocks) */\n  documentContext?: string;\n  \n  /** Inherited agent context/personality */\n  inheritedContext?: Record<string, unknown>;\n}\n\n/**\n * Variable resolution result\n */\nexport interface VariableResolutionResult {\n  /** Resolved variable values */\n  variables: Map<string, string>;\n  \n  /** Any errors during resolution */\n  errors?: Array<{ variable: string; error: string }>;\n}\n\n/**\n * Extract all unique variables from blocks\n * Follows declare-once, use-many pattern\n */\nexport function extractVariableDefinitions(nodes: Node[]): VariableDefinition[] {\n  const definitions = new Map<string, VariableDefinition>();\n  const seenNames = new Set<string>();\n  \n  let globalIndex = 0;\n  \n  for (const node of traverseNodes(nodes)) {\n    if ('content' in node && Array.isArray(node.content)) {\n      processContent(node.content, node.id);\n    }\n    \n    // Check executable node content\n    if ('content' in node && node.content) {\n      processContent(node.content, node.id);\n    }\n  }\n  \n  function processContent(content: RichContent[], blockId: string) {\n    for (const item of content) {\n      if (isVariable(item)) {\n        // First occurrence declares the variable\n        if (!seenNames.has(item.name)) {\n          seenNames.add(item.name);\n          definitions.set(item.name, {\n            name: item.name,\n            prompt: item.prompt,\n            firstOccurrenceBlockId: blockId,\n            firstOccurrenceIndex: globalIndex++,\n          });\n        }\n      } else if ('content' in item && Array.isArray(item.content)) {\n        // Recurse into nested content\n        processContent(item.content, blockId);\n      }\n    }\n  }\n  \n  return Array.from(definitions.values());\n}\n\n/**\n * Check for variable redeclaration errors\n */\nexport function checkVariableRedeclaration(nodes: Node[]): Array<{ name: string; error: string }> {\n  const errors: Array<{ name: string; error: string }> = [];\n  const declarations = new Map<string, { nodeId: string; prompt?: string }>();\n  \n  for (const node of traverseNodes(nodes)) {\n    const variables = extractVariablesFromNode(node);\n    \n    for (const variable of variables) {\n      const existing = declarations.get(variable.name);\n      \n      if (existing) {\n        // Check if it's a redeclaration (different prompt)\n        if (variable.prompt && existing.prompt !== variable.prompt) {\n          errors.push({\n            name: variable.name,\n            error: `Variable \"${variable.name}\" redeclared with different prompt. Original: \"${existing.prompt}\", New: \"${variable.prompt}\"`,\n          });\n        }\n      } else if (variable.prompt) {\n        // First declaration with prompt\n        declarations.set(variable.name, {\n          nodeId: node.id,\n          prompt: variable.prompt,\n        });\n      }\n    }\n  }\n  \n  return errors;\n}\n\n/**\n * Extract variables from a single block\n */\nfunction extractVariablesFromNode(node: Node): VariableElement[] {\n  const variables: VariableElement[] = [];\n  \n  function extractFromContent(content: RichContent[]) {\n    for (const item of content) {\n      if (isVariable(item)) {\n        variables.push(item);\n      } else if ('content' in item && Array.isArray(item.content)) {\n        extractFromContent(item.content);\n      }\n    }\n  }\n  \n  if ('content' in node && Array.isArray(node.content)) {\n    extractFromContent(node.content);\n  }\n  \n  if ('content' in node && node.content) {\n    extractFromContent(node.content);\n  }\n  \n  return variables;\n}\n\n/**\n * Resolve variables using AI interpolation or fallback to mock\n */\nexport async function resolveVariables(\n  definitions: VariableDefinition[],\n  context: VariableResolutionContext\n): Promise<VariableResolutionResult> {\n  // Use mock resolution (AI resolution removed - model should be provided externally if needed)\n  const variables = new Map<string, string>();\n  const errors: Array<{ variable: string; error: string }> = [];\n  \n  for (const def of definitions) {\n    try {\n      const resolvedValue = await mockResolveVariable(def, context);\n      variables.set(def.name, resolvedValue);\n    } catch (error) {\n      errors.push({\n        variable: def.name,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      });\n    }\n  }\n  \n  return { variables, errors: errors.length > 0 ? errors : undefined };\n}\n\n/**\n * Mock variable resolution for testing\n * Replace with actual AI implementation\n */\nasync function mockResolveVariable(\n  definition: VariableDefinition,\n  context: VariableResolutionContext\n): Promise<string> {\n  // Simulate AI resolution based on variable name and context\n  const contextLower = context.agentContext.toLowerCase();\n  \n  switch (definition.name) {\n    case 'searchQuery':\n      if (contextLower.includes('ai breakthroughs')) {\n        return 'AI breakthroughs 2024';\n      }\n      if (contextLower.includes('machine learning')) {\n        return 'machine learning advances';\n      }\n      return 'technology news';\n      \n    case 'timeframe':\n      if (contextLower.includes('past month') || contextLower.includes('last month')) {\n        return 'past month';\n      }\n      if (contextLower.includes('past week') || contextLower.includes('last week')) {\n        return 'past week';\n      }\n      return 'recent';\n      \n    case 'focusArea':\n      if (contextLower.includes('practical')) {\n        return 'practical applications';\n      }\n      if (contextLower.includes('research')) {\n        return 'research developments';\n      }\n      return 'general overview';\n      \n    default:\n      // Use prompt as hint for resolution\n      if (definition.prompt) {\n        return `Resolved: ${definition.name} (${definition.prompt})`;\n      }\n      return `Resolved: ${definition.name}`;\n  }\n}\n\n/**\n * Apply resolved variable values to nodes\n * Updates variable elements with resolvedValue\n */\nexport function applyResolvedVariables(\n  nodes: Node[],\n  resolvedVariables: Map<string, string>\n): Node[] {\n  // Deep clone nodes to avoid mutation\n  const clonedNodes = JSON.parse(JSON.stringify(nodes)) as Node[];\n  \n  for (const node of traverseNodes(clonedNodes)) {\n    if ('content' in node && Array.isArray(node.content)) {\n      node.content = applyToContent(node.content);\n    }\n    \n    if ('content' in node && node.content) {\n      node.content = applyToContent(node.content);\n    }\n  }\n  \n  function applyToContent(content: RichContent[]): RichContent[] {\n    return content.map(item => {\n      if (isVariable(item)) {\n        const resolvedValue = resolvedVariables.get(item.name);\n        if (resolvedValue !== undefined) {\n          return {\n            ...item,\n            resolvedValue,\n          } as VariableElement;\n        }\n      } else if ('content' in item && Array.isArray(item.content)) {\n        return {\n          ...item,\n          content: applyToContent(item.content),\n        };\n      }\n      return item;\n    });\n  }\n  \n  return clonedNodes;\n}\n\n/**\n * Get interpolated text content with variables replaced\n */\nexport function interpolateContent(\n  content: RichContent[],\n  resolvedVariables: Map<string, string>\n): string {\n  let result = '';\n  \n  for (const item of content) {\n    if (item.type === 'text') {\n      result += item.text;\n    } else if (isVariable(item)) {\n      const value = resolvedVariables.get(item.name);\n      result += value || `{{${item.name}}}`;\n    } else if ('content' in item && Array.isArray(item.content)) {\n      result += interpolateContent(item.content, resolvedVariables);\n    }\n  }\n  \n  return result;\n}","/**\n * Custom Tool Executor for Idyllic Engine\n * \n * Executes custom tools defined with <tool> blocks, handling\n * variable resolution and multi-step execution\n */\n\nimport type { \n  Node,\n  ContentNode,\n  ExecutableNode,\n  IdyllDocument \n} from './ast';\nimport { isExecutableNode, getExecutableNodes } from './ast';\nimport type { \n  ToolExecutionReport, \n  ExecutionOptions,\n  NodeExecutionResult,\n  BlockExecutionResult \n} from './execution-types';\nimport { DocumentExecutor } from './executor';\nimport {\n  extractVariableDefinitions,\n  checkVariableRedeclaration,\n  resolveVariables,\n  applyResolvedVariables,\n  interpolateContent,\n  type VariableResolutionContext,\n} from './variable-resolution';\n\n/**\n * Options for custom tool execution\n */\nexport interface CustomToolExecutionOptions<TApi = any> extends ExecutionOptions<TApi> {\n  /** Agent context provided when invoking the tool */\n  agentContext: string;\n  \n  /** Inherited context from agent */\n  inheritedContext?: Record<string, unknown>;\n}\n\n/**\n * Execute a custom tool defined as a ContentNode\n */\nexport async function executeCustomTool<TApi = any>(\n  toolNode: ContentNode,\n  options: CustomToolExecutionOptions<TApi>\n): Promise<ToolExecutionReport> {\n  const startTime = Date.now();\n  \n  // Validate it's a tool node\n  if (toolNode.type !== 'tool') {\n    throw new Error('Node is not a tool');\n  }\n  \n  const toolName = (toolNode.props?.title as string) || 'Unnamed Tool';\n  \n  // Get tool definition nodes (children)\n  const definitionNodes = toolNode.children || [];\n  \n  // Check for variable redeclaration errors\n  const redeclarationErrors = checkVariableRedeclaration(definitionNodes);\n  if (redeclarationErrors.length > 0) {\n    throw new Error(\n      `Variable redeclaration errors: ${redeclarationErrors.map(e => e.error).join('; ')}`\n    );\n  }\n  \n  // Extract variable definitions\n  const variableDefinitions = extractVariableDefinitions(definitionNodes);\n  \n  // Resolve variables\n  const resolutionContext: VariableResolutionContext = {\n    agentContext: options.agentContext,\n    inheritedContext: options.inheritedContext,\n  };\n  \n  const resolutionResult = await resolveVariables(variableDefinitions, resolutionContext);\n  \n  if (resolutionResult.errors) {\n    console.warn('Variable resolution errors:', resolutionResult.errors);\n  }\n  \n  // Apply resolved variables to nodes\n  const nodesWithVariables = applyResolvedVariables(\n    definitionNodes,\n    resolutionResult.variables\n  );\n  \n  // Interpolate content in executable nodes\n  const interpolatedNodes = interpolateExecutableNodes(\n    nodesWithVariables,\n    resolutionResult.variables\n  );\n  \n  // Create a document for execution\n  const executionDocument: IdyllDocument = {\n    id: `tool-exec-${Date.now()}`,\n    nodes: interpolatedNodes,\n  };\n  \n  // Execute using DocumentExecutor\n  const executor = new DocumentExecutor(options);\n  const report = await executor.execute({\n    mode: 'document',\n    document: executionDocument,\n    options,\n  });\n  \n  // Build execution context\n  const executionContext: ToolExecutionReport = {\n    variables: resolutionResult.variables,\n    nodes: report.nodes,\n    metadata: {\n      toolName,\n      duration: Date.now() - startTime,\n      nodesExecuted: report.metadata.nodesExecuted,\n      nodesSucceeded: report.metadata.nodesSucceeded,\n      nodesFailed: report.metadata.nodesFailed,\n    },\n    toolDefinition: toolNode,\n  };\n  \n  return executionContext;\n}\n\n/**\n * Interpolate variables in executable node content\n */\nfunction interpolateExecutableNodes(\n  nodes: Node[],\n  resolvedVariables: Map<string, string>\n): Node[] {\n  return nodes.map(node => {\n    if (isExecutableNode(node) && node.content) {\n      // Interpolate the content to create the content string\n      const interpolatedContent = interpolateContent(\n        node.content,\n        resolvedVariables\n      );\n      \n      // Return a modified node with interpolated content\n      // Note: We're modifying the content to be a simple text content\n      // In a real implementation, we might want to preserve the structure\n      return {\n        ...node,\n        content: [{\n          type: 'text',\n          text: interpolatedContent,\n        }],\n      } as ExecutableNode;\n    }\n    \n    // Recursively handle children\n    if ('children' in node && node.children) {\n      return {\n        ...node,\n        children: interpolateExecutableNodes(node.children, resolvedVariables),\n      };\n    }\n    \n    return node;\n  });\n}\n\n/**\n * Extract relevant result from tool execution context\n * This would be used by the subprocess to return only what's needed\n */\nexport function extractRelevantResult(\n  context: ToolExecutionReport,\n  extractionHint?: string\n): unknown {\n  // Get the last successful result by default\n  const results = Array.from(context.nodes.values());\n  const lastSuccess = results\n    .reverse()\n    .find(r => r.success);\n  \n  if (lastSuccess) {\n    return lastSuccess.data;\n  }\n  \n  // If no successful results, return error summary\n  const errors = results\n    .filter(r => !r.success)\n    .map(r => r.error?.message || 'Unknown error');\n  \n  return {\n    success: false,\n    errors,\n    toolName: context.metadata.toolName,\n  };\n}\n\n/**\n * Parse custom tool from document\n */\nexport function parseCustomTool(document: IdyllDocument): ContentNode | null {\n  for (const node of document.nodes) {\n    if ('type' in node && node.type === 'tool') {\n      return node as ContentNode;\n    }\n  }\n  return null;\n}","/**\n * Diff Application Logic for Idyll Documents\n * \n * Applies edit operations to document nodes with proper error handling.\n */\n\nimport { \n  Node, \n  RichContent,\n  EditOperation, \n  EditAttrOperation,\n  EditContentOperation,\n  EditParamsOperation,\n  EditIdOperation,\n  InsertOperation,\n  DeleteOperation,\n  ReplaceOperation,\n  MoveOperation\n} from './ast';\nimport { v4 as uuidv4 } from 'uuid';\n\nexport interface DiffResult {\n  success: boolean;\n  nodes?: Node[];\n  error?: string;\n}\n\n/**\n * Apply a list of edit operations to document nodes\n */\nexport function applyDiff(nodes: Node[], operations: EditOperation[]): DiffResult {\n  try {\n    let result = [...nodes];\n\n    for (const operation of operations) {\n      switch (operation.type) {\n        case 'edit:attr':\n          result = applyEditAttr(result, operation);\n          break;\n\n        case 'edit:content':\n          result = applyEditContent(result, operation);\n          break;\n\n        case 'edit:params':\n          result = applyEditParams(result, operation);\n          break;\n\n        case 'edit:id':\n          result = applyEditId(result, operation);\n          break;\n\n        case 'insert':\n          result = applyInsert(result, operation);\n          break;\n\n        case 'delete':\n          result = applyDelete(result, operation);\n          break;\n\n        case 'replace':\n          result = applyReplace(result, operation);\n          break;\n\n        case 'move':\n          result = applyMove(result, operation);\n          break;\n\n        default:\n          throw new Error(`Unknown operation type: ${(operation as any).type}`);\n      }\n    }\n\n    return { success: true, nodes: result };\n  } catch (error) {\n    return { \n      success: false, \n      nodes,\n      error: error instanceof Error ? error.message : String(error) \n    };\n  }\n}\n\n// ============================================\n// Operation Application Functions\n// ============================================\n\nfunction applyEditAttr(nodes: Node[], op: EditAttrOperation): Node[] {\n  let found = false;\n  \n  const result = nodes.map(node => {\n    if (node.id === op.blockId) {\n      found = true;\n      return { \n        ...node, \n        props: { ...((node as any).props || {}), [op.name]: op.value } \n      };\n    }\n    \n    // Search in children for nested nodes (even though we prefer flat structure)\n    if ('children' in node && node.children && node.children.length > 0) {\n      const updatedChildren = applyEditAttr(node.children, op);\n      if (!found && updatedChildren !== node.children) {\n        found = true;\n      }\n      return { ...node, children: updatedChildren };\n    }\n    \n    return node;\n  });\n  \n  if (!found) {\n    throw new Error(`Block not found: ${op.blockId}`);\n  }\n  \n  return result;\n}\n\nfunction applyEditContent(nodes: Node[], op: EditContentOperation): Node[] {\n  let found = false;\n  \n  const result = nodes.map(node => {\n    if (node.id === op.blockId) {\n      found = true;\n      \n      // Both ContentNode and ExecutableNode use the content field\n      if ('content' in node) {\n        // Trim whitespace from text content\n        const trimmedContent = trimContent(op.content);\n        return { ...node, content: trimmedContent };\n      }\n      // Node does not have editable content\n      else {\n        throw new Error(`Block ${op.blockId} does not have editable content`);\n      }\n    }\n    \n    if ('children' in node && node.children && node.children.length > 0) {\n      const updatedChildren = applyEditContent(node.children, op);\n      if (!found && updatedChildren !== node.children) {\n        found = true;\n      }\n      return { ...node, children: updatedChildren };\n    }\n    \n    return node;\n  });\n  \n  if (!found) {\n    throw new Error(`Block not found: ${op.blockId}`);\n  }\n  \n  return result;\n}\n\nfunction applyEditParams(nodes: Node[], op: EditParamsOperation): Node[] {\n  let found = false;\n  \n  const result = nodes.map(node => {\n    if (node.id === op.blockId) {\n      found = true;\n      // Only executable nodes have parameters\n      if ('parameters' in node) {\n        return { ...node, parameters: op.params };\n      } else {\n        throw new Error(`Block ${op.blockId} is not an executable node`);\n      }\n    }\n    \n    if ('children' in node && node.children && node.children.length > 0) {\n      const updatedChildren = applyEditParams(node.children, op);\n      if (!found && updatedChildren !== node.children) {\n        found = true;\n      }\n      return { ...node, children: updatedChildren };\n    }\n    \n    return node;\n  });\n  \n  if (!found) {\n    throw new Error(`Block not found: ${op.blockId}`);\n  }\n  \n  return result;\n}\n\nfunction applyEditId(nodes: Node[], op: EditIdOperation): Node[] {\n  let found = false;\n  \n  const result = nodes.map(node => {\n    if (node.id === op.blockId) {\n      found = true;\n      return { ...node, id: op.newId };\n    }\n    \n    if ('children' in node && node.children && node.children.length > 0) {\n      const updatedChildren = applyEditId(node.children, op);\n      if (!found && updatedChildren !== node.children) {\n        found = true;\n      }\n      return { ...node, children: updatedChildren };\n    }\n    \n    return node;\n  });\n  \n  if (!found) {\n    throw new Error(`Block not found: ${op.blockId}`);\n  }\n  \n  return result;\n}\n\nfunction applyInsert(nodes: Node[], op: InsertOperation): Node[] {\n  // Validate position specification\n  const positionCount = [op.atStart, op.atEnd, op.afterBlockId, op.beforeBlockId]\n    .filter(Boolean).length;\n  \n  if (positionCount !== 1) {\n    throw new Error('Insert operation must specify exactly one position');\n  }\n  \n  // Ensure all inserted blocks have IDs\n  const blocksToInsert = op.blocks.map(block => ({\n    ...block,\n    id: block.id || uuidv4(),\n  }));\n\n  if (op.atStart) {\n    return [...blocksToInsert, ...nodes];\n  }\n\n  if (op.atEnd) {\n    return [...nodes, ...blocksToInsert];\n  }\n\n  const result: Node[] = [];\n  let inserted = false;\n\n  for (const node of nodes) {\n    if (op.beforeBlockId && node.id === op.beforeBlockId) {\n      result.push(...blocksToInsert);\n      inserted = true;\n    }\n\n    result.push(node);\n\n    if (op.afterBlockId && node.id === op.afterBlockId) {\n      result.push(...blocksToInsert);\n      inserted = true;\n    }\n  }\n\n  if (!inserted) {\n    throw new Error(`Could not find anchor block for insert operation`);\n  }\n\n  return result;\n}\n\nfunction applyDelete(nodes: Node[], op: DeleteOperation): Node[] {\n  // Remove from top level and recursively from children\n  return nodes\n    .filter(node => node.id !== op.blockId)\n    .map(node => {\n      if ('children' in node && node.children && node.children.length > 0) {\n        return { ...node, children: applyDelete(node.children, op) };\n      }\n      return node;\n    });\n}\n\nfunction applyReplace(nodes: Node[], op: ReplaceOperation): Node[] {\n  // When replacing with a single block, preserve the original ID\n  const replacementBlocks = op.blocks.map((block, index) => {\n    const newId = op.blocks.length === 1 && index === 0 ? op.blockId : (block.id || uuidv4());\n    return {\n      ...block,\n      id: newId,\n    };\n  });\n\n  const result: Node[] = [];\n  let replaced = false;\n\n  for (const node of nodes) {\n    if (node.id === op.blockId) {\n      result.push(...replacementBlocks);\n      replaced = true;\n    } else {\n      result.push(node);\n    }\n  }\n\n  if (!replaced) {\n    throw new Error(`Could not find block ${op.blockId} to replace`);\n  }\n\n  return result;\n}\n\nfunction applyMove(nodes: Node[], op: MoveOperation): Node[] {\n  // Determine what blocks to move\n  let blocksToMove: Node[] = [];\n  let remainingNodes: Node[] = [];\n\n  if (op.blockId) {\n    // Single block move\n    const blockToMove = findNodeById(nodes, op.blockId);\n    if (!blockToMove) {\n      throw new Error(`Block not found: ${op.blockId}`);\n    }\n    blocksToMove = [blockToMove];\n    remainingNodes = nodes.filter(n => n.id !== op.blockId);\n  } else if (op.blockIds) {\n    // Multiple blocks move\n    for (const id of op.blockIds) {\n      const block = findNodeById(nodes, id);\n      if (!block) {\n        throw new Error(`Block not found: ${id}`);\n      }\n      blocksToMove.push(block);\n    }\n    remainingNodes = nodes.filter(n => !op.blockIds!.includes(n.id));\n  } else if (op.fromBlockId && op.toBlockId) {\n    // Range move\n    const fromIndex = nodes.findIndex(n => n.id === op.fromBlockId);\n    const toIndex = nodes.findIndex(n => n.id === op.toBlockId);\n    \n    if (fromIndex === -1) {\n      throw new Error(`Block not found: ${op.fromBlockId}`);\n    }\n    if (toIndex === -1) {\n      throw new Error(`Block not found: ${op.toBlockId}`);\n    }\n    \n    const startIndex = Math.min(fromIndex, toIndex);\n    const endIndex = Math.max(fromIndex, toIndex);\n    \n    blocksToMove = nodes.slice(startIndex, endIndex + 1);\n    remainingNodes = [\n      ...nodes.slice(0, startIndex),\n      ...nodes.slice(endIndex + 1)\n    ];\n  } else {\n    throw new Error('Move operation must specify blockId, blockIds, or fromBlockId/toBlockId');\n  }\n\n  // Now insert the moved blocks at the new position\n  const insertOp: InsertOperation = {\n    type: 'insert',\n    afterBlockId: op.afterBlockId,\n    beforeBlockId: op.beforeBlockId,\n    atStart: op.atStart,\n    atEnd: op.atEnd,\n    blocks: blocksToMove\n  };\n\n  return applyInsert(remainingNodes, insertOp);\n}\n\n// ============================================\n// Helper Functions\n// ============================================\n\nfunction findNodeById(nodes: Node[], id: string): Node | null {\n  for (const node of nodes) {\n    if (node.id === id) {\n      return node;\n    }\n    \n    if ('children' in node && node.children) {\n      const found = findNodeById(node.children, id);\n      if (found) return found;\n    }\n  }\n  \n  return null;\n}\n\n/**\n * Trim whitespace from RichContent array\n */\nfunction trimContent(content: RichContent[]): RichContent[] {\n  if (!content || content.length === 0) {\n    return content || [];\n  }\n  \n  const result = content\n    .filter(item => item != null) // Filter out null/undefined items\n    .map(item => {\n      if (!item || typeof item !== 'object') {\n        console.warn('Invalid content item:', item);\n        return null;\n      }\n      \n      if (item.type === 'text' && 'text' in item) {\n        // Ensure text property exists and is a string\n        const text = String(item.text || '').trim();\n        return {\n          ...item,\n          text\n        };\n      }\n      return item;\n    })\n    .filter(item => item != null); // Remove any nulls from invalid items\n  \n  // Remove empty text items after trimming\n  return result.filter(item => {\n    if (item && item.type === 'text') {\n      return item.text && item.text.length > 0;\n    }\n    return true;\n  });\n}\n\n// Re-export types for convenience\nexport type { EditOperation } from './ast';","/**\n * Lightweight Agent implementation for idyll-engine\n *\n * This is a clean implementation inspired by the app's Agent class\n * but without the database dependencies and app-specific logic.\n */\n\nimport { generateText, streamText, Message, CoreTool, LanguageModel } from \"ai\";\nimport {\n  AgentConfig,\n  AgentDefinition,\n  AgentContext,\n  AgentExecuteOptions,\n  AgentExecuteResult,\n  AgentActivity,\n} from \"./types\";\nimport type { AgentDocument } from \"../document/ast\";\nimport { ActivityMemory } from \"./memory\";\nimport { ToolRegistry } from \"../document/tool-registry\";\nimport {\n  NodeExecutionContext,\n  BlockExecutionContext,\n} from \"../document/execution-types\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { buildDetailedSystemPrompt } from \"./system-prompt\";\nimport { extractCustomTools } from \"./custom-tools\";\nimport { mergeToolRegistries } from \"../document/tool-registry\";\nimport { ResponsePipeline, ResponseMiddleware } from \"./response-pipeline\";\nimport {\n  toAzureFunctionName,\n  fromAzureFunctionName,\n} from \"../document/tool-naming\";\n\n/**\n * Agent class for executing conversations with tools\n */\nexport class Agent {\n  private program: AgentDefinition;\n  private model: LanguageModel;\n  private tools: ToolRegistry;\n  private memory: ActivityMemory;\n  private context: AgentContext;\n  private aiTools: Record<string, CoreTool> = {};\n  private currentMessages: Message[] = [];\n  private responsePipeline: ResponsePipeline;\n\n  constructor(config: AgentConfig) {\n    this.program = config.program;\n    this.model = config.model;\n    this.tools = config.tools;\n\n    this.memory = new ActivityMemory();\n    this.context = {\n      agentId: this.program.id,\n      activities: [],\n    };\n\n    // Initialize response pipeline\n    this.responsePipeline = new ResponsePipeline();\n    if (config.responseMiddleware) {\n      config.responseMiddleware.forEach((mw) => this.responsePipeline.use(mw));\n    }\n\n    // Initialize AI tools from registry\n    this.initializeTools();\n  }\n\n  /**\n   * Initialize tools for AI SDK\n   */\n  private initializeTools() {\n    // Extract custom tools from agent program\n    const customTools = extractCustomTools(this.program, this.tools, () => {\n      // Get the last user message as agent context\n      const lastUserMessage = this.currentMessages\n        .filter((m) => m.role === \"user\")\n        .pop();\n      return typeof lastUserMessage?.content === \"string\"\n        ? lastUserMessage.content\n        : JSON.stringify(lastUserMessage?.content || \"\");\n    });\n\n    // Merge base tools with custom tools\n    const allTools = mergeToolRegistries(this.tools, customTools);\n\n    // Convert all tools to AI SDK format\n    for (const [name, tool] of Object.entries(allTools)) {\n      // Transform tool name to be OpenAI-compatible using Azure adapter pattern\n      const aiToolName = toAzureFunctionName(name);\n\n      // Create AI SDK tool wrapper\n      this.aiTools[aiToolName] = {\n        description: tool.description,\n        parameters: tool.schema,\n        execute: async (params: any) => {\n          console.log(` Executing tool: ${name}`);\n\n          // Create execution context\n          const context: NodeExecutionContext = {\n            currentNodeId: uuidv4(),\n            previousResults: new Map(),\n            document: { id: this.program.id, nodes: this.program.nodes } as any,\n          };\n\n          try {\n            // Execute tool\n            const content = params.content || \"\";\n            delete params.content; // Remove content from params\n\n            const result = await tool.execute(params, content, context);\n\n            // Process response through middleware pipeline\n            const finalResult = await this.responsePipeline.process({\n              toolName: name,\n              params: params,\n              result: result,\n              messages: this.currentMessages.slice(-3),\n            });\n\n            const isCustomTool = name.startsWith(\"custom:\");\n            if (isCustomTool) {\n              console.log(` Custom tool ${name} executed and compressed`);\n            }\n\n            // Track tool call\n            this.memory.add({\n              type: \"tool\",\n              toolCalls: [\n                {\n                  name,\n                  args: params,\n                  result: finalResult,\n                },\n              ],\n            });\n\n            return finalResult;\n          } catch (error) {\n            const errorMessage =\n              error instanceof Error ? error.message : \"Unknown error\";\n\n            // Track error\n            this.memory.add({\n              type: \"tool\",\n              toolCalls: [\n                {\n                  name,\n                  args: params,\n                },\n              ],\n              error: errorMessage,\n            });\n\n            throw error;\n          }\n        },\n      };\n    }\n  }\n\n  /**\n   * Get the system prompt with memory injection\n   */\n  private getSystemPrompt(): string {\n    const memoryContext = this.memory.formatForPrompt();\n    const toolNames = Object.keys(this.aiTools);\n\n    const systemPrompt = buildDetailedSystemPrompt(\n      this.program,\n      toolNames,\n      memoryContext\n    );\n\n    console.log(\n      `[Agent]  System prompt generated (${systemPrompt.length} chars)`\n    );\n    console.log(\n      `[Agent]  System prompt contains response_guidelines: ${systemPrompt.includes(\"response_guidelines\")}`\n    );\n\n    return systemPrompt;\n  }\n\n  /**\n   * Execute a chat message (non-streaming)\n   */\n  async chat(\n    messages: Message[],\n    options?: AgentExecuteOptions\n  ): Promise<AgentExecuteResult> {\n    // Store current messages for context\n    this.currentMessages = messages;\n\n    const userMessage = messages[messages.length - 1]?.content;\n\n    try {\n      // Add to memory\n      const activity = this.memory.add({\n        type: \"chat\",\n        userMessage:\n          typeof userMessage === \"string\"\n            ? userMessage\n            : JSON.stringify(userMessage),\n      });\n\n      const result = await generateText({\n        model: this.model,\n        system: this.getSystemPrompt(),\n        messages,\n        tools: this.aiTools,\n        toolChoice: \"auto\",\n        maxSteps: options?.maxSteps ?? 10,\n        temperature: options?.temperature ?? 0.7,\n      });\n\n      // Update activity with response\n      activity.assistantMessage = result.text;\n      activity.usage = result.usage;\n      if (result.toolCalls && result.toolCalls.length > 0) {\n        activity.toolCalls = result.toolCalls.map((tc) => ({\n          name: tc.toolName,\n          args: tc.args as Record<string, any>,\n        }));\n      }\n\n      return {\n        message: {\n          id: uuidv4(),\n          role: \"assistant\",\n          content: result.text,\n          createdAt: new Date(),\n        },\n        usage: result.usage,\n        finishReason: result.finishReason,\n      };\n    } catch (error) {\n      // Track error\n      this.memory.add({\n        type: \"chat\",\n        userMessage:\n          typeof userMessage === \"string\"\n            ? userMessage\n            : JSON.stringify(userMessage),\n        error: error instanceof Error ? error.message : \"Unknown error\",\n      });\n\n      throw error;\n    }\n  }\n\n  /**\n   * Execute a chat message (streaming)\n   * Returns streamText result that can be used with toDataStreamResponse()\n   */\n  async chatStream(messages: Message[], options?: AgentExecuteOptions) {\n    const userMessage = messages[messages.length - 1]?.content;\n\n    try {\n      // Add to memory\n      const activity = this.memory.add({\n        type: \"chat\",\n        userMessage:\n          typeof userMessage === \"string\"\n            ? userMessage\n            : JSON.stringify(userMessage),\n      });\n\n      const result = await streamText({\n        model: this.model,\n        system: this.getSystemPrompt(),\n        messages,\n        tools: this.aiTools,\n        maxSteps: options?.maxSteps ?? 10,\n        temperature: options?.temperature ?? 0.7,\n        onFinish: async ({ text, toolCalls, usage, finishReason }) => {\n          console.log(\n            `[Agent]  Final finish - reason: ${finishReason}, text length: ${text.length}, toolCalls: ${toolCalls?.length || 0}`\n          );\n\n          // Update activity when stream finishes\n          activity.assistantMessage = text;\n          if (toolCalls && toolCalls.length > 0) {\n            activity.toolCalls = toolCalls.map((tc) => ({\n              name: fromAzureFunctionName(tc.toolName),\n              args: tc.args,\n            }));\n          }\n\n          // Call the external onFinish callback if provided\n          if (options?.onFinish) {\n            await options.onFinish({\n              text,\n              toolCalls: toolCalls?.map((tc) => ({\n                ...tc,\n                toolName: fromAzureFunctionName(tc.toolName),\n              })),\n              usage,\n              finishReason,\n            });\n          }\n        },\n      });\n\n      return result;\n    } catch (error) {\n      // Track error\n      this.memory.add({\n        type: \"chat\",\n        userMessage:\n          typeof userMessage === \"string\"\n            ? userMessage\n            : JSON.stringify(userMessage),\n        error: error instanceof Error ? error.message : \"Unknown error\",\n      });\n\n      throw error;\n    }\n  }\n\n  /**\n   * Get memory/activity history\n   */\n  getMemory(): ActivityMemory {\n    return this.memory;\n  }\n\n  /**\n   * Get agent context\n   */\n  getContext(): AgentContext {\n    return {\n      ...this.context,\n      activities: this.memory.toJSON(),\n    };\n  }\n\n  /**\n   * Clear memory\n   */\n  clearMemory(): void {\n    this.memory.clear();\n  }\n}\n","/**\n * In-memory activity tracking for agents\n */\n\nimport { formatDistanceToNow } from 'date-fns';\nimport { AgentActivity } from './types';\n\n/**\n * Simple in-memory activity store\n */\nexport class ActivityMemory {\n  private activities: AgentActivity[] = [];\n  private maxSize: number;\n\n  constructor(maxSize = 20) {\n    this.maxSize = maxSize;\n  }\n\n  /**\n   * Add an activity record\n   */\n  add(activity: Omit<AgentActivity, 'id' | 'timestamp'>): AgentActivity {\n    const record: AgentActivity = {\n      ...activity,\n      id: crypto.randomUUID(),\n      timestamp: new Date(),\n    };\n\n    this.activities.unshift(record);\n    \n    // Keep only maxSize records\n    if (this.activities.length > this.maxSize) {\n      this.activities = this.activities.slice(0, this.maxSize);\n    }\n\n    return record;\n  }\n\n  /**\n   * Get recent activities\n   */\n  getRecent(limit?: number): AgentActivity[] {\n    return limit ? this.activities.slice(0, limit) : this.activities;\n  }\n\n  /**\n   * Clear all activities\n   */\n  clear(): void {\n    this.activities = [];\n  }\n\n  /**\n   * Format activities as memory context for agent\n   */\n  formatForPrompt(limit = 10): string {\n    const recent = this.getRecent(limit);\n    \n    if (recent.length === 0) {\n      return '';\n    }\n\n    const formatted = recent.map(activity => {\n      const timeAgo = formatDistanceToNow(activity.timestamp, { addSuffix: true });\n      const parts = [`[${timeAgo}] ${activity.type}`];\n      \n      if (activity.userMessage) {\n        parts.push(`User: \"${activity.userMessage.substring(0, 100)}${activity.userMessage.length > 100 ? '...' : ''}\"`);\n      }\n      \n      if (activity.assistantMessage) {\n        parts.push(`Assistant: \"${activity.assistantMessage.substring(0, 100)}${activity.assistantMessage.length > 100 ? '...' : ''}\"`);\n      }\n      \n      if (activity.toolCalls && activity.toolCalls.length > 0) {\n        parts.push(`Tools: ${activity.toolCalls.map(tc => tc.name).join(', ')}`);\n      }\n      \n      if (activity.error) {\n        parts.push(`Error: ${activity.error}`);\n      }\n      \n      return parts.join(' | ');\n    }).join('\\n');\n\n    return `<recent_activity>\n${formatted}\n</recent_activity>`;\n  }\n\n  /**\n   * Get activities as JSON\n   */\n  toJSON(): AgentActivity[] {\n    return this.activities;\n  }\n}","/**\n * System prompt builder for agents\n * \n * Converts AgentDocument to a proper system prompt with:\n * - Background context\n * - Tool definitions\n * - Custom instructions from nodes\n */\n\nimport { AgentDocument, Node, isExecutableNode, isTextContent } from '../document/ast';\nimport { serializeAstToXml } from '../document/parser-grammar';\n\n/**\n * Build system prompt from agent document\n */\nexport function buildSystemPrompt(agent: AgentDocument, availableTools: string[]): string {\n  const sections: string[] = [];\n  \n  // Agent identity\n  sections.push(`You are ${agent.name || 'an AI assistant'}.`);\n  if (agent.description) {\n    sections.push(agent.description);\n  }\n  \n  // Model info\n  sections.push(`\\nModel: ${agent.model || 'default'}`);\n  \n  // Available tools\n  if (availableTools.length > 0) {\n    sections.push(`\\nAvailable tools:\\n${availableTools.map(t => `- ${t}`).join('\\n')}`);\n  }\n  \n  // Process blocks for custom instructions and tool definitions\n  const instructions: string[] = [];\n  const customTools: string[] = [];\n  const triggers: string[] = [];\n  \n  for (const node of agent.nodes) {\n    if (node.type === 'tool') {\n      // Extract tool definition\n      const title = node.props?.title as string || 'Untitled Tool';\n      customTools.push(`Custom tool: ${title}`);\n    } else if (node.type === 'trigger') {\n      // Note triggers\n      const trigger = node.props?.trigger as string;\n      if (trigger) {\n        triggers.push(`Trigger: ${trigger}`);\n      }\n    } else if ('content' in node && node.content) {\n      // Extract text content as instructions\n      const text = extractTextFromBlock(node);\n      if (text) {\n        instructions.push(text);\n      }\n    }\n  }\n  \n  // Add custom tools section\n  if (customTools.length > 0) {\n    sections.push(`\\nCustom tools defined:\\n${customTools.join('\\n')}`);\n  }\n  \n  // Add triggers section\n  if (triggers.length > 0) {\n    sections.push(`\\nTriggers configured:\\n${triggers.join('\\n')}`);\n  }\n  \n  // Add instructions\n  if (instructions.length > 0) {\n    sections.push(`\\nInstructions:\\n${instructions.join('\\n\\n')}`);\n  }\n  \n  // Add XML context for understanding the format\n  sections.push(`\\nWhen working with documents, use the Idyllic XML format.`);\n  \n  return sections.join('\\n');\n}\n\n/**\n * Extract plain text from a node\n */\nfunction extractTextFromBlock(node: Node): string {\n  if (!('content' in node) || !node.content) {\n    return '';\n  }\n  \n  const texts: string[] = [];\n  \n  for (const content of node.content) {\n    if (isTextContent(content)) {\n      texts.push(content.text);\n    }\n  }\n  \n  return texts.join('');\n}\n\n/**\n * Create a more detailed prompt with XML examples\n */\nexport function buildDetailedSystemPrompt(\n  agent: AgentDocument, \n  availableTools: string[],\n  includeMemory?: string\n): string {\n  let prompt = buildSystemPrompt(agent, availableTools);\n  \n  // Add memory if provided\n  if (includeMemory) {\n    prompt = `${prompt}\\n\\n${includeMemory}`;\n  }\n  \n  // Add document structure explanation\n  prompt += `\\n\\n<document_format>\nDocuments are structured using XML with blocks like:\n- <p> for paragraphs\n- <h1>, <h2>, etc. for headings\n- <fncall idyll-tool=\"...\"> for tool execution\n- <variable name=\"...\" /> for variables\n- <mention:type id=\"...\">label</mention:type> for references\n</document_format>\n\n<response_guidelines>\nWhen responding to user queries:\n1. If you need to call tools, call them first\n2. After tool calls complete, provide ONE clear, comprehensive response\n3. Do not repeat or rephrase the same information multiple times\n4. Only continue with additional steps if you need to call different tools or perform distinct reasoning\n5. Avoid generating multiple similar responses about the same topic\n</response_guidelines>`;\n  \n  return prompt;\n}","/**\n * Custom tool extraction and execution for agents\n * \n * Extracts tool definitions from agent system prompts and\n * creates executable tools that use the custom tool executor.\n */\n\nimport { z } from 'zod';\nimport { AgentDocument, Node, ContentNode } from '../document/ast';\nimport { ToolDefinition, ToolRegistry } from '../document/tool-registry';\nimport { executeCustomTool, parseCustomTool } from '../document/custom-tool-executor';\nimport { parseXmlToAst } from '../document/parser-grammar';\n\n/**\n * Extract custom tools from agent document\n */\nexport function extractCustomTools(\n  agentDoc: AgentDocument,\n  baseTools: ToolRegistry,\n  getAgentContext?: () => string\n): ToolRegistry {\n  const customTools: ToolRegistry = {};\n  \n  console.log(' Extracting custom tools from agent document...');\n  \n  // Find all tool blocks\n  for (const block of agentDoc.nodes) {\n    if (block.type === 'tool' && 'props' in block) {\n      console.log(' Found tool block:', JSON.stringify(block, null, 2));\n      const title = block.props?.title as string || 'Untitled Tool';\n      const icon = block.props?.icon as string;\n      \n      // Extract description from content\n      const description = extractTextContent(block);\n      \n      // Extract tool definition blocks from children\n      const definitionBlocks = extractToolDefinitionBlocks(block);\n      \n      if (definitionBlocks.length === 0) {\n        console.warn(`Tool \"${title}\" has no definition blocks`);\n        continue;\n      }\n      \n      // Convert title to valid tool name (snake_case)\n      const toolName = title\n        .toLowerCase()\n        .replace(/[^a-z0-9]+/g, '_')\n        .replace(/^_+|_+$/g, '');\n      \n      // Create the custom tool\n      customTools[`custom:${toolName}`] = {\n        description: description || `Custom tool: ${title}`,\n        schema: z.object({\n          context: z.string()\n            .describe('Relevant context to help resolve any variables in the tool')\n            .optional(),\n        }),\n        execute: async (params, content, context) => {\n          console.log(` Executing custom tool: ${title}`);\n          \n          // Create a virtual document with the tool definition\n          const toolDoc = {\n            id: `custom-tool-${toolName}`,\n            nodes: definitionBlocks,\n          };\n          \n          // Create custom tool block for execution\n          const customToolBlock: ContentNode = {\n            id: context.currentNodeId || 'custom-tool-exec',\n            type: 'tool',\n            content: [],\n            children: definitionBlocks,\n            props: { title, icon },\n          };\n          \n          // Build agent context from params and content\n          // The AI typically passes context in params.context or uses content\n          let agentContext = '';\n          if (params.context) {\n            agentContext = params.context;\n          } else if (content) {\n            agentContext = content;\n          } else if (getAgentContext) {\n            // Use the agent context getter if provided\n            agentContext = getAgentContext();\n          } else {\n            // Try to infer from the execution context\n            agentContext = `Tool invoked: ${title}`;\n          }\n          \n          console.log(` Agent context for variable resolution: \"${agentContext}\"`);\n          console.log(` Params:`, params);\n          console.log(` Content:`, content);\n          console.log(` GetAgentContext available:`, !!getAgentContext);\n          \n          try {\n            // Execute the custom tool\n            const executionContext = await executeCustomTool(customToolBlock, {\n              tools: baseTools,\n              agentContext: agentContext,\n            });\n            \n            // Extract the final result\n            const lastNodeId = Array.from(executionContext.nodes.keys()).pop();\n            const lastResult = lastNodeId ? executionContext.nodes.get(lastNodeId) : undefined;\n            \n            console.log(` Execution complete. Last node ID: ${lastNodeId}`);\n            console.log(` Last result:`, lastResult);\n            console.log(` All nodes:`, Array.from(executionContext.nodes.entries()));\n            \n            // Check if we have any successful results\n            const results = Array.from(executionContext.nodes.values());\n            const successfulResults = results.filter(r => r.success);\n            const failedResults = results.filter(r => !r.success);\n            \n            console.log(` Execution summary: ${successfulResults.length} successful, ${failedResults.length} failed`);\n            \n            // If we have successful results, return the full context for compression\n            if (successfulResults.length > 0) {\n              console.log(` Returning full ToolExecutionReport for compression`);\n              return executionContext;\n            }\n            \n            // If everything failed, throw the last error\n            if (lastResult && !lastResult.success) {\n              const errorMsg = typeof lastResult.error === 'string' \n                ? lastResult.error \n                : JSON.stringify(lastResult.error) || 'Tool execution failed';\n              throw new Error(errorMsg);\n            }\n            \n            // Fallback\n            return executionContext;\n          } catch (error) {\n            console.error(` Custom tool \"${title}\" failed:`, error);\n            throw error;\n          }\n        },\n      };\n    }\n  }\n  \n  return customTools;\n}\n\n/**\n * Extract text content from a block\n */\nfunction extractTextContent(block: Node): string {\n  if (!('content' in block) || !block.content) {\n    return '';\n  }\n  \n  const texts: string[] = [];\n  for (const content of block.content) {\n    if (content.type === 'text') {\n      texts.push(content.text);\n    }\n  }\n  \n  return texts.join('').trim();\n}\n\n/**\n * Extract tool definition blocks from a tool block\n * \n * Tool blocks have a structure like:\n * <tool>\n *   <tool:description>text content</tool:description>\n *   <tool:definition>\n *     <p>...</p>\n *     <fncall>...</fncall>\n *   </tool:definition>\n * </tool>\n */\nfunction extractToolDefinitionBlocks(toolBlock: Node): Node[] {\n  if (!('children' in toolBlock) || !toolBlock.children) {\n    return [];\n  }\n  \n  const definitionBlocks: Node[] = [];\n  \n  for (const child of toolBlock.children) {\n    // Look for blocks with specific types from our parser\n    if ('type' in child) {\n      // The parser converts <tool:definition> to a block with type 'tool:definition'\n      // But we need to check the actual parsed structure\n      if (child.type === 'paragraph' || child.type === 'function_call') {\n        definitionBlocks.push(child);\n      } else if ('children' in child && child.children) {\n        // Recursively extract from nested structures\n        definitionBlocks.push(...extractToolDefinitionBlocks(child));\n      }\n    }\n  }\n  \n  return definitionBlocks;\n}","/**\n * Response Pipeline System\n * \n * Provides middleware-based processing of tool execution results\n * before they are returned to the agent conversation loop.\n */\n\nimport { Message } from 'ai';\n\n/**\n * Context provided to middleware for processing tool results\n */\nexport interface MiddlewareContext {\n  /** Name of the tool that was executed */\n  toolName: string;\n  \n  /** Parameters passed to the tool */\n  params: any;\n  \n  /** The raw result from tool execution */\n  result: any;\n  \n  /** Recent conversation messages for context-aware processing */\n  messages?: Message[];\n}\n\n/**\n * Middleware interface for processing tool results\n */\nexport interface ResponseMiddleware {\n  /** Unique name for the middleware */\n  name: string;\n  \n  /** Process the tool result and return the modified result */\n  process(context: MiddlewareContext): Promise<any>;\n}\n\n/**\n * Pipeline that processes tool results through a chain of middleware\n */\nexport class ResponsePipeline {\n  private middleware: ResponseMiddleware[] = [];\n  \n  /**\n   * Add middleware to the pipeline\n   */\n  use(middleware: ResponseMiddleware): void {\n    this.middleware.push(middleware);\n  }\n  \n  /**\n   * Process a tool result through all middleware in order\n   */\n  async process(context: MiddlewareContext): Promise<any> {\n    let result = context.result;\n    \n    // Process through each middleware sequentially\n    for (const mw of this.middleware) {\n      try {\n        // Update the context with the current result for the next middleware\n        const updatedContext = { ...context, result };\n        result = await mw.process(updatedContext);\n      } catch (error) {\n        console.error(`[ResponsePipeline] Error in middleware ${mw.name}:`, error);\n        // Continue with the current result if middleware fails\n      }\n    }\n    \n    return result;\n  }\n  \n  /**\n   * Check if any middleware is configured\n   */\n  hasMiddleware(): boolean {\n    return this.middleware.length > 0;\n  }\n  \n  /**\n   * Get list of configured middleware names\n   */\n  getMiddlewareNames(): string[] {\n    return this.middleware.map(mw => mw.name);\n  }\n}"],"mappings":"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","names":["terminal","compiled","z","uuidv4","uuidv4","z","extractTextContent","z","uuidv4"]}