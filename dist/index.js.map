{"version":3,"sources":["../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider/src/errors/ai-sdk-error.ts","../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider/src/errors/api-call-error.ts","../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider/src/errors/empty-response-body-error.ts","../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider/src/errors/get-error-message.ts","../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider/src/errors/invalid-argument-error.ts","../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider/src/errors/invalid-prompt-error.ts","../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider/src/errors/invalid-response-data-error.ts","../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider/src/errors/json-parse-error.ts","../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider/src/errors/load-api-key-error.ts","../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider/src/errors/load-setting-error.ts","../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider/src/errors/no-content-generated-error.ts","../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider/src/errors/no-such-model-error.ts","../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider/src/errors/too-many-embedding-values-for-call-error.ts","../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider/src/errors/type-validation-error.ts","../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider/src/errors/unsupported-functionality-error.ts","../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider/src/json-value/is-json.ts","../node_modules/nanoid/non-secure/index.js","../node_modules/secure-json-parse/index.js","../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider-utils/src/combine-headers.ts","../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider-utils/src/convert-async-iterator-to-readable-stream.ts","../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider-utils/src/delay.ts","../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider-utils/src/event-source-parser-stream.ts","../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider-utils/src/extract-response-headers.ts","../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider-utils/src/generate-id.ts","../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider-utils/src/get-error-message.ts","../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider-utils/src/get-from-api.ts","../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider-utils/src/remove-undefined-entries.ts","../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider-utils/src/is-abort-error.ts","../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider-utils/src/load-api-key.ts","../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider-utils/src/load-optional-setting.ts","../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider-utils/src/load-setting.ts","../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider-utils/src/parse-json.ts","../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider-utils/src/validate-types.ts","../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider-utils/src/validator.ts","../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider-utils/src/parse-provider-options.ts","../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider-utils/src/post-to-api.ts","../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider-utils/src/resolve.ts","../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider-utils/src/response-handler.ts","../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider-utils/src/uint8-utils.ts","../node_modules/@ai-sdk/openai/node_modules/@ai-sdk/provider-utils/src/without-trailing-slash.ts","../node_modules/@ai-sdk/openai/src/openai-chat-language-model.ts","../node_modules/@ai-sdk/openai/src/convert-to-openai-chat-messages.ts","../node_modules/@ai-sdk/openai/src/map-openai-chat-logprobs.ts","../node_modules/@ai-sdk/openai/src/map-openai-finish-reason.ts","../node_modules/@ai-sdk/openai/src/openai-error.ts","../node_modules/@ai-sdk/openai/src/get-response-metadata.ts","../node_modules/@ai-sdk/openai/src/openai-prepare-tools.ts","../node_modules/@ai-sdk/openai/src/openai-completion-language-model.ts","../node_modules/@ai-sdk/openai/src/convert-to-openai-completion-prompt.ts","../node_modules/@ai-sdk/openai/src/map-openai-completion-logprobs.ts","../node_modules/@ai-sdk/openai/src/openai-embedding-model.ts","../node_modules/@ai-sdk/openai/src/openai-image-model.ts","../node_modules/@ai-sdk/openai/src/openai-image-settings.ts","../node_modules/@ai-sdk/openai/src/openai-transcription-model.ts","../node_modules/@ai-sdk/openai/src/openai-speech-model.ts","../node_modules/@ai-sdk/openai/src/responses/openai-responses-language-model.ts","../node_modules/@ai-sdk/openai/src/responses/convert-to-openai-responses-messages.ts","../node_modules/@ai-sdk/openai/src/responses/map-openai-responses-finish-reason.ts","../node_modules/@ai-sdk/openai/src/responses/openai-responses-prepare-tools.ts","../node_modules/@ai-sdk/azure/node_modules/@ai-sdk/provider/src/errors/ai-sdk-error.ts","../node_modules/@ai-sdk/azure/node_modules/@ai-sdk/provider/src/errors/api-call-error.ts","../node_modules/@ai-sdk/azure/node_modules/@ai-sdk/provider/src/errors/empty-response-body-error.ts","../node_modules/@ai-sdk/azure/node_modules/@ai-sdk/provider/src/errors/get-error-message.ts","../node_modules/@ai-sdk/azure/node_modules/@ai-sdk/provider/src/errors/invalid-argument-error.ts","../node_modules/@ai-sdk/azure/node_modules/@ai-sdk/provider/src/errors/invalid-prompt-error.ts","../node_modules/@ai-sdk/azure/node_modules/@ai-sdk/provider/src/errors/invalid-response-data-error.ts","../node_modules/@ai-sdk/azure/node_modules/@ai-sdk/provider/src/errors/json-parse-error.ts","../node_modules/@ai-sdk/azure/node_modules/@ai-sdk/provider/src/errors/load-api-key-error.ts","../node_modules/@ai-sdk/azure/node_modules/@ai-sdk/provider/src/errors/load-setting-error.ts","../node_modules/@ai-sdk/azure/node_modules/@ai-sdk/provider/src/errors/no-content-generated-error.ts","../node_modules/@ai-sdk/azure/node_modules/@ai-sdk/provider/src/errors/no-such-model-error.ts","../node_modules/@ai-sdk/azure/node_modules/@ai-sdk/provider/src/errors/too-many-embedding-values-for-call-error.ts","../node_modules/@ai-sdk/azure/node_modules/@ai-sdk/provider/src/errors/type-validation-error.ts","../node_modules/@ai-sdk/azure/node_modules/@ai-sdk/provider/src/errors/unsupported-functionality-error.ts","../node_modules/@ai-sdk/azure/node_modules/@ai-sdk/provider/src/json-value/is-json.ts","../node_modules/@ai-sdk/azure/node_modules/@ai-sdk/provider-utils/src/combine-headers.ts","../node_modules/@ai-sdk/azure/node_modules/@ai-sdk/provider-utils/src/convert-async-iterator-to-readable-stream.ts","../node_modules/@ai-sdk/azure/node_modules/@ai-sdk/provider-utils/src/delay.ts","../node_modules/@ai-sdk/azure/node_modules/@ai-sdk/provider-utils/src/event-source-parser-stream.ts","../node_modules/@ai-sdk/azure/node_modules/@ai-sdk/provider-utils/src/extract-response-headers.ts","../node_modules/@ai-sdk/azure/node_modules/@ai-sdk/provider-utils/src/generate-id.ts","../node_modules/@ai-sdk/azure/node_modules/@ai-sdk/provider-utils/src/get-error-message.ts","../node_modules/@ai-sdk/azure/node_modules/@ai-sdk/provider-utils/src/get-from-api.ts","../node_modules/@ai-sdk/azure/node_modules/@ai-sdk/provider-utils/src/remove-undefined-entries.ts","../node_modules/@ai-sdk/azure/node_modules/@ai-sdk/provider-utils/src/is-abort-error.ts","../node_modules/@ai-sdk/azure/node_modules/@ai-sdk/provider-utils/src/load-api-key.ts","../node_modules/@ai-sdk/azure/node_modules/@ai-sdk/provider-utils/src/load-optional-setting.ts","../node_modules/@ai-sdk/azure/node_modules/@ai-sdk/provider-utils/src/load-setting.ts","../node_modules/@ai-sdk/azure/node_modules/@ai-sdk/provider-utils/src/parse-json.ts","../node_modules/@ai-sdk/azure/node_modules/@ai-sdk/provider-utils/src/validate-types.ts","../node_modules/@ai-sdk/azure/node_modules/@ai-sdk/provider-utils/src/validator.ts","../node_modules/@ai-sdk/azure/node_modules/@ai-sdk/provider-utils/src/parse-provider-options.ts","../node_modules/@ai-sdk/azure/node_modules/@ai-sdk/provider-utils/src/post-to-api.ts","../node_modules/@ai-sdk/azure/node_modules/@ai-sdk/provider-utils/src/resolve.ts","../node_modules/@ai-sdk/azure/node_modules/@ai-sdk/provider-utils/src/response-handler.ts","../node_modules/@ai-sdk/azure/node_modules/@ai-sdk/provider-utils/src/uint8-utils.ts","../node_modules/@ai-sdk/azure/node_modules/@ai-sdk/provider-utils/src/without-trailing-slash.ts","../node_modules/@ai-sdk/azure/src/azure-openai-provider.ts","../node_modules/@ai-sdk/amazon-bedrock/node_modules/@ai-sdk/provider/src/errors/ai-sdk-error.ts","../node_modules/@ai-sdk/amazon-bedrock/node_modules/@ai-sdk/provider/src/errors/api-call-error.ts","../node_modules/@ai-sdk/amazon-bedrock/node_modules/@ai-sdk/provider/src/errors/empty-response-body-error.ts","../node_modules/@ai-sdk/amazon-bedrock/node_modules/@ai-sdk/provider/src/errors/get-error-message.ts","../node_modules/@ai-sdk/amazon-bedrock/node_modules/@ai-sdk/provider/src/errors/invalid-argument-error.ts","../node_modules/@ai-sdk/amazon-bedrock/node_modules/@ai-sdk/provider/src/errors/invalid-prompt-error.ts","../node_modules/@ai-sdk/amazon-bedrock/node_modules/@ai-sdk/provider/src/errors/invalid-response-data-error.ts","../node_modules/@ai-sdk/amazon-bedrock/node_modules/@ai-sdk/provider/src/errors/json-parse-error.ts","../node_modules/@ai-sdk/amazon-bedrock/node_modules/@ai-sdk/provider/src/errors/load-api-key-error.ts","../node_modules/@ai-sdk/amazon-bedrock/node_modules/@ai-sdk/provider/src/errors/load-setting-error.ts","../node_modules/@ai-sdk/amazon-bedrock/node_modules/@ai-sdk/provider/src/errors/no-content-generated-error.ts","../node_modules/@ai-sdk/amazon-bedrock/node_modules/@ai-sdk/provider/src/errors/no-such-model-error.ts","../node_modules/@ai-sdk/amazon-bedrock/node_modules/@ai-sdk/provider/src/errors/too-many-embedding-values-for-call-error.ts","../node_modules/@ai-sdk/amazon-bedrock/node_modules/@ai-sdk/provider/src/errors/type-validation-error.ts","../node_modules/@ai-sdk/amazon-bedrock/node_modules/@ai-sdk/provider/src/errors/unsupported-functionality-error.ts","../node_modules/@ai-sdk/amazon-bedrock/node_modules/@ai-sdk/provider/src/json-value/is-json.ts","../node_modules/@ai-sdk/amazon-bedrock/node_modules/@ai-sdk/provider-utils/src/combine-headers.ts","../node_modules/@ai-sdk/amazon-bedrock/node_modules/@ai-sdk/provider-utils/src/convert-async-iterator-to-readable-stream.ts","../node_modules/@ai-sdk/amazon-bedrock/node_modules/@ai-sdk/provider-utils/src/delay.ts","../node_modules/@ai-sdk/amazon-bedrock/node_modules/@ai-sdk/provider-utils/src/event-source-parser-stream.ts","../node_modules/@ai-sdk/amazon-bedrock/node_modules/@ai-sdk/provider-utils/src/extract-response-headers.ts","../node_modules/@ai-sdk/amazon-bedrock/node_modules/@ai-sdk/provider-utils/src/generate-id.ts","../node_modules/@ai-sdk/amazon-bedrock/node_modules/@ai-sdk/provider-utils/src/get-error-message.ts","../node_modules/@ai-sdk/amazon-bedrock/node_modules/@ai-sdk/provider-utils/src/get-from-api.ts","../node_modules/@ai-sdk/amazon-bedrock/node_modules/@ai-sdk/provider-utils/src/remove-undefined-entries.ts","../node_modules/@ai-sdk/amazon-bedrock/node_modules/@ai-sdk/provider-utils/src/is-abort-error.ts","../node_modules/@ai-sdk/amazon-bedrock/node_modules/@ai-sdk/provider-utils/src/load-api-key.ts","../node_modules/@ai-sdk/amazon-bedrock/node_modules/@ai-sdk/provider-utils/src/load-optional-setting.ts","../node_modules/@ai-sdk/amazon-bedrock/node_modules/@ai-sdk/provider-utils/src/load-setting.ts","../node_modules/@ai-sdk/amazon-bedrock/node_modules/@ai-sdk/provider-utils/src/parse-json.ts","../node_modules/@ai-sdk/amazon-bedrock/node_modules/@ai-sdk/provider-utils/src/validate-types.ts","../node_modules/@ai-sdk/amazon-bedrock/node_modules/@ai-sdk/provider-utils/src/validator.ts","../node_modules/@ai-sdk/amazon-bedrock/node_modules/@ai-sdk/provider-utils/src/parse-provider-options.ts","../node_modules/@ai-sdk/amazon-bedrock/node_modules/@ai-sdk/provider-utils/src/post-to-api.ts","../node_modules/@ai-sdk/amazon-bedrock/node_modules/@ai-sdk/provider-utils/src/resolve.ts","../node_modules/@ai-sdk/amazon-bedrock/node_modules/@ai-sdk/provider-utils/src/response-handler.ts","../node_modules/@ai-sdk/amazon-bedrock/node_modules/@ai-sdk/provider-utils/src/uint8-utils.ts","../node_modules/@ai-sdk/amazon-bedrock/node_modules/@ai-sdk/provider-utils/src/without-trailing-slash.ts","../node_modules/tslib/tslib.es6.mjs","../node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/node_modules/@smithy/util-buffer-from/node_modules/@smithy/is-array-buffer/dist-es/index.js","../node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/node_modules/@smithy/util-buffer-from/dist-es/index.js","../node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/dist-es/fromUtf8.js","../node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/dist-es/toUint8Array.js","../node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/dist-es/toUtf8.js","../node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/dist-es/index.js","../node_modules/@aws-crypto/util/src/convertToBuffer.ts","../node_modules/@aws-crypto/util/src/isEmptyData.ts","../node_modules/@aws-crypto/util/src/numToUint8.ts","../node_modules/@aws-crypto/util/src/uint32ArrayFrom.ts","../node_modules/@aws-crypto/util/src/index.ts","../node_modules/@aws-crypto/crc32/src/aws_crc32.ts","../node_modules/@aws-crypto/crc32/src/index.ts","../node_modules/@smithy/util-hex-encoding/dist-es/index.js","../node_modules/@smithy/eventstream-codec/dist-es/Int64.js","../node_modules/@smithy/eventstream-codec/dist-es/HeaderMarshaller.js","../node_modules/@smithy/eventstream-codec/dist-es/splitMessage.js","../node_modules/@smithy/eventstream-codec/dist-es/EventStreamCodec.js","../node_modules/@smithy/eventstream-codec/dist-es/Message.js","../node_modules/@smithy/eventstream-codec/dist-es/MessageDecoderStream.js","../node_modules/@smithy/eventstream-codec/dist-es/MessageEncoderStream.js","../node_modules/@smithy/eventstream-codec/dist-es/SmithyMessageDecoderStream.js","../node_modules/@smithy/eventstream-codec/dist-es/SmithyMessageEncoderStream.js","../node_modules/@smithy/eventstream-codec/dist-es/index.js","../node_modules/@smithy/is-array-buffer/dist-es/index.js","../node_modules/@smithy/util-buffer-from/dist-es/index.js","../node_modules/@smithy/util-utf8/dist-es/fromUtf8.js","../node_modules/@smithy/util-utf8/dist-es/toUint8Array.js","../node_modules/@smithy/util-utf8/dist-es/toUtf8.js","../node_modules/@smithy/util-utf8/dist-es/index.js","../node_modules/aws4fetch/dist/aws4fetch.esm.mjs","../node_modules/@ai-sdk/amazon-bedrock/src/bedrock-provider.ts","../node_modules/@ai-sdk/amazon-bedrock/src/bedrock-chat-language-model.ts","../node_modules/@ai-sdk/amazon-bedrock/src/bedrock-api-types.ts","../node_modules/@ai-sdk/amazon-bedrock/src/bedrock-error.ts","../node_modules/@ai-sdk/amazon-bedrock/src/bedrock-event-stream-response-handler.ts","../node_modules/@ai-sdk/amazon-bedrock/src/bedrock-prepare-tools.ts","../node_modules/@ai-sdk/amazon-bedrock/src/convert-to-bedrock-chat-messages.ts","../node_modules/@ai-sdk/amazon-bedrock/src/map-bedrock-finish-reason.ts","../node_modules/@ai-sdk/amazon-bedrock/src/bedrock-embedding-model.ts","../node_modules/@ai-sdk/amazon-bedrock/src/bedrock-image-model.ts","../node_modules/@ai-sdk/amazon-bedrock/src/bedrock-image-settings.ts","../node_modules/@ai-sdk/amazon-bedrock/src/headers-utils.ts","../node_modules/@ai-sdk/amazon-bedrock/src/bedrock-sigv4-fetch.ts","../node_modules/@ai-sdk/google/node_modules/@ai-sdk/provider/src/errors/ai-sdk-error.ts","../node_modules/@ai-sdk/google/node_modules/@ai-sdk/provider/src/errors/api-call-error.ts","../node_modules/@ai-sdk/google/node_modules/@ai-sdk/provider/src/errors/empty-response-body-error.ts","../node_modules/@ai-sdk/google/node_modules/@ai-sdk/provider/src/errors/get-error-message.ts","../node_modules/@ai-sdk/google/node_modules/@ai-sdk/provider/src/errors/invalid-argument-error.ts","../node_modules/@ai-sdk/google/node_modules/@ai-sdk/provider/src/errors/invalid-prompt-error.ts","../node_modules/@ai-sdk/google/node_modules/@ai-sdk/provider/src/errors/invalid-response-data-error.ts","../node_modules/@ai-sdk/google/node_modules/@ai-sdk/provider/src/errors/json-parse-error.ts","../node_modules/@ai-sdk/google/node_modules/@ai-sdk/provider/src/errors/load-api-key-error.ts","../node_modules/@ai-sdk/google/node_modules/@ai-sdk/provider/src/errors/load-setting-error.ts","../node_modules/@ai-sdk/google/node_modules/@ai-sdk/provider/src/errors/no-content-generated-error.ts","../node_modules/@ai-sdk/google/node_modules/@ai-sdk/provider/src/errors/no-such-model-error.ts","../node_modules/@ai-sdk/google/node_modules/@ai-sdk/provider/src/errors/too-many-embedding-values-for-call-error.ts","../node_modules/@ai-sdk/google/node_modules/@ai-sdk/provider/src/errors/type-validation-error.ts","../node_modules/@ai-sdk/google/node_modules/@ai-sdk/provider/src/errors/unsupported-functionality-error.ts","../node_modules/@ai-sdk/google/node_modules/@ai-sdk/provider/src/json-value/is-json.ts","../node_modules/@ai-sdk/google/node_modules/@ai-sdk/provider-utils/src/combine-headers.ts","../node_modules/@ai-sdk/google/node_modules/@ai-sdk/provider-utils/src/convert-async-iterator-to-readable-stream.ts","../node_modules/@ai-sdk/google/node_modules/@ai-sdk/provider-utils/src/delay.ts","../node_modules/@ai-sdk/google/node_modules/@ai-sdk/provider-utils/src/event-source-parser-stream.ts","../node_modules/@ai-sdk/google/node_modules/@ai-sdk/provider-utils/src/extract-response-headers.ts","../node_modules/@ai-sdk/google/node_modules/@ai-sdk/provider-utils/src/generate-id.ts","../node_modules/@ai-sdk/google/node_modules/@ai-sdk/provider-utils/src/get-error-message.ts","../node_modules/@ai-sdk/google/node_modules/@ai-sdk/provider-utils/src/get-from-api.ts","../node_modules/@ai-sdk/google/node_modules/@ai-sdk/provider-utils/src/remove-undefined-entries.ts","../node_modules/@ai-sdk/google/node_modules/@ai-sdk/provider-utils/src/is-abort-error.ts","../node_modules/@ai-sdk/google/node_modules/@ai-sdk/provider-utils/src/load-api-key.ts","../node_modules/@ai-sdk/google/node_modules/@ai-sdk/provider-utils/src/load-optional-setting.ts","../node_modules/@ai-sdk/google/node_modules/@ai-sdk/provider-utils/src/load-setting.ts","../node_modules/@ai-sdk/google/node_modules/@ai-sdk/provider-utils/src/parse-json.ts","../node_modules/@ai-sdk/google/node_modules/@ai-sdk/provider-utils/src/validate-types.ts","../node_modules/@ai-sdk/google/node_modules/@ai-sdk/provider-utils/src/validator.ts","../node_modules/@ai-sdk/google/node_modules/@ai-sdk/provider-utils/src/parse-provider-options.ts","../node_modules/@ai-sdk/google/node_modules/@ai-sdk/provider-utils/src/post-to-api.ts","../node_modules/@ai-sdk/google/node_modules/@ai-sdk/provider-utils/src/resolve.ts","../node_modules/@ai-sdk/google/node_modules/@ai-sdk/provider-utils/src/response-handler.ts","../node_modules/@ai-sdk/google/node_modules/@ai-sdk/provider-utils/src/uint8-utils.ts","../node_modules/@ai-sdk/google/node_modules/@ai-sdk/provider-utils/src/without-trailing-slash.ts","../node_modules/@ai-sdk/google/src/google-provider.ts","../node_modules/@ai-sdk/google/src/google-generative-ai-language-model.ts","../node_modules/@ai-sdk/google/src/convert-json-schema-to-openapi-schema.ts","../node_modules/@ai-sdk/google/src/convert-to-google-generative-ai-messages.ts","../node_modules/@ai-sdk/google/src/get-model-path.ts","../node_modules/@ai-sdk/google/src/google-error.ts","../node_modules/@ai-sdk/google/src/google-prepare-tools.ts","../node_modules/@ai-sdk/google/src/map-google-generative-ai-finish-reason.ts","../node_modules/@ai-sdk/google/src/google-generative-ai-embedding-model.ts","../node_modules/@ai-sdk/google/src/google-supported-file-url.ts","../agent/model-provider.ts","../agent/ai-variable-resolver.ts","../document/ast.ts","../document/parser-grammar.ts","../types.ts","../document/grammars/grammar-dsl.ts","../document/grammars/document-grammar.ts","../document/grammars/agent-grammar.ts","../document/grammars/diff-grammar.ts","../document/grammars/index.ts","../document/grammar-compiler.ts","../document/executor.ts","../document/tool-registry.ts","../document/tool-naming.ts","../document/validator.ts","../document/variable-resolution.ts","../document/custom-tool-executor.ts","../document/diff-applier.ts","../document/blocknote-converter.ts","../agent/agent.ts","../agent/memory.ts","../agent/system-prompt.ts","../agent/custom-tools.ts","../agent/response-compressor.ts","../index.ts"],"sourcesContent":["/**\n * Symbol used for identifying AI SDK Error instances.\n * Enables checking if an error is an instance of AISDKError across package versions.\n */\nconst marker = 'vercel.ai.error';\nconst symbol = Symbol.for(marker);\n\n/**\n * Custom error class for AI SDK related errors.\n * @extends Error\n */\nexport class AISDKError extends Error {\n  private readonly [symbol] = true; // used in isInstance\n\n  /**\n   * The underlying cause of the error, if any.\n   */\n  readonly cause?: unknown;\n\n  /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */\n  constructor({\n    name,\n    message,\n    cause,\n  }: {\n    name: string;\n    message: string;\n    cause?: unknown;\n  }) {\n    super(message);\n\n    this.name = name;\n    this.cause = cause;\n  }\n\n  /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */\n  static isInstance(error: unknown): error is AISDKError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  protected static hasMarker(error: unknown, marker: string): boolean {\n    const markerSymbol = Symbol.for(marker);\n    return (\n      error != null &&\n      typeof error === 'object' &&\n      markerSymbol in error &&\n      typeof error[markerSymbol] === 'boolean' &&\n      error[markerSymbol] === true\n    );\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_APICallError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class APICallError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly url: string;\n  readonly requestBodyValues: unknown;\n  readonly statusCode?: number;\n\n  readonly responseHeaders?: Record<string, string>;\n  readonly responseBody?: string;\n\n  readonly isRetryable: boolean;\n  readonly data?: unknown;\n\n  constructor({\n    message,\n    url,\n    requestBodyValues,\n    statusCode,\n    responseHeaders,\n    responseBody,\n    cause,\n    isRetryable = statusCode != null &&\n      (statusCode === 408 || // request timeout\n        statusCode === 409 || // conflict\n        statusCode === 429 || // too many requests\n        statusCode >= 500), // server error\n    data,\n  }: {\n    message: string;\n    url: string;\n    requestBodyValues: unknown;\n    statusCode?: number;\n    responseHeaders?: Record<string, string>;\n    responseBody?: string;\n    cause?: unknown;\n    isRetryable?: boolean;\n    data?: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.url = url;\n    this.requestBodyValues = requestBodyValues;\n    this.statusCode = statusCode;\n    this.responseHeaders = responseHeaders;\n    this.responseBody = responseBody;\n    this.isRetryable = isRetryable;\n    this.data = data;\n  }\n\n  static isInstance(error: unknown): error is APICallError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_EmptyResponseBodyError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class EmptyResponseBodyError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message = 'Empty response body' }: { message?: string } = {}) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is EmptyResponseBodyError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","export function getErrorMessage(error: unknown | undefined) {\n  if (error == null) {\n    return 'unknown error';\n  }\n\n  if (typeof error === 'string') {\n    return error;\n  }\n\n  if (error instanceof Error) {\n    return error.message;\n  }\n\n  return JSON.stringify(error);\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidArgumentError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * A function argument is invalid.\n */\nexport class InvalidArgumentError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly argument: string;\n\n  constructor({\n    message,\n    cause,\n    argument,\n  }: {\n    argument: string;\n    message: string;\n    cause?: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.argument = argument;\n  }\n\n  static isInstance(error: unknown): error is InvalidArgumentError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidPromptError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * A prompt is invalid. This error should be thrown by providers when they cannot\n * process a prompt.\n */\nexport class InvalidPromptError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly prompt: unknown;\n\n  constructor({\n    prompt,\n    message,\n    cause,\n  }: {\n    prompt: unknown;\n    message: string;\n    cause?: unknown;\n  }) {\n    super({ name, message: `Invalid prompt: ${message}`, cause });\n\n    this.prompt = prompt;\n  }\n\n  static isInstance(error: unknown): error is InvalidPromptError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidResponseDataError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * Server returned a response with invalid data content.\n * This should be thrown by providers when they cannot parse the response from the API.\n */\nexport class InvalidResponseDataError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly data: unknown;\n\n  constructor({\n    data,\n    message = `Invalid response data: ${JSON.stringify(data)}.`,\n  }: {\n    data: unknown;\n    message?: string;\n  }) {\n    super({ name, message });\n\n    this.data = data;\n  }\n\n  static isInstance(error: unknown): error is InvalidResponseDataError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\nimport { getErrorMessage } from './get-error-message';\n\nconst name = 'AI_JSONParseError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n// TODO v5: rename to ParseError\nexport class JSONParseError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly text: string;\n\n  constructor({ text, cause }: { text: string; cause: unknown }) {\n    super({\n      name,\n      message:\n        `JSON parsing failed: ` +\n        `Text: ${text}.\\n` +\n        `Error message: ${getErrorMessage(cause)}`,\n      cause,\n    });\n\n    this.text = text;\n  }\n\n  static isInstance(error: unknown): error is JSONParseError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_LoadAPIKeyError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class LoadAPIKeyError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message }: { message: string }) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is LoadAPIKeyError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_LoadSettingError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class LoadSettingError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message }: { message: string }) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is LoadSettingError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_NoContentGeneratedError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\nThrown when the AI provider fails to generate any content.\n */\nexport class NoContentGeneratedError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({\n    message = 'No content generated.',\n  }: { message?: string } = {}) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is NoContentGeneratedError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_NoSuchModelError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class NoSuchModelError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly modelId: string;\n  readonly modelType: 'languageModel' | 'textEmbeddingModel' | 'imageModel';\n\n  constructor({\n    errorName = name,\n    modelId,\n    modelType,\n    message = `No such ${modelType}: ${modelId}`,\n  }: {\n    errorName?: string;\n    modelId: string;\n    modelType: 'languageModel' | 'textEmbeddingModel' | 'imageModel';\n    message?: string;\n  }) {\n    super({ name: errorName, message });\n\n    this.modelId = modelId;\n    this.modelType = modelType;\n  }\n\n  static isInstance(error: unknown): error is NoSuchModelError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_TooManyEmbeddingValuesForCallError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class TooManyEmbeddingValuesForCallError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly provider: string;\n  readonly modelId: string;\n  readonly maxEmbeddingsPerCall: number;\n  readonly values: Array<unknown>;\n\n  constructor(options: {\n    provider: string;\n    modelId: string;\n    maxEmbeddingsPerCall: number;\n    values: Array<unknown>;\n  }) {\n    super({\n      name,\n      message:\n        `Too many values for a single embedding call. ` +\n        `The ${options.provider} model \"${options.modelId}\" can only embed up to ` +\n        `${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`,\n    });\n\n    this.provider = options.provider;\n    this.modelId = options.modelId;\n    this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;\n    this.values = options.values;\n  }\n\n  static isInstance(\n    error: unknown,\n  ): error is TooManyEmbeddingValuesForCallError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\nimport { getErrorMessage } from './get-error-message';\n\nconst name = 'AI_TypeValidationError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class TypeValidationError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly value: unknown;\n\n  constructor({ value, cause }: { value: unknown; cause: unknown }) {\n    super({\n      name,\n      message:\n        `Type validation failed: ` +\n        `Value: ${JSON.stringify(value)}.\\n` +\n        `Error message: ${getErrorMessage(cause)}`,\n      cause,\n    });\n\n    this.value = value;\n  }\n\n  static isInstance(error: unknown): error is TypeValidationError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * Wraps an error into a TypeValidationError.\n   * If the cause is already a TypeValidationError with the same value, it returns the cause.\n   * Otherwise, it creates a new TypeValidationError.\n   *\n   * @param {Object} params - The parameters for wrapping the error.\n   * @param {unknown} params.value - The value that failed validation.\n   * @param {unknown} params.cause - The original error or cause of the validation failure.\n   * @returns {TypeValidationError} A TypeValidationError instance.\n   */\n  static wrap({\n    value,\n    cause,\n  }: {\n    value: unknown;\n    cause: unknown;\n  }): TypeValidationError {\n    return TypeValidationError.isInstance(cause) && cause.value === value\n      ? cause\n      : new TypeValidationError({ value, cause });\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_UnsupportedFunctionalityError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class UnsupportedFunctionalityError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly functionality: string;\n\n  constructor({\n    functionality,\n    message = `'${functionality}' functionality not supported.`,\n  }: {\n    functionality: string;\n    message?: string;\n  }) {\n    super({ name, message });\n    this.functionality = functionality;\n  }\n\n  static isInstance(error: unknown): error is UnsupportedFunctionalityError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { JSONArray, JSONObject, JSONValue } from './json-value';\n\nexport function isJSONValue(value: unknown): value is JSONValue {\n  if (\n    value === null ||\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    typeof value === 'boolean'\n  ) {\n    return true;\n  }\n\n  if (Array.isArray(value)) {\n    return value.every(isJSONValue);\n  }\n\n  if (typeof value === 'object') {\n    return Object.entries(value).every(\n      ([key, val]) => typeof key === 'string' && isJSONValue(val),\n    );\n  }\n\n  return false;\n}\n\nexport function isJSONArray(value: unknown): value is JSONArray {\n  return Array.isArray(value) && value.every(isJSONValue);\n}\n\nexport function isJSONObject(value: unknown): value is JSONObject {\n  return (\n    value != null &&\n    typeof value === 'object' &&\n    Object.entries(value).every(\n      ([key, val]) => typeof key === 'string' && isJSONValue(val),\n    )\n  );\n}\n","let urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nlet customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size | 0\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nlet nanoid = (size = 21) => {\n  let id = ''\n  let i = size | 0\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\nexport { nanoid, customAlphabet }\n","'use strict'\n\nconst hasBuffer = typeof Buffer !== 'undefined'\nconst suspectProtoRx = /\"(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])(?:p|\\\\u0070)(?:r|\\\\u0072)(?:o|\\\\u006[Ff])(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])\"\\s*:/\nconst suspectConstructorRx = /\"(?:c|\\\\u0063)(?:o|\\\\u006[Ff])(?:n|\\\\u006[Ee])(?:s|\\\\u0073)(?:t|\\\\u0074)(?:r|\\\\u0072)(?:u|\\\\u0075)(?:c|\\\\u0063)(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:r|\\\\u0072)\"\\s*:/\n\nfunction _parse (text, reviver, options) {\n  // Normalize arguments\n  if (options == null) {\n    if (reviver !== null && typeof reviver === 'object') {\n      options = reviver\n      reviver = undefined\n    }\n  }\n\n  if (hasBuffer && Buffer.isBuffer(text)) {\n    text = text.toString()\n  }\n\n  // BOM checker\n  if (text && text.charCodeAt(0) === 0xFEFF) {\n    text = text.slice(1)\n  }\n\n  // Parse normally, allowing exceptions\n  const obj = JSON.parse(text, reviver)\n\n  // Ignore null and non-objects\n  if (obj === null || typeof obj !== 'object') {\n    return obj\n  }\n\n  const protoAction = (options && options.protoAction) || 'error'\n  const constructorAction = (options && options.constructorAction) || 'error'\n\n  // options: 'error' (default) / 'remove' / 'ignore'\n  if (protoAction === 'ignore' && constructorAction === 'ignore') {\n    return obj\n  }\n\n  if (protoAction !== 'ignore' && constructorAction !== 'ignore') {\n    if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {\n      return obj\n    }\n  } else if (protoAction !== 'ignore' && constructorAction === 'ignore') {\n    if (suspectProtoRx.test(text) === false) {\n      return obj\n    }\n  } else {\n    if (suspectConstructorRx.test(text) === false) {\n      return obj\n    }\n  }\n\n  // Scan result for proto keys\n  return filter(obj, { protoAction, constructorAction, safe: options && options.safe })\n}\n\nfunction filter (obj, { protoAction = 'error', constructorAction = 'error', safe } = {}) {\n  let next = [obj]\n\n  while (next.length) {\n    const nodes = next\n    next = []\n\n    for (const node of nodes) {\n      if (protoAction !== 'ignore' && Object.prototype.hasOwnProperty.call(node, '__proto__')) { // Avoid calling node.hasOwnProperty directly\n        if (safe === true) {\n          return null\n        } else if (protoAction === 'error') {\n          throw new SyntaxError('Object contains forbidden prototype property')\n        }\n\n        delete node.__proto__ // eslint-disable-line no-proto\n      }\n\n      if (constructorAction !== 'ignore' &&\n          Object.prototype.hasOwnProperty.call(node, 'constructor') &&\n          Object.prototype.hasOwnProperty.call(node.constructor, 'prototype')) { // Avoid calling node.hasOwnProperty directly\n        if (safe === true) {\n          return null\n        } else if (constructorAction === 'error') {\n          throw new SyntaxError('Object contains forbidden prototype property')\n        }\n\n        delete node.constructor\n      }\n\n      for (const key in node) {\n        const value = node[key]\n        if (value && typeof value === 'object') {\n          next.push(value)\n        }\n      }\n    }\n  }\n  return obj\n}\n\nfunction parse (text, reviver, options) {\n  const stackTraceLimit = Error.stackTraceLimit\n  Error.stackTraceLimit = 0\n  try {\n    return _parse(text, reviver, options)\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit\n  }\n}\n\nfunction safeParse (text, reviver) {\n  const stackTraceLimit = Error.stackTraceLimit\n  Error.stackTraceLimit = 0\n  try {\n    return _parse(text, reviver, { safe: true })\n  } catch (_e) {\n    return null\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit\n  }\n}\n\nmodule.exports = parse\nmodule.exports.default = parse\nmodule.exports.parse = parse\nmodule.exports.safeParse = safeParse\nmodule.exports.scan = filter\n","export function combineHeaders(\n  ...headers: Array<Record<string, string | undefined> | undefined>\n): Record<string, string | undefined> {\n  return headers.reduce(\n    (combinedHeaders, currentHeaders) => ({\n      ...combinedHeaders,\n      ...(currentHeaders ?? {}),\n    }),\n    {},\n  ) as Record<string, string | undefined>;\n}\n","/**\n * Converts an AsyncIterator to a ReadableStream.\n *\n * @template T - The type of elements produced by the AsyncIterator.\n * @param { <T>} iterator - The AsyncIterator to convert.\n * @returns {ReadableStream<T>} - A ReadableStream that provides the same data as the AsyncIterator.\n */\nexport function convertAsyncIteratorToReadableStream<T>(\n  iterator: AsyncIterator<T>,\n): ReadableStream<T> {\n  return new ReadableStream<T>({\n    /**\n     * Called when the consumer wants to pull more data from the stream.\n     *\n     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.\n     * @returns {Promise<void>}\n     */\n    async pull(controller) {\n      try {\n        const { value, done } = await iterator.next();\n        if (done) {\n          controller.close();\n        } else {\n          controller.enqueue(value);\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    /**\n     * Called when the consumer cancels the stream.\n     */\n    cancel() {},\n  });\n}\n","/**\n * Creates a Promise that resolves after a specified delay\n * @param delayInMs - The delay duration in milliseconds. If null or undefined, resolves immediately.\n * @returns A Promise that resolves after the specified delay\n */\nexport async function delay(delayInMs?: number | null): Promise<void> {\n  return delayInMs == null\n    ? Promise.resolve()\n    : new Promise(resolve => setTimeout(resolve, delayInMs));\n}\n","export type EventSourceChunk = {\n  event: string | undefined;\n  data: string;\n  id?: string;\n  retry?: number;\n};\n\nexport function createEventSourceParserStream() {\n  let buffer = '';\n  let event: string | undefined = undefined;\n  let data: string[] = [];\n  let lastEventId: string | undefined = undefined;\n  let retry: number | undefined = undefined;\n\n  function parseLine(\n    line: string,\n    controller: TransformStreamDefaultController<EventSourceChunk>,\n  ) {\n    // Empty line means dispatch the event\n    if (line === '') {\n      dispatchEvent(controller);\n      return;\n    }\n\n    // Comments start with colon\n    if (line.startsWith(':')) {\n      return;\n    }\n\n    // Field parsing\n    const colonIndex = line.indexOf(':');\n    if (colonIndex === -1) {\n      // field with no value\n      handleField(line, '');\n      return;\n    }\n\n    const field = line.slice(0, colonIndex);\n    // If there's a space after the colon, it should be ignored\n    const valueStart = colonIndex + 1;\n    const value =\n      valueStart < line.length && line[valueStart] === ' '\n        ? line.slice(valueStart + 1)\n        : line.slice(valueStart);\n\n    handleField(field, value);\n  }\n\n  function dispatchEvent(\n    controller: TransformStreamDefaultController<EventSourceChunk>,\n  ) {\n    if (data.length > 0) {\n      controller.enqueue({\n        event,\n        data: data.join('\\n'),\n        id: lastEventId,\n        retry,\n      });\n\n      // Reset data but keep lastEventId as per spec\n      data = [];\n      event = undefined;\n      retry = undefined;\n    }\n  }\n\n  function handleField(field: string, value: string) {\n    switch (field) {\n      case 'event':\n        event = value;\n        break;\n      case 'data':\n        data.push(value);\n        break;\n      case 'id':\n        lastEventId = value;\n        break;\n      case 'retry':\n        const parsedRetry = parseInt(value, 10);\n        if (!isNaN(parsedRetry)) {\n          retry = parsedRetry;\n        }\n        break;\n    }\n  }\n\n  return new TransformStream<string, EventSourceChunk>({\n    transform(chunk, controller) {\n      const { lines, incompleteLine } = splitLines(buffer, chunk);\n\n      buffer = incompleteLine;\n\n      // using for loop for performance\n      for (let i = 0; i < lines.length; i++) {\n        parseLine(lines[i], controller);\n      }\n    },\n\n    flush(controller) {\n      parseLine(buffer, controller);\n      dispatchEvent(controller);\n    },\n  });\n}\n\n// performance: send in already scanned buffer separately, do not scan again\nfunction splitLines(buffer: string, chunk: string) {\n  const lines: Array<string> = [];\n  let currentLine = buffer;\n\n  // using for loop for performance\n  for (let i = 0; i < chunk.length; ) {\n    const char = chunk[i++];\n\n    // order is performance-optimized\n    if (char === '\\n') {\n      // Standalone LF\n      lines.push(currentLine);\n      currentLine = '';\n    } else if (char === '\\r') {\n      lines.push(currentLine);\n      currentLine = '';\n      if (chunk[i] === '\\n') {\n        i++; // CRLF case: Skip the LF character\n      }\n    } else {\n      currentLine += char;\n    }\n  }\n\n  return { lines, incompleteLine: currentLine };\n}\n","/**\nExtracts the headers from a response object and returns them as a key-value object.\n\n@param response - The response object to extract headers from.\n@returns The headers as a key-value object.\n*/\nexport function extractResponseHeaders(\n  response: Response,\n): Record<string, string> {\n  const headers: Record<string, string> = {};\n  response.headers.forEach((value, key) => {\n    headers[key] = value;\n  });\n  return headers;\n}\n","import { InvalidArgumentError } from '@ai-sdk/provider';\nimport { customAlphabet } from 'nanoid/non-secure';\n\n/**\nCreates an ID generator.\nThe total length of the ID is the sum of the prefix, separator, and random part length.\nNon-secure.\n\n@param alphabet - The alphabet to use for the ID. Default: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.\n@param prefix - The prefix of the ID to generate. Default: ''.\n@param separator - The separator between the prefix and the random part of the ID. Default: '-'.\n@param size - The size of the random part of the ID to generate. Default: 16.\n */\n// TODO 5.0 breaking change: change the return type to IDGenerator\nexport const createIdGenerator = ({\n  prefix,\n  size: defaultSize = 16,\n  alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n  separator = '-',\n}: {\n  prefix?: string;\n  separator?: string;\n  size?: number;\n  alphabet?: string;\n} = {}): ((size?: number) => string) => {\n  const generator = customAlphabet(alphabet, defaultSize);\n\n  if (prefix == null) {\n    return generator;\n  }\n\n  // check that the prefix is not part of the alphabet (otherwise prefix checking can fail randomly)\n  if (alphabet.includes(separator)) {\n    throw new InvalidArgumentError({\n      argument: 'separator',\n      message: `The separator \"${separator}\" must not be part of the alphabet \"${alphabet}\".`,\n    });\n  }\n\n  return size => `${prefix}${separator}${generator(size)}`;\n};\n\n/**\nA function that generates an ID.\n */\nexport type IDGenerator = () => string;\n\n/**\nGenerates a 16-character random string to use for IDs. Not secure.\n\n@param size - The size of the ID to generate. Default: 16.\n */\nexport const generateId = createIdGenerator();\n","export function getErrorMessage(error: unknown | undefined) {\n  if (error == null) {\n    return 'unknown error';\n  }\n\n  if (typeof error === 'string') {\n    return error;\n  }\n\n  if (error instanceof Error) {\n    return error.message;\n  }\n\n  return JSON.stringify(error);\n}\n","import { APICallError } from '@ai-sdk/provider';\nimport { FetchFunction } from './fetch-function';\nimport { removeUndefinedEntries } from './remove-undefined-entries';\nimport { ResponseHandler } from './response-handler';\nimport { isAbortError } from './is-abort-error';\nimport { extractResponseHeaders } from './extract-response-headers';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => globalThis.fetch;\n\nexport const getFromApi = async <T>({\n  url,\n  headers = {},\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch(),\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  failedResponseHandler: ResponseHandler<Error>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: 'GET',\n      headers: removeUndefinedEntries(headers),\n      signal: abortSignal,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.ok) {\n      let errorInformation: {\n        value: Error;\n        responseHeaders?: Record<string, string> | undefined;\n      };\n\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: {},\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n\n        throw new APICallError({\n          message: 'Failed to process error response',\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: {},\n        });\n      }\n\n      throw errorInformation.value;\n    }\n\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: {},\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n\n      throw new APICallError({\n        message: 'Failed to process successful response',\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: {},\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n\n    if (error instanceof TypeError && error.message === 'fetch failed') {\n      const cause = (error as any).cause;\n      if (cause != null) {\n        throw new APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          isRetryable: true,\n          requestBodyValues: {},\n        });\n      }\n    }\n\n    throw error;\n  }\n};\n","/**\n * Removes entries from a record where the value is null or undefined.\n * @param record - The input object whose entries may be null or undefined.\n * @returns A new object containing only entries with non-null and non-undefined values.\n */\nexport function removeUndefinedEntries<T>(\n  record: Record<string, T | undefined>,\n): Record<string, T> {\n  return Object.fromEntries(\n    Object.entries(record).filter(([_key, value]) => value != null),\n  ) as Record<string, T>;\n}\n","export function isAbortError(error: unknown): error is Error {\n  return (\n    error instanceof Error &&\n    (error.name === 'AbortError' || error.name === 'TimeoutError')\n  );\n}\n","import { LoadAPIKeyError } from '@ai-sdk/provider';\n\nexport function loadApiKey({\n  apiKey,\n  environmentVariableName,\n  apiKeyParameterName = 'apiKey',\n  description,\n}: {\n  apiKey: string | undefined;\n  environmentVariableName: string;\n  apiKeyParameterName?: string;\n  description: string;\n}): string {\n  if (typeof apiKey === 'string') {\n    return apiKey;\n  }\n\n  if (apiKey != null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string.`,\n    });\n  }\n\n  if (typeof process === 'undefined') {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`,\n    });\n  }\n\n  apiKey = process.env[environmentVariableName];\n\n  if (apiKey == null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`,\n    });\n  }\n\n  if (typeof apiKey !== 'string') {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`,\n    });\n  }\n\n  return apiKey;\n}\n","/**\n * Loads an optional `string` setting from the environment or a parameter.\n *\n * @param settingValue - The setting value.\n * @param environmentVariableName - The environment variable name.\n * @returns The setting value.\n */\nexport function loadOptionalSetting({\n  settingValue,\n  environmentVariableName,\n}: {\n  settingValue: string | undefined;\n  environmentVariableName: string;\n}): string | undefined {\n  if (typeof settingValue === 'string') {\n    return settingValue;\n  }\n\n  if (settingValue != null || typeof process === 'undefined') {\n    return undefined;\n  }\n\n  settingValue = process.env[environmentVariableName];\n\n  if (settingValue == null || typeof settingValue !== 'string') {\n    return undefined;\n  }\n\n  return settingValue;\n}\n","import { LoadSettingError } from '@ai-sdk/provider';\n\n/**\n * Loads a `string` setting from the environment or a parameter.\n *\n * @param settingValue - The setting value.\n * @param environmentVariableName - The environment variable name.\n * @param settingName - The setting name.\n * @param description - The description of the setting.\n * @returns The setting value.\n */\nexport function loadSetting({\n  settingValue,\n  environmentVariableName,\n  settingName,\n  description,\n}: {\n  settingValue: string | undefined;\n  environmentVariableName: string;\n  settingName: string;\n  description: string;\n}): string {\n  if (typeof settingValue === 'string') {\n    return settingValue;\n  }\n\n  if (settingValue != null) {\n    throw new LoadSettingError({\n      message: `${description} setting must be a string.`,\n    });\n  }\n\n  if (typeof process === 'undefined') {\n    throw new LoadSettingError({\n      message:\n        `${description} setting is missing. ` +\n        `Pass it using the '${settingName}' parameter. ` +\n        `Environment variables is not supported in this environment.`,\n    });\n  }\n\n  settingValue = process.env[environmentVariableName];\n\n  if (settingValue == null) {\n    throw new LoadSettingError({\n      message:\n        `${description} setting is missing. ` +\n        `Pass it using the '${settingName}' parameter ` +\n        `or the ${environmentVariableName} environment variable.`,\n    });\n  }\n\n  if (typeof settingValue !== 'string') {\n    throw new LoadSettingError({\n      message:\n        `${description} setting must be a string. ` +\n        `The value of the ${environmentVariableName} environment variable is not a string.`,\n    });\n  }\n\n  return settingValue;\n}\n","import {\n  JSONParseError,\n  JSONValue,\n  TypeValidationError,\n} from '@ai-sdk/provider';\nimport SecureJSON from 'secure-json-parse';\nimport { ZodSchema } from 'zod';\nimport { safeValidateTypes, validateTypes } from './validate-types';\nimport { Validator } from './validator';\n\n/**\n * Parses a JSON string into an unknown object.\n *\n * @param text - The JSON string to parse.\n * @returns {JSONValue} - The parsed JSON object.\n */\nexport function parseJSON(options: {\n  text: string;\n  schema?: undefined;\n}): JSONValue;\n/**\n * Parses a JSON string into a strongly-typed object using the provided schema.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Validator<T>} schema - The schema to use for parsing the JSON.\n * @returns {T} - The parsed object.\n */\nexport function parseJSON<T>(options: {\n  text: string;\n  schema: ZodSchema<T> | Validator<T>;\n}): T;\nexport function parseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: ZodSchema<T> | Validator<T>;\n}): T {\n  try {\n    const value = SecureJSON.parse(text);\n\n    if (schema == null) {\n      return value;\n    }\n\n    return validateTypes({ value, schema });\n  } catch (error) {\n    if (\n      JSONParseError.isInstance(error) ||\n      TypeValidationError.isInstance(error)\n    ) {\n      throw error;\n    }\n\n    throw new JSONParseError({ text, cause: error });\n  }\n}\n\nexport type ParseResult<T> =\n  | { success: true; value: T; rawValue: unknown }\n  | { success: false; error: JSONParseError | TypeValidationError };\n\n/**\n * Safely parses a JSON string and returns the result as an object of type `unknown`.\n *\n * @param text - The JSON string to parse.\n * @returns {object} Either an object with `success: true` and the parsed data, or an object with `success: false` and the error that occurred.\n */\nexport function safeParseJSON(options: {\n  text: string;\n  schema?: undefined;\n}): ParseResult<JSONValue>;\n/**\n * Safely parses a JSON string into a strongly-typed object, using a provided schema to validate the object.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Validator<T>} schema - The schema to use for parsing the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport function safeParseJSON<T>(options: {\n  text: string;\n  schema: ZodSchema<T> | Validator<T>;\n}): ParseResult<T>;\nexport function safeParseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: ZodSchema<T> | Validator<T>;\n}): ParseResult<T> {\n  try {\n    const value = SecureJSON.parse(text);\n\n    if (schema == null) {\n      return { success: true, value: value as T, rawValue: value };\n    }\n\n    const validationResult = safeValidateTypes({ value, schema });\n\n    return validationResult.success\n      ? { ...validationResult, rawValue: value }\n      : validationResult;\n  } catch (error) {\n    return {\n      success: false,\n      error: JSONParseError.isInstance(error)\n        ? error\n        : new JSONParseError({ text, cause: error }),\n    };\n  }\n}\n\nexport function isParsableJson(input: string): boolean {\n  try {\n    SecureJSON.parse(input);\n    return true;\n  } catch {\n    return false;\n  }\n}\n","import { TypeValidationError } from '@ai-sdk/provider';\nimport { z } from 'zod';\nimport { Validator, asValidator } from './validator';\n\n/**\n * Validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The object to validate.\n * @param {Validator<T>} options.schema - The schema to use for validating the JSON.\n * @returns {T} - The typed object.\n */\nexport function validateTypes<T>({\n  value,\n  schema: inputSchema,\n}: {\n  value: unknown;\n  schema: z.Schema<T, z.ZodTypeDef, any> | Validator<T>;\n}): T {\n  const result = safeValidateTypes({ value, schema: inputSchema });\n\n  if (!result.success) {\n    throw TypeValidationError.wrap({ value, cause: result.error });\n  }\n\n  return result.value;\n}\n\n/**\n * Safely validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The JSON object to validate.\n * @param {Validator<T>} options.schema - The schema to use for validating the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport function safeValidateTypes<T>({\n  value,\n  schema,\n}: {\n  value: unknown;\n  schema: z.Schema<T, z.ZodTypeDef, any> | Validator<T>;\n}):\n  | { success: true; value: T }\n  | { success: false; error: TypeValidationError } {\n  const validator = asValidator(schema);\n\n  try {\n    if (validator.validate == null) {\n      return { success: true, value: value as T };\n    }\n\n    const result = validator.validate(value);\n\n    if (result.success) {\n      return result;\n    }\n\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: result.error }),\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: error }),\n    };\n  }\n}\n","import { z } from 'zod';\n\n/**\n * Used to mark validator functions so we can support both Zod and custom schemas.\n */\nexport const validatorSymbol = Symbol.for('vercel.ai.validator');\n\nexport type ValidationResult<OBJECT> =\n  | { success: true; value: OBJECT }\n  | { success: false; error: Error };\n\nexport type Validator<OBJECT = unknown> = {\n  /**\n   * Used to mark validator functions so we can support both Zod and custom schemas.\n   */\n  [validatorSymbol]: true;\n\n  /**\n   * Optional. Validates that the structure of a value matches this schema,\n   * and returns a typed version of the value if it does.\n   */\n  readonly validate?: (value: unknown) => ValidationResult<OBJECT>;\n};\n\n/**\n * Create a validator.\n *\n * @param validate A validation function for the schema.\n */\nexport function validator<OBJECT>(\n  validate?: undefined | ((value: unknown) => ValidationResult<OBJECT>),\n): Validator<OBJECT> {\n  return { [validatorSymbol]: true, validate };\n}\n\nexport function isValidator(value: unknown): value is Validator {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    validatorSymbol in value &&\n    value[validatorSymbol] === true &&\n    'validate' in value\n  );\n}\n\nexport function asValidator<OBJECT>(\n  value: Validator<OBJECT> | z.Schema<OBJECT, z.ZodTypeDef, any>,\n): Validator<OBJECT> {\n  return isValidator(value) ? value : zodValidator(value);\n}\n\nexport function zodValidator<OBJECT>(\n  zodSchema: z.Schema<OBJECT, z.ZodTypeDef, any>,\n): Validator<OBJECT> {\n  return validator(value => {\n    const result = zodSchema.safeParse(value);\n    return result.success\n      ? { success: true, value: result.data }\n      : { success: false, error: result.error };\n  });\n}\n","import { InvalidArgumentError } from '@ai-sdk/provider';\nimport { safeValidateTypes } from './validate-types';\nimport { z } from 'zod';\n\nexport function parseProviderOptions<T>({\n  provider,\n  providerOptions,\n  schema,\n}: {\n  provider: string;\n  providerOptions: Record<string, unknown> | undefined;\n  schema: z.ZodSchema<T>;\n}): T | undefined {\n  if (providerOptions?.[provider] == null) {\n    return undefined;\n  }\n\n  const parsedProviderOptions = safeValidateTypes({\n    value: providerOptions[provider],\n    schema,\n  });\n\n  if (!parsedProviderOptions.success) {\n    throw new InvalidArgumentError({\n      argument: 'providerOptions',\n      message: `invalid ${provider} provider options`,\n      cause: parsedProviderOptions.error,\n    });\n  }\n\n  return parsedProviderOptions.value;\n}\n","import { APICallError } from '@ai-sdk/provider';\nimport { extractResponseHeaders } from './extract-response-headers';\nimport { FetchFunction } from './fetch-function';\nimport { isAbortError } from './is-abort-error';\nimport { removeUndefinedEntries } from './remove-undefined-entries';\nimport { ResponseHandler } from './response-handler';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => globalThis.fetch;\n\nexport const postJsonToApi = async <T>({\n  url,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch,\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  body: unknown;\n  failedResponseHandler: ResponseHandler<APICallError>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) =>\n  postToApi({\n    url,\n    headers: {\n      'Content-Type': 'application/json',\n      ...headers,\n    },\n    body: {\n      content: JSON.stringify(body),\n      values: body,\n    },\n    failedResponseHandler,\n    successfulResponseHandler,\n    abortSignal,\n    fetch,\n  });\n\nexport const postFormDataToApi = async <T>({\n  url,\n  headers,\n  formData,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch,\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  formData: FormData;\n  failedResponseHandler: ResponseHandler<APICallError>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) =>\n  postToApi({\n    url,\n    headers,\n    body: {\n      content: formData,\n      values: Object.fromEntries((formData as any).entries()),\n    },\n    failedResponseHandler,\n    successfulResponseHandler,\n    abortSignal,\n    fetch,\n  });\n\nexport const postToApi = async <T>({\n  url,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch(),\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  body: {\n    content: string | FormData | Uint8Array;\n    values: unknown;\n  };\n  failedResponseHandler: ResponseHandler<Error>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: removeUndefinedEntries(headers),\n      body: body.content,\n      signal: abortSignal,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.ok) {\n      let errorInformation: {\n        value: Error;\n        responseHeaders?: Record<string, string> | undefined;\n      };\n\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: body.values,\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n\n        throw new APICallError({\n          message: 'Failed to process error response',\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: body.values,\n        });\n      }\n\n      throw errorInformation.value;\n    }\n\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: body.values,\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n\n      throw new APICallError({\n        message: 'Failed to process successful response',\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: body.values,\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n\n    // unwrap original error when fetch failed (for easier debugging):\n    if (error instanceof TypeError && error.message === 'fetch failed') {\n      const cause = (error as any).cause;\n\n      if (cause != null) {\n        // Failed to connect to server:\n        throw new APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          requestBodyValues: body.values,\n          isRetryable: true, // retry when network error\n        });\n      }\n    }\n\n    throw error;\n  }\n};\n","export type Resolvable<T> =\n  | T // Raw value\n  | Promise<T> // Promise of value\n  | (() => T) // Function returning value\n  | (() => Promise<T>); // Function returning promise of value\n\n/**\n * Resolves a value that could be a raw value, a Promise, a function returning a value,\n * or a function returning a Promise.\n */\nexport async function resolve<T>(value: Resolvable<T>): Promise<T> {\n  // If it's a function, call it to get the value/promise\n  if (typeof value === 'function') {\n    value = (value as Function)();\n  }\n\n  // Otherwise just resolve whatever we got (value or promise)\n  return Promise.resolve(value as T);\n}\n","import { APICallError, EmptyResponseBodyError } from '@ai-sdk/provider';\nimport { ZodSchema } from 'zod';\nimport {\n  createEventSourceParserStream,\n  EventSourceChunk,\n} from './event-source-parser-stream';\nimport { extractResponseHeaders } from './extract-response-headers';\nimport { parseJSON, ParseResult, safeParseJSON } from './parse-json';\n\nexport type ResponseHandler<RETURN_TYPE> = (options: {\n  url: string;\n  requestBodyValues: unknown;\n  response: Response;\n}) => PromiseLike<{\n  value: RETURN_TYPE;\n  rawValue?: unknown;\n  responseHeaders?: Record<string, string>;\n}>;\n\nexport const createJsonErrorResponseHandler =\n  <T>({\n    errorSchema,\n    errorToMessage,\n    isRetryable,\n  }: {\n    errorSchema: ZodSchema<T>;\n    errorToMessage: (error: T) => string;\n    isRetryable?: (response: Response, error?: T) => boolean;\n  }): ResponseHandler<APICallError> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseBody = await response.text();\n    const responseHeaders = extractResponseHeaders(response);\n\n    // Some providers return an empty response body for some errors:\n    if (responseBody.trim() === '') {\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: response.statusText,\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          isRetryable: isRetryable?.(response),\n        }),\n      };\n    }\n\n    // resilient parsing in case the response is not JSON or does not match the schema:\n    try {\n      const parsedError = parseJSON({\n        text: responseBody,\n        schema: errorSchema,\n      });\n\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: errorToMessage(parsedError),\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          data: parsedError,\n          isRetryable: isRetryable?.(response, parsedError),\n        }),\n      };\n    } catch (parseError) {\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: response.statusText,\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          isRetryable: isRetryable?.(response),\n        }),\n      };\n    }\n  };\n\nexport const createEventSourceResponseHandler =\n  <T>(\n    chunkSchema: ZodSchema<T>,\n  ): ResponseHandler<ReadableStream<ParseResult<T>>> =>\n  async ({ response }: { response: Response }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (response.body == null) {\n      throw new EmptyResponseBodyError({});\n    }\n\n    return {\n      responseHeaders,\n      value: response.body\n        .pipeThrough(new TextDecoderStream())\n        .pipeThrough(createEventSourceParserStream())\n        .pipeThrough(\n          new TransformStream<EventSourceChunk, ParseResult<T>>({\n            transform({ data }, controller) {\n              // ignore the 'DONE' event that e.g. OpenAI sends:\n              if (data === '[DONE]') {\n                return;\n              }\n\n              controller.enqueue(\n                safeParseJSON({\n                  text: data,\n                  schema: chunkSchema,\n                }),\n              );\n            },\n          }),\n        ),\n    };\n  };\n\nexport const createJsonStreamResponseHandler =\n  <T>(\n    chunkSchema: ZodSchema<T>,\n  ): ResponseHandler<ReadableStream<ParseResult<T>>> =>\n  async ({ response }: { response: Response }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (response.body == null) {\n      throw new EmptyResponseBodyError({});\n    }\n\n    let buffer = '';\n\n    return {\n      responseHeaders,\n      value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(\n        new TransformStream<string, ParseResult<T>>({\n          transform(chunkText, controller) {\n            if (chunkText.endsWith('\\n')) {\n              controller.enqueue(\n                safeParseJSON({\n                  text: buffer + chunkText,\n                  schema: chunkSchema,\n                }),\n              );\n              buffer = '';\n            } else {\n              buffer += chunkText;\n            }\n          },\n        }),\n      ),\n    };\n  };\n\nexport const createJsonResponseHandler =\n  <T>(responseSchema: ZodSchema<T>): ResponseHandler<T> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseBody = await response.text();\n\n    const parsedResult = safeParseJSON({\n      text: responseBody,\n      schema: responseSchema,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!parsedResult.success) {\n      throw new APICallError({\n        message: 'Invalid JSON response',\n        cause: parsedResult.error,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        url,\n        requestBodyValues,\n      });\n    }\n\n    return {\n      responseHeaders,\n      value: parsedResult.value,\n      rawValue: parsedResult.rawValue,\n    };\n  };\n\nexport const createBinaryResponseHandler =\n  (): ResponseHandler<Uint8Array> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.body) {\n      throw new APICallError({\n        message: 'Response body is empty',\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody: undefined,\n      });\n    }\n\n    try {\n      const buffer = await response.arrayBuffer();\n      return {\n        responseHeaders,\n        value: new Uint8Array(buffer),\n      };\n    } catch (error) {\n      throw new APICallError({\n        message: 'Failed to read response as array buffer',\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody: undefined,\n        cause: error,\n      });\n    }\n  };\n\nexport const createStatusCodeErrorResponseHandler =\n  (): ResponseHandler<APICallError> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseHeaders = extractResponseHeaders(response);\n    const responseBody = await response.text();\n\n    return {\n      responseHeaders,\n      value: new APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues: requestBodyValues as Record<string, unknown>,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n      }),\n    };\n  };\n","// btoa and atob need to be invoked as a function call, not as a method call.\n// Otherwise CloudFlare will throw a\n// \"TypeError: Illegal invocation: function called with incorrect this reference\"\nconst { btoa, atob } = globalThis;\n\nexport function convertBase64ToUint8Array(base64String: string) {\n  const base64Url = base64String.replace(/-/g, '+').replace(/_/g, '/');\n  const latin1string = atob(base64Url);\n  return Uint8Array.from(latin1string, byte => byte.codePointAt(0)!);\n}\n\nexport function convertUint8ArrayToBase64(array: Uint8Array): string {\n  let latin1string = '';\n\n  // Note: regular for loop to support older JavaScript versions that\n  // do not support for..of on Uint8Array\n  for (let i = 0; i < array.length; i++) {\n    latin1string += String.fromCodePoint(array[i]);\n  }\n\n  return btoa(latin1string);\n}\n","export function withoutTrailingSlash(url: string | undefined) {\n  return url?.replace(/\\/$/, '');\n}\n","import {\n  InvalidResponseDataError,\n  LanguageModelV1,\n  LanguageModelV1CallWarning,\n  LanguageModelV1FinishReason,\n  LanguageModelV1LogProbs,\n  LanguageModelV1ProviderMetadata,\n  LanguageModelV1StreamPart,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport {\n  FetchFunction,\n  ParseResult,\n  combineHeaders,\n  createEventSourceResponseHandler,\n  createJsonResponseHandler,\n  generateId,\n  isParsableJson,\n  postJsonToApi,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\nimport { convertToOpenAIChatMessages } from './convert-to-openai-chat-messages';\nimport { mapOpenAIChatLogProbsOutput } from './map-openai-chat-logprobs';\nimport { mapOpenAIFinishReason } from './map-openai-finish-reason';\nimport { OpenAIChatModelId, OpenAIChatSettings } from './openai-chat-settings';\nimport {\n  openaiErrorDataSchema,\n  openaiFailedResponseHandler,\n} from './openai-error';\nimport { getResponseMetadata } from './get-response-metadata';\nimport { prepareTools } from './openai-prepare-tools';\n\ntype OpenAIChatConfig = {\n  provider: string;\n  compatibility: 'strict' | 'compatible';\n  headers: () => Record<string, string | undefined>;\n  url: (options: { modelId: string; path: string }) => string;\n  fetch?: FetchFunction;\n};\n\nexport class OpenAIChatLanguageModel implements LanguageModelV1 {\n  readonly specificationVersion = 'v1';\n\n  readonly modelId: OpenAIChatModelId;\n  readonly settings: OpenAIChatSettings;\n\n  private readonly config: OpenAIChatConfig;\n\n  constructor(\n    modelId: OpenAIChatModelId,\n    settings: OpenAIChatSettings,\n    config: OpenAIChatConfig,\n  ) {\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n  }\n\n  get supportsStructuredOutputs(): boolean {\n    // enable structured outputs for reasoning models by default:\n    // TODO in the next major version, remove this and always use json mode for models\n    // that support structured outputs (blacklist other models)\n    return this.settings.structuredOutputs ?? isReasoningModel(this.modelId);\n  }\n\n  get defaultObjectGenerationMode() {\n    // audio models don't support structured outputs:\n    if (isAudioModel(this.modelId)) {\n      return 'tool';\n    }\n\n    return this.supportsStructuredOutputs ? 'json' : 'tool';\n  }\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  get supportsImageUrls(): boolean {\n    // image urls can be sent if downloadImages is disabled (default):\n    return !this.settings.downloadImages;\n  }\n\n  private getArgs({\n    mode,\n    prompt,\n    maxTokens,\n    temperature,\n    topP,\n    topK,\n    frequencyPenalty,\n    presencePenalty,\n    stopSequences,\n    responseFormat,\n    seed,\n    providerMetadata,\n  }: Parameters<LanguageModelV1['doGenerate']>[0]) {\n    const type = mode.type;\n\n    const warnings: LanguageModelV1CallWarning[] = [];\n\n    if (topK != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'topK',\n      });\n    }\n\n    if (\n      responseFormat?.type === 'json' &&\n      responseFormat.schema != null &&\n      !this.supportsStructuredOutputs\n    ) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'responseFormat',\n        details:\n          'JSON response format schema is only supported with structuredOutputs',\n      });\n    }\n\n    const useLegacyFunctionCalling = this.settings.useLegacyFunctionCalling;\n\n    if (useLegacyFunctionCalling && this.settings.parallelToolCalls === true) {\n      throw new UnsupportedFunctionalityError({\n        functionality: 'useLegacyFunctionCalling with parallelToolCalls',\n      });\n    }\n\n    if (useLegacyFunctionCalling && this.supportsStructuredOutputs) {\n      throw new UnsupportedFunctionalityError({\n        functionality: 'structuredOutputs with useLegacyFunctionCalling',\n      });\n    }\n\n    const { messages, warnings: messageWarnings } = convertToOpenAIChatMessages(\n      {\n        prompt,\n        useLegacyFunctionCalling,\n        systemMessageMode: getSystemMessageMode(this.modelId),\n      },\n    );\n\n    warnings.push(...messageWarnings);\n\n    const baseArgs = {\n      // model id:\n      model: this.modelId,\n\n      // model specific settings:\n      logit_bias: this.settings.logitBias,\n      logprobs:\n        this.settings.logprobs === true ||\n        typeof this.settings.logprobs === 'number'\n          ? true\n          : undefined,\n      top_logprobs:\n        typeof this.settings.logprobs === 'number'\n          ? this.settings.logprobs\n          : typeof this.settings.logprobs === 'boolean'\n            ? this.settings.logprobs\n              ? 0\n              : undefined\n            : undefined,\n      user: this.settings.user,\n      parallel_tool_calls: this.settings.parallelToolCalls,\n\n      // standardized settings:\n      max_tokens: maxTokens,\n      temperature,\n      top_p: topP,\n      frequency_penalty: frequencyPenalty,\n      presence_penalty: presencePenalty,\n      response_format:\n        responseFormat?.type === 'json'\n          ? this.supportsStructuredOutputs && responseFormat.schema != null\n            ? {\n                type: 'json_schema',\n                json_schema: {\n                  schema: responseFormat.schema,\n                  strict: true,\n                  name: responseFormat.name ?? 'response',\n                  description: responseFormat.description,\n                },\n              }\n            : { type: 'json_object' }\n          : undefined,\n      stop: stopSequences,\n      seed,\n\n      // openai specific settings:\n      // TODO remove in next major version; we auto-map maxTokens now\n      max_completion_tokens: providerMetadata?.openai?.maxCompletionTokens,\n      store: providerMetadata?.openai?.store,\n      metadata: providerMetadata?.openai?.metadata,\n      prediction: providerMetadata?.openai?.prediction,\n      reasoning_effort:\n        providerMetadata?.openai?.reasoningEffort ??\n        this.settings.reasoningEffort,\n\n      // messages:\n      messages,\n    };\n\n    if (isReasoningModel(this.modelId)) {\n      // remove unsupported settings for reasoning models\n      // see https://platform.openai.com/docs/guides/reasoning#limitations\n      if (baseArgs.temperature != null) {\n        baseArgs.temperature = undefined;\n        warnings.push({\n          type: 'unsupported-setting',\n          setting: 'temperature',\n          details: 'temperature is not supported for reasoning models',\n        });\n      }\n      if (baseArgs.top_p != null) {\n        baseArgs.top_p = undefined;\n        warnings.push({\n          type: 'unsupported-setting',\n          setting: 'topP',\n          details: 'topP is not supported for reasoning models',\n        });\n      }\n      if (baseArgs.frequency_penalty != null) {\n        baseArgs.frequency_penalty = undefined;\n        warnings.push({\n          type: 'unsupported-setting',\n          setting: 'frequencyPenalty',\n          details: 'frequencyPenalty is not supported for reasoning models',\n        });\n      }\n      if (baseArgs.presence_penalty != null) {\n        baseArgs.presence_penalty = undefined;\n        warnings.push({\n          type: 'unsupported-setting',\n          setting: 'presencePenalty',\n          details: 'presencePenalty is not supported for reasoning models',\n        });\n      }\n      if (baseArgs.logit_bias != null) {\n        baseArgs.logit_bias = undefined;\n        warnings.push({\n          type: 'other',\n          message: 'logitBias is not supported for reasoning models',\n        });\n      }\n      if (baseArgs.logprobs != null) {\n        baseArgs.logprobs = undefined;\n        warnings.push({\n          type: 'other',\n          message: 'logprobs is not supported for reasoning models',\n        });\n      }\n      if (baseArgs.top_logprobs != null) {\n        baseArgs.top_logprobs = undefined;\n        warnings.push({\n          type: 'other',\n          message: 'topLogprobs is not supported for reasoning models',\n        });\n      }\n\n      // reasoning models use max_completion_tokens instead of max_tokens:\n      if (baseArgs.max_tokens != null) {\n        if (baseArgs.max_completion_tokens == null) {\n          baseArgs.max_completion_tokens = baseArgs.max_tokens;\n        }\n        baseArgs.max_tokens = undefined;\n      }\n    } else if (\n      this.modelId.startsWith('gpt-4o-search-preview') ||\n      this.modelId.startsWith('gpt-4o-mini-search-preview')\n    ) {\n      if (baseArgs.temperature != null) {\n        baseArgs.temperature = undefined;\n        warnings.push({\n          type: 'unsupported-setting',\n          setting: 'temperature',\n          details:\n            'temperature is not supported for the search preview models and has been removed.',\n        });\n      }\n    }\n    switch (type) {\n      case 'regular': {\n        const { tools, tool_choice, functions, function_call, toolWarnings } =\n          prepareTools({\n            mode,\n            useLegacyFunctionCalling,\n            structuredOutputs: this.supportsStructuredOutputs,\n          });\n\n        return {\n          args: {\n            ...baseArgs,\n            tools,\n            tool_choice,\n            functions,\n            function_call,\n          },\n          warnings: [...warnings, ...toolWarnings],\n        };\n      }\n\n      case 'object-json': {\n        return {\n          args: {\n            ...baseArgs,\n            response_format:\n              this.supportsStructuredOutputs && mode.schema != null\n                ? {\n                    type: 'json_schema',\n                    json_schema: {\n                      schema: mode.schema,\n                      strict: true,\n                      name: mode.name ?? 'response',\n                      description: mode.description,\n                    },\n                  }\n                : { type: 'json_object' },\n          },\n          warnings,\n        };\n      }\n\n      case 'object-tool': {\n        return {\n          args: useLegacyFunctionCalling\n            ? {\n                ...baseArgs,\n                function_call: {\n                  name: mode.tool.name,\n                },\n                functions: [\n                  {\n                    name: mode.tool.name,\n                    description: mode.tool.description,\n                    parameters: mode.tool.parameters,\n                  },\n                ],\n              }\n            : {\n                ...baseArgs,\n                tool_choice: {\n                  type: 'function',\n                  function: { name: mode.tool.name },\n                },\n                tools: [\n                  {\n                    type: 'function',\n                    function: {\n                      name: mode.tool.name,\n                      description: mode.tool.description,\n                      parameters: mode.tool.parameters,\n                      strict: this.supportsStructuredOutputs ? true : undefined,\n                    },\n                  },\n                ],\n              },\n          warnings,\n        };\n      }\n\n      default: {\n        const _exhaustiveCheck: never = type;\n        throw new Error(`Unsupported type: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  async doGenerate(\n    options: Parameters<LanguageModelV1['doGenerate']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV1['doGenerate']>>> {\n    const { args: body, warnings } = this.getArgs(options);\n\n    const {\n      responseHeaders,\n      value: response,\n      rawValue: rawResponse,\n    } = await postJsonToApi({\n      url: this.config.url({\n        path: '/chat/completions',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        openaiChatResponseSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const { messages: rawPrompt, ...rawSettings } = body;\n    const choice = response.choices[0];\n\n    // provider metadata:\n    const completionTokenDetails = response.usage?.completion_tokens_details;\n    const promptTokenDetails = response.usage?.prompt_tokens_details;\n    const providerMetadata: LanguageModelV1ProviderMetadata = { openai: {} };\n    if (completionTokenDetails?.reasoning_tokens != null) {\n      providerMetadata.openai.reasoningTokens =\n        completionTokenDetails?.reasoning_tokens;\n    }\n    if (completionTokenDetails?.accepted_prediction_tokens != null) {\n      providerMetadata.openai.acceptedPredictionTokens =\n        completionTokenDetails?.accepted_prediction_tokens;\n    }\n    if (completionTokenDetails?.rejected_prediction_tokens != null) {\n      providerMetadata.openai.rejectedPredictionTokens =\n        completionTokenDetails?.rejected_prediction_tokens;\n    }\n    if (promptTokenDetails?.cached_tokens != null) {\n      providerMetadata.openai.cachedPromptTokens =\n        promptTokenDetails?.cached_tokens;\n    }\n\n    return {\n      text: choice.message.content ?? undefined,\n      toolCalls:\n        this.settings.useLegacyFunctionCalling && choice.message.function_call\n          ? [\n              {\n                toolCallType: 'function',\n                toolCallId: generateId(),\n                toolName: choice.message.function_call.name,\n                args: choice.message.function_call.arguments,\n              },\n            ]\n          : choice.message.tool_calls?.map(toolCall => ({\n              toolCallType: 'function',\n              toolCallId: toolCall.id ?? generateId(),\n              toolName: toolCall.function.name,\n              args: toolCall.function.arguments!,\n            })),\n      finishReason: mapOpenAIFinishReason(choice.finish_reason),\n      usage: {\n        promptTokens: response.usage?.prompt_tokens ?? NaN,\n        completionTokens: response.usage?.completion_tokens ?? NaN,\n      },\n      rawCall: { rawPrompt, rawSettings },\n      rawResponse: { headers: responseHeaders, body: rawResponse },\n      request: { body: JSON.stringify(body) },\n      response: getResponseMetadata(response),\n      warnings,\n      logprobs: mapOpenAIChatLogProbsOutput(choice.logprobs),\n      providerMetadata,\n    };\n  }\n\n  async doStream(\n    options: Parameters<LanguageModelV1['doStream']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV1['doStream']>>> {\n    if (this.settings.simulateStreaming) {\n      const result = await this.doGenerate(options);\n\n      const simulatedStream = new ReadableStream<LanguageModelV1StreamPart>({\n        start(controller) {\n          controller.enqueue({ type: 'response-metadata', ...result.response });\n          if (result.text) {\n            controller.enqueue({\n              type: 'text-delta',\n              textDelta: result.text,\n            });\n          }\n          if (result.toolCalls) {\n            for (const toolCall of result.toolCalls) {\n              controller.enqueue({\n                type: 'tool-call-delta',\n                toolCallType: 'function',\n                toolCallId: toolCall.toolCallId,\n                toolName: toolCall.toolName,\n                argsTextDelta: toolCall.args,\n              });\n\n              controller.enqueue({\n                type: 'tool-call',\n                ...toolCall,\n              });\n            }\n          }\n          controller.enqueue({\n            type: 'finish',\n            finishReason: result.finishReason,\n            usage: result.usage,\n            logprobs: result.logprobs,\n            providerMetadata: result.providerMetadata,\n          });\n          controller.close();\n        },\n      });\n      return {\n        stream: simulatedStream,\n        rawCall: result.rawCall,\n        rawResponse: result.rawResponse,\n        warnings: result.warnings,\n      };\n    }\n\n    const { args, warnings } = this.getArgs(options);\n\n    const body = {\n      ...args,\n      stream: true,\n\n      // only include stream_options when in strict compatibility mode:\n      stream_options:\n        this.config.compatibility === 'strict'\n          ? { include_usage: true }\n          : undefined,\n    };\n\n    const { responseHeaders, value: response } = await postJsonToApi({\n      url: this.config.url({\n        path: '/chat/completions',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createEventSourceResponseHandler(\n        openaiChatChunkSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const { messages: rawPrompt, ...rawSettings } = args;\n\n    const toolCalls: Array<{\n      id: string;\n      type: 'function';\n      function: {\n        name: string;\n        arguments: string;\n      };\n      hasFinished: boolean;\n    }> = [];\n\n    let finishReason: LanguageModelV1FinishReason = 'unknown';\n    let usage: {\n      promptTokens: number | undefined;\n      completionTokens: number | undefined;\n    } = {\n      promptTokens: undefined,\n      completionTokens: undefined,\n    };\n    let logprobs: LanguageModelV1LogProbs;\n    let isFirstChunk = true;\n\n    const { useLegacyFunctionCalling } = this.settings;\n\n    const providerMetadata: LanguageModelV1ProviderMetadata = { openai: {} };\n\n    return {\n      stream: response.pipeThrough(\n        new TransformStream<\n          ParseResult<z.infer<typeof openaiChatChunkSchema>>,\n          LanguageModelV1StreamPart\n        >({\n          transform(chunk, controller) {\n            // handle failed chunk parsing / validation:\n            if (!chunk.success) {\n              finishReason = 'error';\n              controller.enqueue({ type: 'error', error: chunk.error });\n              return;\n            }\n\n            const value = chunk.value;\n\n            // handle error chunks:\n            if ('error' in value) {\n              finishReason = 'error';\n              controller.enqueue({ type: 'error', error: value.error });\n              return;\n            }\n\n            if (isFirstChunk) {\n              isFirstChunk = false;\n\n              controller.enqueue({\n                type: 'response-metadata',\n                ...getResponseMetadata(value),\n              });\n            }\n\n            if (value.usage != null) {\n              const {\n                prompt_tokens,\n                completion_tokens,\n                prompt_tokens_details,\n                completion_tokens_details,\n              } = value.usage;\n\n              usage = {\n                promptTokens: prompt_tokens ?? undefined,\n                completionTokens: completion_tokens ?? undefined,\n              };\n\n              if (completion_tokens_details?.reasoning_tokens != null) {\n                providerMetadata.openai.reasoningTokens =\n                  completion_tokens_details?.reasoning_tokens;\n              }\n              if (\n                completion_tokens_details?.accepted_prediction_tokens != null\n              ) {\n                providerMetadata.openai.acceptedPredictionTokens =\n                  completion_tokens_details?.accepted_prediction_tokens;\n              }\n              if (\n                completion_tokens_details?.rejected_prediction_tokens != null\n              ) {\n                providerMetadata.openai.rejectedPredictionTokens =\n                  completion_tokens_details?.rejected_prediction_tokens;\n              }\n              if (prompt_tokens_details?.cached_tokens != null) {\n                providerMetadata.openai.cachedPromptTokens =\n                  prompt_tokens_details?.cached_tokens;\n              }\n            }\n\n            const choice = value.choices[0];\n\n            if (choice?.finish_reason != null) {\n              finishReason = mapOpenAIFinishReason(choice.finish_reason);\n            }\n\n            if (choice?.delta == null) {\n              return;\n            }\n\n            const delta = choice.delta;\n\n            if (delta.content != null) {\n              controller.enqueue({\n                type: 'text-delta',\n                textDelta: delta.content,\n              });\n            }\n\n            const mappedLogprobs = mapOpenAIChatLogProbsOutput(\n              choice?.logprobs,\n            );\n            if (mappedLogprobs?.length) {\n              if (logprobs === undefined) logprobs = [];\n              logprobs.push(...mappedLogprobs);\n            }\n\n            const mappedToolCalls: typeof delta.tool_calls =\n              useLegacyFunctionCalling && delta.function_call != null\n                ? [\n                    {\n                      type: 'function',\n                      id: generateId(),\n                      function: delta.function_call,\n                      index: 0,\n                    },\n                  ]\n                : delta.tool_calls;\n\n            if (mappedToolCalls != null) {\n              for (const toolCallDelta of mappedToolCalls) {\n                const index = toolCallDelta.index;\n\n                // Tool call start. OpenAI returns all information except the arguments in the first chunk.\n                if (toolCalls[index] == null) {\n                  if (toolCallDelta.type !== 'function') {\n                    throw new InvalidResponseDataError({\n                      data: toolCallDelta,\n                      message: `Expected 'function' type.`,\n                    });\n                  }\n\n                  if (toolCallDelta.id == null) {\n                    throw new InvalidResponseDataError({\n                      data: toolCallDelta,\n                      message: `Expected 'id' to be a string.`,\n                    });\n                  }\n\n                  if (toolCallDelta.function?.name == null) {\n                    throw new InvalidResponseDataError({\n                      data: toolCallDelta,\n                      message: `Expected 'function.name' to be a string.`,\n                    });\n                  }\n\n                  toolCalls[index] = {\n                    id: toolCallDelta.id,\n                    type: 'function',\n                    function: {\n                      name: toolCallDelta.function.name,\n                      arguments: toolCallDelta.function.arguments ?? '',\n                    },\n                    hasFinished: false,\n                  };\n\n                  const toolCall = toolCalls[index];\n\n                  if (\n                    toolCall.function?.name != null &&\n                    toolCall.function?.arguments != null\n                  ) {\n                    // send delta if the argument text has already started:\n                    if (toolCall.function.arguments.length > 0) {\n                      controller.enqueue({\n                        type: 'tool-call-delta',\n                        toolCallType: 'function',\n                        toolCallId: toolCall.id,\n                        toolName: toolCall.function.name,\n                        argsTextDelta: toolCall.function.arguments,\n                      });\n                    }\n\n                    // check if tool call is complete\n                    // (some providers send the full tool call in one chunk):\n                    if (isParsableJson(toolCall.function.arguments)) {\n                      controller.enqueue({\n                        type: 'tool-call',\n                        toolCallType: 'function',\n                        toolCallId: toolCall.id ?? generateId(),\n                        toolName: toolCall.function.name,\n                        args: toolCall.function.arguments,\n                      });\n                      toolCall.hasFinished = true;\n                    }\n                  }\n\n                  continue;\n                }\n\n                // existing tool call, merge if not finished\n                const toolCall = toolCalls[index];\n\n                if (toolCall.hasFinished) {\n                  continue;\n                }\n\n                if (toolCallDelta.function?.arguments != null) {\n                  toolCall.function!.arguments +=\n                    toolCallDelta.function?.arguments ?? '';\n                }\n\n                // send delta\n                controller.enqueue({\n                  type: 'tool-call-delta',\n                  toolCallType: 'function',\n                  toolCallId: toolCall.id,\n                  toolName: toolCall.function.name,\n                  argsTextDelta: toolCallDelta.function.arguments ?? '',\n                });\n\n                // check if tool call is complete\n                if (\n                  toolCall.function?.name != null &&\n                  toolCall.function?.arguments != null &&\n                  isParsableJson(toolCall.function.arguments)\n                ) {\n                  controller.enqueue({\n                    type: 'tool-call',\n                    toolCallType: 'function',\n                    toolCallId: toolCall.id ?? generateId(),\n                    toolName: toolCall.function.name,\n                    args: toolCall.function.arguments,\n                  });\n                  toolCall.hasFinished = true;\n                }\n              }\n            }\n          },\n\n          flush(controller) {\n            controller.enqueue({\n              type: 'finish',\n              finishReason,\n              logprobs,\n              usage: {\n                promptTokens: usage.promptTokens ?? NaN,\n                completionTokens: usage.completionTokens ?? NaN,\n              },\n              ...(providerMetadata != null ? { providerMetadata } : {}),\n            });\n          },\n        }),\n      ),\n      rawCall: { rawPrompt, rawSettings },\n      rawResponse: { headers: responseHeaders },\n      request: { body: JSON.stringify(body) },\n      warnings,\n    };\n  }\n}\n\nconst openaiTokenUsageSchema = z\n  .object({\n    prompt_tokens: z.number().nullish(),\n    completion_tokens: z.number().nullish(),\n    prompt_tokens_details: z\n      .object({\n        cached_tokens: z.number().nullish(),\n      })\n      .nullish(),\n    completion_tokens_details: z\n      .object({\n        reasoning_tokens: z.number().nullish(),\n        accepted_prediction_tokens: z.number().nullish(),\n        rejected_prediction_tokens: z.number().nullish(),\n      })\n      .nullish(),\n  })\n  .nullish();\n\n// limited version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst openaiChatResponseSchema = z.object({\n  id: z.string().nullish(),\n  created: z.number().nullish(),\n  model: z.string().nullish(),\n  choices: z.array(\n    z.object({\n      message: z.object({\n        role: z.literal('assistant').nullish(),\n        content: z.string().nullish(),\n        function_call: z\n          .object({\n            arguments: z.string(),\n            name: z.string(),\n          })\n          .nullish(),\n        tool_calls: z\n          .array(\n            z.object({\n              id: z.string().nullish(),\n              type: z.literal('function'),\n              function: z.object({\n                name: z.string(),\n                arguments: z.string(),\n              }),\n            }),\n          )\n          .nullish(),\n      }),\n      index: z.number(),\n      logprobs: z\n        .object({\n          content: z\n            .array(\n              z.object({\n                token: z.string(),\n                logprob: z.number(),\n                top_logprobs: z.array(\n                  z.object({\n                    token: z.string(),\n                    logprob: z.number(),\n                  }),\n                ),\n              }),\n            )\n            .nullable(),\n        })\n        .nullish(),\n      finish_reason: z.string().nullish(),\n    }),\n  ),\n  usage: openaiTokenUsageSchema,\n});\n\n// limited version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst openaiChatChunkSchema = z.union([\n  z.object({\n    id: z.string().nullish(),\n    created: z.number().nullish(),\n    model: z.string().nullish(),\n    choices: z.array(\n      z.object({\n        delta: z\n          .object({\n            role: z.enum(['assistant']).nullish(),\n            content: z.string().nullish(),\n            function_call: z\n              .object({\n                name: z.string().optional(),\n                arguments: z.string().optional(),\n              })\n              .nullish(),\n            tool_calls: z\n              .array(\n                z.object({\n                  index: z.number(),\n                  id: z.string().nullish(),\n                  type: z.literal('function').nullish(),\n                  function: z.object({\n                    name: z.string().nullish(),\n                    arguments: z.string().nullish(),\n                  }),\n                }),\n              )\n              .nullish(),\n          })\n          .nullish(),\n        logprobs: z\n          .object({\n            content: z\n              .array(\n                z.object({\n                  token: z.string(),\n                  logprob: z.number(),\n                  top_logprobs: z.array(\n                    z.object({\n                      token: z.string(),\n                      logprob: z.number(),\n                    }),\n                  ),\n                }),\n              )\n              .nullable(),\n          })\n          .nullish(),\n        finish_reason: z.string().nullish(),\n        index: z.number(),\n      }),\n    ),\n    usage: openaiTokenUsageSchema,\n  }),\n  openaiErrorDataSchema,\n]);\n\nfunction isReasoningModel(modelId: string) {\n  return modelId.startsWith('o');\n}\n\nfunction isAudioModel(modelId: string) {\n  return modelId.startsWith('gpt-4o-audio-preview');\n}\n\nfunction getSystemMessageMode(modelId: string) {\n  if (!isReasoningModel(modelId)) {\n    return 'system';\n  }\n\n  return (\n    reasoningModels[modelId as keyof typeof reasoningModels]\n      ?.systemMessageMode ?? 'developer'\n  );\n}\n\nconst reasoningModels = {\n  'o1-mini': {\n    systemMessageMode: 'remove',\n  },\n  'o1-mini-2024-09-12': {\n    systemMessageMode: 'remove',\n  },\n  'o1-preview': {\n    systemMessageMode: 'remove',\n  },\n  'o1-preview-2024-09-12': {\n    systemMessageMode: 'remove',\n  },\n  o3: {\n    systemMessageMode: 'developer',\n  },\n  'o3-2025-04-16': {\n    systemMessageMode: 'developer',\n  },\n  'o3-mini': {\n    systemMessageMode: 'developer',\n  },\n  'o3-mini-2025-01-31': {\n    systemMessageMode: 'developer',\n  },\n  'o4-mini': {\n    systemMessageMode: 'developer',\n  },\n  'o4-mini-2025-04-16': {\n    systemMessageMode: 'developer',\n  },\n} as const;\n","import {\n  LanguageModelV1CallWarning,\n  LanguageModelV1Prompt,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport { convertUint8ArrayToBase64 } from '@ai-sdk/provider-utils';\nimport { OpenAIChatPrompt } from './openai-chat-prompt';\n\nexport function convertToOpenAIChatMessages({\n  prompt,\n  useLegacyFunctionCalling = false,\n  systemMessageMode = 'system',\n}: {\n  prompt: LanguageModelV1Prompt;\n  useLegacyFunctionCalling?: boolean;\n  systemMessageMode?: 'system' | 'developer' | 'remove';\n}): {\n  messages: OpenAIChatPrompt;\n  warnings: Array<LanguageModelV1CallWarning>;\n} {\n  const messages: OpenAIChatPrompt = [];\n  const warnings: Array<LanguageModelV1CallWarning> = [];\n\n  for (const { role, content } of prompt) {\n    switch (role) {\n      case 'system': {\n        switch (systemMessageMode) {\n          case 'system': {\n            messages.push({ role: 'system', content });\n            break;\n          }\n          case 'developer': {\n            messages.push({ role: 'developer', content });\n            break;\n          }\n          case 'remove': {\n            warnings.push({\n              type: 'other',\n              message: 'system messages are removed for this model',\n            });\n            break;\n          }\n          default: {\n            const _exhaustiveCheck: never = systemMessageMode;\n            throw new Error(\n              `Unsupported system message mode: ${_exhaustiveCheck}`,\n            );\n          }\n        }\n        break;\n      }\n\n      case 'user': {\n        if (content.length === 1 && content[0].type === 'text') {\n          messages.push({ role: 'user', content: content[0].text });\n          break;\n        }\n\n        messages.push({\n          role: 'user',\n          content: content.map((part, index) => {\n            switch (part.type) {\n              case 'text': {\n                return { type: 'text', text: part.text };\n              }\n              case 'image': {\n                return {\n                  type: 'image_url',\n                  image_url: {\n                    url:\n                      part.image instanceof URL\n                        ? part.image.toString()\n                        : `data:${\n                            part.mimeType ?? 'image/jpeg'\n                          };base64,${convertUint8ArrayToBase64(part.image)}`,\n\n                    // OpenAI specific extension: image detail\n                    detail: part.providerMetadata?.openai?.imageDetail,\n                  },\n                };\n              }\n              case 'file': {\n                if (part.data instanceof URL) {\n                  throw new UnsupportedFunctionalityError({\n                    functionality:\n                      \"'File content parts with URL data' functionality not supported.\",\n                  });\n                }\n\n                switch (part.mimeType) {\n                  case 'audio/wav': {\n                    return {\n                      type: 'input_audio',\n                      input_audio: { data: part.data, format: 'wav' },\n                    };\n                  }\n                  case 'audio/mp3':\n                  case 'audio/mpeg': {\n                    return {\n                      type: 'input_audio',\n                      input_audio: { data: part.data, format: 'mp3' },\n                    };\n                  }\n                  case 'application/pdf': {\n                    return {\n                      type: 'file',\n                      file: {\n                        filename: part.filename ?? `part-${index}.pdf`,\n                        file_data: `data:application/pdf;base64,${part.data}`,\n                      },\n                    };\n                  }\n                  default: {\n                    throw new UnsupportedFunctionalityError({\n                      functionality: `File content part type ${part.mimeType} in user messages`,\n                    });\n                  }\n                }\n              }\n            }\n          }),\n        });\n\n        break;\n      }\n\n      case 'assistant': {\n        let text = '';\n        const toolCalls: Array<{\n          id: string;\n          type: 'function';\n          function: { name: string; arguments: string };\n        }> = [];\n\n        for (const part of content) {\n          switch (part.type) {\n            case 'text': {\n              text += part.text;\n              break;\n            }\n            case 'tool-call': {\n              toolCalls.push({\n                id: part.toolCallId,\n                type: 'function',\n                function: {\n                  name: part.toolName,\n                  arguments: JSON.stringify(part.args),\n                },\n              });\n              break;\n            }\n          }\n        }\n\n        if (useLegacyFunctionCalling) {\n          if (toolCalls.length > 1) {\n            throw new UnsupportedFunctionalityError({\n              functionality:\n                'useLegacyFunctionCalling with multiple tool calls in one message',\n            });\n          }\n\n          messages.push({\n            role: 'assistant',\n            content: text,\n            function_call:\n              toolCalls.length > 0 ? toolCalls[0].function : undefined,\n          });\n        } else {\n          messages.push({\n            role: 'assistant',\n            content: text,\n            tool_calls: toolCalls.length > 0 ? toolCalls : undefined,\n          });\n        }\n\n        break;\n      }\n\n      case 'tool': {\n        for (const toolResponse of content) {\n          if (useLegacyFunctionCalling) {\n            messages.push({\n              role: 'function',\n              name: toolResponse.toolName,\n              content: JSON.stringify(toolResponse.result),\n            });\n          } else {\n            messages.push({\n              role: 'tool',\n              tool_call_id: toolResponse.toolCallId,\n              content: JSON.stringify(toolResponse.result),\n            });\n          }\n        }\n        break;\n      }\n\n      default: {\n        const _exhaustiveCheck: never = role;\n        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  return { messages, warnings };\n}\n","import { LanguageModelV1LogProbs } from '@ai-sdk/provider';\n\ntype OpenAIChatLogProbs = {\n  content:\n    | {\n        token: string;\n        logprob: number;\n        top_logprobs:\n          | {\n              token: string;\n              logprob: number;\n            }[]\n          | null;\n      }[]\n    | null;\n};\n\nexport function mapOpenAIChatLogProbsOutput(\n  logprobs: OpenAIChatLogProbs | null | undefined,\n): LanguageModelV1LogProbs | undefined {\n  return (\n    logprobs?.content?.map(({ token, logprob, top_logprobs }) => ({\n      token,\n      logprob,\n      topLogprobs: top_logprobs\n        ? top_logprobs.map(({ token, logprob }) => ({\n            token,\n            logprob,\n          }))\n        : [],\n    })) ?? undefined\n  );\n}\n","import { LanguageModelV1FinishReason } from '@ai-sdk/provider';\n\nexport function mapOpenAIFinishReason(\n  finishReason: string | null | undefined,\n): LanguageModelV1FinishReason {\n  switch (finishReason) {\n    case 'stop':\n      return 'stop';\n    case 'length':\n      return 'length';\n    case 'content_filter':\n      return 'content-filter';\n    case 'function_call':\n    case 'tool_calls':\n      return 'tool-calls';\n    default:\n      return 'unknown';\n  }\n}\n","import { z } from 'zod';\nimport { createJsonErrorResponseHandler } from '@ai-sdk/provider-utils';\n\nexport const openaiErrorDataSchema = z.object({\n  error: z.object({\n    message: z.string(),\n\n    // The additional information below is handled loosely to support\n    // OpenAI-compatible providers that have slightly different error\n    // responses:\n    type: z.string().nullish(),\n    param: z.any().nullish(),\n    code: z.union([z.string(), z.number()]).nullish(),\n  }),\n});\n\nexport type OpenAIErrorData = z.infer<typeof openaiErrorDataSchema>;\n\nexport const openaiFailedResponseHandler = createJsonErrorResponseHandler({\n  errorSchema: openaiErrorDataSchema,\n  errorToMessage: data => data.error.message,\n});\n","export function getResponseMetadata({\n  id,\n  model,\n  created,\n}: {\n  id?: string | undefined | null;\n  created?: number | undefined | null;\n  model?: string | undefined | null;\n}) {\n  return {\n    id: id ?? undefined,\n    modelId: model ?? undefined,\n    timestamp: created != null ? new Date(created * 1000) : undefined,\n  };\n}\n","import {\n  JSONSchema7,\n  LanguageModelV1,\n  LanguageModelV1CallWarning,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\n\nexport function prepareTools({\n  mode,\n  useLegacyFunctionCalling = false,\n  structuredOutputs,\n}: {\n  mode: Parameters<LanguageModelV1['doGenerate']>[0]['mode'] & {\n    type: 'regular';\n  };\n  useLegacyFunctionCalling: boolean | undefined;\n  structuredOutputs: boolean;\n}): {\n  tools?: {\n    type: 'function';\n    function: {\n      name: string;\n      description: string | undefined;\n      parameters: JSONSchema7;\n      strict?: boolean;\n    };\n  }[];\n  tool_choice?:\n    | 'auto'\n    | 'none'\n    | 'required'\n    | { type: 'function'; function: { name: string } };\n\n  // legacy support\n  functions?: {\n    name: string;\n    description: string | undefined;\n    parameters: JSONSchema7;\n  }[];\n  function_call?: { name: string };\n  toolWarnings: Array<LanguageModelV1CallWarning>;\n} {\n  // when the tools array is empty, change it to undefined to prevent errors:\n  const tools = mode.tools?.length ? mode.tools : undefined;\n\n  const toolWarnings: LanguageModelV1CallWarning[] = [];\n\n  if (tools == null) {\n    return { tools: undefined, tool_choice: undefined, toolWarnings };\n  }\n\n  const toolChoice = mode.toolChoice;\n\n  if (useLegacyFunctionCalling) {\n    const openaiFunctions: Array<{\n      name: string;\n      description: string | undefined;\n      parameters: JSONSchema7;\n    }> = [];\n\n    for (const tool of tools) {\n      if (tool.type === 'provider-defined') {\n        toolWarnings.push({ type: 'unsupported-tool', tool });\n      } else {\n        openaiFunctions.push({\n          name: tool.name,\n          description: tool.description,\n          parameters: tool.parameters,\n        });\n      }\n    }\n\n    if (toolChoice == null) {\n      return {\n        functions: openaiFunctions,\n        function_call: undefined,\n        toolWarnings,\n      };\n    }\n\n    const type = toolChoice.type;\n\n    switch (type) {\n      case 'auto':\n      case 'none':\n      case undefined:\n        return {\n          functions: openaiFunctions,\n          function_call: undefined,\n          toolWarnings,\n        };\n      case 'required':\n        throw new UnsupportedFunctionalityError({\n          functionality: 'useLegacyFunctionCalling and toolChoice: required',\n        });\n      default:\n        return {\n          functions: openaiFunctions,\n          function_call: { name: toolChoice.toolName },\n          toolWarnings,\n        };\n    }\n  }\n\n  const openaiTools: Array<{\n    type: 'function';\n    function: {\n      name: string;\n      description: string | undefined;\n      parameters: JSONSchema7;\n      strict: boolean | undefined;\n    };\n  }> = [];\n\n  for (const tool of tools) {\n    if (tool.type === 'provider-defined') {\n      toolWarnings.push({ type: 'unsupported-tool', tool });\n    } else {\n      openaiTools.push({\n        type: 'function',\n        function: {\n          name: tool.name,\n          description: tool.description,\n          parameters: tool.parameters,\n          strict: structuredOutputs ? true : undefined,\n        },\n      });\n    }\n  }\n\n  if (toolChoice == null) {\n    return { tools: openaiTools, tool_choice: undefined, toolWarnings };\n  }\n\n  const type = toolChoice.type;\n\n  switch (type) {\n    case 'auto':\n    case 'none':\n    case 'required':\n      return { tools: openaiTools, tool_choice: type, toolWarnings };\n    case 'tool':\n      return {\n        tools: openaiTools,\n        tool_choice: {\n          type: 'function',\n          function: {\n            name: toolChoice.toolName,\n          },\n        },\n        toolWarnings,\n      };\n    default: {\n      const _exhaustiveCheck: never = type;\n      throw new UnsupportedFunctionalityError({\n        functionality: `Unsupported tool choice type: ${_exhaustiveCheck}`,\n      });\n    }\n  }\n}\n","import {\n  LanguageModelV1,\n  LanguageModelV1CallWarning,\n  LanguageModelV1FinishReason,\n  LanguageModelV1LogProbs,\n  LanguageModelV1StreamPart,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport {\n  FetchFunction,\n  ParseResult,\n  combineHeaders,\n  createEventSourceResponseHandler,\n  createJsonResponseHandler,\n  postJsonToApi,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\nimport { convertToOpenAICompletionPrompt } from './convert-to-openai-completion-prompt';\nimport { mapOpenAICompletionLogProbs } from './map-openai-completion-logprobs';\nimport { mapOpenAIFinishReason } from './map-openai-finish-reason';\nimport {\n  OpenAICompletionModelId,\n  OpenAICompletionSettings,\n} from './openai-completion-settings';\nimport {\n  openaiErrorDataSchema,\n  openaiFailedResponseHandler,\n} from './openai-error';\nimport { getResponseMetadata } from './get-response-metadata';\n\ntype OpenAICompletionConfig = {\n  provider: string;\n  compatibility: 'strict' | 'compatible';\n  headers: () => Record<string, string | undefined>;\n  url: (options: { modelId: string; path: string }) => string;\n  fetch?: FetchFunction;\n};\n\nexport class OpenAICompletionLanguageModel implements LanguageModelV1 {\n  readonly specificationVersion = 'v1';\n  readonly defaultObjectGenerationMode = undefined;\n\n  readonly modelId: OpenAICompletionModelId;\n  readonly settings: OpenAICompletionSettings;\n\n  private readonly config: OpenAICompletionConfig;\n\n  constructor(\n    modelId: OpenAICompletionModelId,\n    settings: OpenAICompletionSettings,\n    config: OpenAICompletionConfig,\n  ) {\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n  }\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  private getArgs({\n    mode,\n    inputFormat,\n    prompt,\n    maxTokens,\n    temperature,\n    topP,\n    topK,\n    frequencyPenalty,\n    presencePenalty,\n    stopSequences: userStopSequences,\n    responseFormat,\n    seed,\n  }: Parameters<LanguageModelV1['doGenerate']>[0]) {\n    const type = mode.type;\n\n    const warnings: LanguageModelV1CallWarning[] = [];\n\n    if (topK != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'topK',\n      });\n    }\n\n    if (responseFormat != null && responseFormat.type !== 'text') {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'responseFormat',\n        details: 'JSON response format is not supported.',\n      });\n    }\n\n    const { prompt: completionPrompt, stopSequences } =\n      convertToOpenAICompletionPrompt({ prompt, inputFormat });\n\n    const stop = [...(stopSequences ?? []), ...(userStopSequences ?? [])];\n\n    const baseArgs = {\n      // model id:\n      model: this.modelId,\n\n      // model specific settings:\n      echo: this.settings.echo,\n      logit_bias: this.settings.logitBias,\n      logprobs:\n        typeof this.settings.logprobs === 'number'\n          ? this.settings.logprobs\n          : typeof this.settings.logprobs === 'boolean'\n            ? this.settings.logprobs\n              ? 0\n              : undefined\n            : undefined,\n      suffix: this.settings.suffix,\n      user: this.settings.user,\n\n      // standardized settings:\n      max_tokens: maxTokens,\n      temperature,\n      top_p: topP,\n      frequency_penalty: frequencyPenalty,\n      presence_penalty: presencePenalty,\n      seed,\n\n      // prompt:\n      prompt: completionPrompt,\n\n      // stop sequences:\n      stop: stop.length > 0 ? stop : undefined,\n    };\n\n    switch (type) {\n      case 'regular': {\n        if (mode.tools?.length) {\n          throw new UnsupportedFunctionalityError({\n            functionality: 'tools',\n          });\n        }\n\n        if (mode.toolChoice) {\n          throw new UnsupportedFunctionalityError({\n            functionality: 'toolChoice',\n          });\n        }\n\n        return { args: baseArgs, warnings };\n      }\n\n      case 'object-json': {\n        throw new UnsupportedFunctionalityError({\n          functionality: 'object-json mode',\n        });\n      }\n\n      case 'object-tool': {\n        throw new UnsupportedFunctionalityError({\n          functionality: 'object-tool mode',\n        });\n      }\n\n      default: {\n        const _exhaustiveCheck: never = type;\n        throw new Error(`Unsupported type: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  async doGenerate(\n    options: Parameters<LanguageModelV1['doGenerate']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV1['doGenerate']>>> {\n    const { args, warnings } = this.getArgs(options);\n\n    const {\n      responseHeaders,\n      value: response,\n      rawValue: rawResponse,\n    } = await postJsonToApi({\n      url: this.config.url({\n        path: '/completions',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body: args,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        openaiCompletionResponseSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const { prompt: rawPrompt, ...rawSettings } = args;\n    const choice = response.choices[0];\n\n    return {\n      text: choice.text,\n      usage: {\n        promptTokens: response.usage.prompt_tokens,\n        completionTokens: response.usage.completion_tokens,\n      },\n      finishReason: mapOpenAIFinishReason(choice.finish_reason),\n      logprobs: mapOpenAICompletionLogProbs(choice.logprobs),\n      rawCall: { rawPrompt, rawSettings },\n      rawResponse: { headers: responseHeaders, body: rawResponse },\n      response: getResponseMetadata(response),\n      warnings,\n      request: { body: JSON.stringify(args) },\n    };\n  }\n\n  async doStream(\n    options: Parameters<LanguageModelV1['doStream']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV1['doStream']>>> {\n    const { args, warnings } = this.getArgs(options);\n\n    const body = {\n      ...args,\n      stream: true,\n\n      // only include stream_options when in strict compatibility mode:\n      stream_options:\n        this.config.compatibility === 'strict'\n          ? { include_usage: true }\n          : undefined,\n    };\n\n    const { responseHeaders, value: response } = await postJsonToApi({\n      url: this.config.url({\n        path: '/completions',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createEventSourceResponseHandler(\n        openaiCompletionChunkSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const { prompt: rawPrompt, ...rawSettings } = args;\n\n    let finishReason: LanguageModelV1FinishReason = 'unknown';\n    let usage: { promptTokens: number; completionTokens: number } = {\n      promptTokens: Number.NaN,\n      completionTokens: Number.NaN,\n    };\n    let logprobs: LanguageModelV1LogProbs;\n    let isFirstChunk = true;\n\n    return {\n      stream: response.pipeThrough(\n        new TransformStream<\n          ParseResult<z.infer<typeof openaiCompletionChunkSchema>>,\n          LanguageModelV1StreamPart\n        >({\n          transform(chunk, controller) {\n            // handle failed chunk parsing / validation:\n            if (!chunk.success) {\n              finishReason = 'error';\n              controller.enqueue({ type: 'error', error: chunk.error });\n              return;\n            }\n\n            const value = chunk.value;\n\n            // handle error chunks:\n            if ('error' in value) {\n              finishReason = 'error';\n              controller.enqueue({ type: 'error', error: value.error });\n              return;\n            }\n\n            if (isFirstChunk) {\n              isFirstChunk = false;\n\n              controller.enqueue({\n                type: 'response-metadata',\n                ...getResponseMetadata(value),\n              });\n            }\n\n            if (value.usage != null) {\n              usage = {\n                promptTokens: value.usage.prompt_tokens,\n                completionTokens: value.usage.completion_tokens,\n              };\n            }\n\n            const choice = value.choices[0];\n\n            if (choice?.finish_reason != null) {\n              finishReason = mapOpenAIFinishReason(choice.finish_reason);\n            }\n\n            if (choice?.text != null) {\n              controller.enqueue({\n                type: 'text-delta',\n                textDelta: choice.text,\n              });\n            }\n\n            const mappedLogprobs = mapOpenAICompletionLogProbs(\n              choice?.logprobs,\n            );\n            if (mappedLogprobs?.length) {\n              if (logprobs === undefined) logprobs = [];\n              logprobs.push(...mappedLogprobs);\n            }\n          },\n\n          flush(controller) {\n            controller.enqueue({\n              type: 'finish',\n              finishReason,\n              logprobs,\n              usage,\n            });\n          },\n        }),\n      ),\n      rawCall: { rawPrompt, rawSettings },\n      rawResponse: { headers: responseHeaders },\n      warnings,\n      request: { body: JSON.stringify(body) },\n    };\n  }\n}\n\n// limited version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst openaiCompletionResponseSchema = z.object({\n  id: z.string().nullish(),\n  created: z.number().nullish(),\n  model: z.string().nullish(),\n  choices: z.array(\n    z.object({\n      text: z.string(),\n      finish_reason: z.string(),\n      logprobs: z\n        .object({\n          tokens: z.array(z.string()),\n          token_logprobs: z.array(z.number()),\n          top_logprobs: z.array(z.record(z.string(), z.number())).nullable(),\n        })\n        .nullish(),\n    }),\n  ),\n  usage: z.object({\n    prompt_tokens: z.number(),\n    completion_tokens: z.number(),\n  }),\n});\n\n// limited version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst openaiCompletionChunkSchema = z.union([\n  z.object({\n    id: z.string().nullish(),\n    created: z.number().nullish(),\n    model: z.string().nullish(),\n    choices: z.array(\n      z.object({\n        text: z.string(),\n        finish_reason: z.string().nullish(),\n        index: z.number(),\n        logprobs: z\n          .object({\n            tokens: z.array(z.string()),\n            token_logprobs: z.array(z.number()),\n            top_logprobs: z.array(z.record(z.string(), z.number())).nullable(),\n          })\n          .nullish(),\n      }),\n    ),\n    usage: z\n      .object({\n        prompt_tokens: z.number(),\n        completion_tokens: z.number(),\n      })\n      .nullish(),\n  }),\n  openaiErrorDataSchema,\n]);\n","import {\n  InvalidPromptError,\n  LanguageModelV1Prompt,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\n\nexport function convertToOpenAICompletionPrompt({\n  prompt,\n  inputFormat,\n  user = 'user',\n  assistant = 'assistant',\n}: {\n  prompt: LanguageModelV1Prompt;\n  inputFormat: 'prompt' | 'messages';\n  user?: string;\n  assistant?: string;\n}): {\n  prompt: string;\n  stopSequences?: string[];\n} {\n  // When the user supplied a prompt input, we don't transform it:\n  if (\n    inputFormat === 'prompt' &&\n    prompt.length === 1 &&\n    prompt[0].role === 'user' &&\n    prompt[0].content.length === 1 &&\n    prompt[0].content[0].type === 'text'\n  ) {\n    return { prompt: prompt[0].content[0].text };\n  }\n\n  // otherwise transform to a chat message format:\n  let text = '';\n\n  // if first message is a system message, add it to the text:\n  if (prompt[0].role === 'system') {\n    text += `${prompt[0].content}\\n\\n`;\n    prompt = prompt.slice(1);\n  }\n\n  for (const { role, content } of prompt) {\n    switch (role) {\n      case 'system': {\n        throw new InvalidPromptError({\n          message: 'Unexpected system message in prompt: ${content}',\n          prompt,\n        });\n      }\n\n      case 'user': {\n        const userMessage = content\n          .map(part => {\n            switch (part.type) {\n              case 'text': {\n                return part.text;\n              }\n              case 'image': {\n                throw new UnsupportedFunctionalityError({\n                  functionality: 'images',\n                });\n              }\n            }\n          })\n          .join('');\n\n        text += `${user}:\\n${userMessage}\\n\\n`;\n        break;\n      }\n\n      case 'assistant': {\n        const assistantMessage = content\n          .map(part => {\n            switch (part.type) {\n              case 'text': {\n                return part.text;\n              }\n              case 'tool-call': {\n                throw new UnsupportedFunctionalityError({\n                  functionality: 'tool-call messages',\n                });\n              }\n            }\n          })\n          .join('');\n\n        text += `${assistant}:\\n${assistantMessage}\\n\\n`;\n        break;\n      }\n\n      case 'tool': {\n        throw new UnsupportedFunctionalityError({\n          functionality: 'tool messages',\n        });\n      }\n\n      default: {\n        const _exhaustiveCheck: never = role;\n        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  // Assistant message prefix:\n  text += `${assistant}:\\n`;\n\n  return {\n    prompt: text,\n    stopSequences: [`\\n${user}:`],\n  };\n}\n","import { LanguageModelV1LogProbs } from '@ai-sdk/provider';\n\ntype OpenAICompletionLogProps = {\n  tokens: string[];\n  token_logprobs: number[];\n  top_logprobs: Record<string, number>[] | null;\n};\n\nexport function mapOpenAICompletionLogProbs(\n  logprobs: OpenAICompletionLogProps | null | undefined,\n): LanguageModelV1LogProbs | undefined {\n  return logprobs?.tokens.map((token, index) => ({\n    token,\n    logprob: logprobs.token_logprobs[index],\n    topLogprobs: logprobs.top_logprobs\n      ? Object.entries(logprobs.top_logprobs[index]).map(\n          ([token, logprob]) => ({\n            token,\n            logprob,\n          }),\n        )\n      : [],\n  }));\n}\n","import {\n  EmbeddingModelV1,\n  TooManyEmbeddingValuesForCallError,\n} from '@ai-sdk/provider';\nimport {\n  combineHeaders,\n  createJsonResponseHandler,\n  postJsonToApi,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\nimport { OpenAIConfig } from './openai-config';\nimport {\n  OpenAIEmbeddingModelId,\n  OpenAIEmbeddingSettings,\n} from './openai-embedding-settings';\nimport { openaiFailedResponseHandler } from './openai-error';\n\nexport class OpenAIEmbeddingModel implements EmbeddingModelV1<string> {\n  readonly specificationVersion = 'v1';\n  readonly modelId: OpenAIEmbeddingModelId;\n\n  private readonly config: OpenAIConfig;\n  private readonly settings: OpenAIEmbeddingSettings;\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  get maxEmbeddingsPerCall(): number {\n    return this.settings.maxEmbeddingsPerCall ?? 2048;\n  }\n\n  get supportsParallelCalls(): boolean {\n    return this.settings.supportsParallelCalls ?? true;\n  }\n\n  constructor(\n    modelId: OpenAIEmbeddingModelId,\n    settings: OpenAIEmbeddingSettings,\n    config: OpenAIConfig,\n  ) {\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n  }\n\n  async doEmbed({\n    values,\n    headers,\n    abortSignal,\n  }: Parameters<EmbeddingModelV1<string>['doEmbed']>[0]): Promise<\n    Awaited<ReturnType<EmbeddingModelV1<string>['doEmbed']>>\n  > {\n    if (values.length > this.maxEmbeddingsPerCall) {\n      throw new TooManyEmbeddingValuesForCallError({\n        provider: this.provider,\n        modelId: this.modelId,\n        maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,\n        values,\n      });\n    }\n\n    const { responseHeaders, value: response } = await postJsonToApi({\n      url: this.config.url({\n        path: '/embeddings',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), headers),\n      body: {\n        model: this.modelId,\n        input: values,\n        encoding_format: 'float',\n        dimensions: this.settings.dimensions,\n        user: this.settings.user,\n      },\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        openaiTextEmbeddingResponseSchema,\n      ),\n      abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    return {\n      embeddings: response.data.map(item => item.embedding),\n      usage: response.usage\n        ? { tokens: response.usage.prompt_tokens }\n        : undefined,\n      rawResponse: { headers: responseHeaders },\n    };\n  }\n}\n\n// minimal version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst openaiTextEmbeddingResponseSchema = z.object({\n  data: z.array(z.object({ embedding: z.array(z.number()) })),\n  usage: z.object({ prompt_tokens: z.number() }).nullish(),\n});\n","import { ImageModelV1, ImageModelV1CallWarning } from '@ai-sdk/provider';\nimport {\n  combineHeaders,\n  createJsonResponseHandler,\n  postJsonToApi,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\nimport { OpenAIConfig } from './openai-config';\nimport { openaiFailedResponseHandler } from './openai-error';\nimport {\n  OpenAIImageModelId,\n  OpenAIImageSettings,\n  modelMaxImagesPerCall,\n  hasDefaultResponseFormat,\n} from './openai-image-settings';\n\ninterface OpenAIImageModelConfig extends OpenAIConfig {\n  _internal?: {\n    currentDate?: () => Date;\n  };\n}\n\nexport class OpenAIImageModel implements ImageModelV1 {\n  readonly specificationVersion = 'v1';\n\n  get maxImagesPerCall(): number {\n    return (\n      this.settings.maxImagesPerCall ?? modelMaxImagesPerCall[this.modelId] ?? 1\n    );\n  }\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  constructor(\n    readonly modelId: OpenAIImageModelId,\n    private readonly settings: OpenAIImageSettings,\n    private readonly config: OpenAIImageModelConfig,\n  ) {}\n\n  async doGenerate({\n    prompt,\n    n,\n    size,\n    aspectRatio,\n    seed,\n    providerOptions,\n    headers,\n    abortSignal,\n  }: Parameters<ImageModelV1['doGenerate']>[0]): Promise<\n    Awaited<ReturnType<ImageModelV1['doGenerate']>>\n  > {\n    const warnings: Array<ImageModelV1CallWarning> = [];\n\n    if (aspectRatio != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'aspectRatio',\n        details:\n          'This model does not support aspect ratio. Use `size` instead.',\n      });\n    }\n\n    if (seed != null) {\n      warnings.push({ type: 'unsupported-setting', setting: 'seed' });\n    }\n\n    const currentDate = this.config._internal?.currentDate?.() ?? new Date();\n    const { value: response, responseHeaders } = await postJsonToApi({\n      url: this.config.url({\n        path: '/images/generations',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), headers),\n      body: {\n        model: this.modelId,\n        prompt,\n        n,\n        size,\n        ...(providerOptions.openai ?? {}),\n        ...(!hasDefaultResponseFormat.has(this.modelId)\n          ? { response_format: 'b64_json' }\n          : {}),\n      },\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        openaiImageResponseSchema,\n      ),\n      abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    return {\n      images: response.data.map(item => item.b64_json),\n      warnings,\n      response: {\n        timestamp: currentDate,\n        modelId: this.modelId,\n        headers: responseHeaders,\n      },\n    };\n  }\n}\n\n// minimal version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst openaiImageResponseSchema = z.object({\n  data: z.array(z.object({ b64_json: z.string() })),\n});\n","export type OpenAIImageModelId =\n  | 'gpt-image-1'\n  | 'dall-e-3'\n  | 'dall-e-2'\n  | (string & {});\n\n// https://platform.openai.com/docs/guides/images\nexport const modelMaxImagesPerCall: Record<OpenAIImageModelId, number> = {\n  'dall-e-3': 1,\n  'dall-e-2': 10,\n  'gpt-image-1': 10,\n};\n\nexport const hasDefaultResponseFormat = new Set(['gpt-image-1']);\n\nexport interface OpenAIImageSettings {\n  /**\nOverride the maximum number of images per call (default is dependent on the\nmodel, or 1 for an unknown model).\n   */\n  maxImagesPerCall?: number;\n}\n","import {\n  TranscriptionModelV1,\n  TranscriptionModelV1CallOptions,\n  TranscriptionModelV1CallWarning,\n} from '@ai-sdk/provider';\nimport {\n  combineHeaders,\n  convertBase64ToUint8Array,\n  createJsonResponseHandler,\n  parseProviderOptions,\n  postFormDataToApi,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\nimport { OpenAIConfig } from './openai-config';\nimport { openaiFailedResponseHandler } from './openai-error';\nimport {\n  OpenAITranscriptionModelId,\n  OpenAITranscriptionModelOptions,\n} from './openai-transcription-settings';\n\n// https://platform.openai.com/docs/api-reference/audio/createTranscription\nconst openAIProviderOptionsSchema = z.object({\n  include: z.array(z.string()).nullish(),\n  language: z.string().nullish(),\n  prompt: z.string().nullish(),\n  temperature: z.number().min(0).max(1).nullish().default(0),\n  timestampGranularities: z\n    .array(z.enum(['word', 'segment']))\n    .nullish()\n    .default(['segment']),\n});\n\nexport type OpenAITranscriptionCallOptions = Omit<\n  TranscriptionModelV1CallOptions,\n  'providerOptions'\n> & {\n  providerOptions?: {\n    openai?: z.infer<typeof openAIProviderOptionsSchema>;\n  };\n};\n\ninterface OpenAITranscriptionModelConfig extends OpenAIConfig {\n  _internal?: {\n    currentDate?: () => Date;\n  };\n}\n\n// https://platform.openai.com/docs/guides/speech-to-text#supported-languages\nconst languageMap = {\n  afrikaans: 'af',\n  arabic: 'ar',\n  armenian: 'hy',\n  azerbaijani: 'az',\n  belarusian: 'be',\n  bosnian: 'bs',\n  bulgarian: 'bg',\n  catalan: 'ca',\n  chinese: 'zh',\n  croatian: 'hr',\n  czech: 'cs',\n  danish: 'da',\n  dutch: 'nl',\n  english: 'en',\n  estonian: 'et',\n  finnish: 'fi',\n  french: 'fr',\n  galician: 'gl',\n  german: 'de',\n  greek: 'el',\n  hebrew: 'he',\n  hindi: 'hi',\n  hungarian: 'hu',\n  icelandic: 'is',\n  indonesian: 'id',\n  italian: 'it',\n  japanese: 'ja',\n  kannada: 'kn',\n  kazakh: 'kk',\n  korean: 'ko',\n  latvian: 'lv',\n  lithuanian: 'lt',\n  macedonian: 'mk',\n  malay: 'ms',\n  marathi: 'mr',\n  maori: 'mi',\n  nepali: 'ne',\n  norwegian: 'no',\n  persian: 'fa',\n  polish: 'pl',\n  portuguese: 'pt',\n  romanian: 'ro',\n  russian: 'ru',\n  serbian: 'sr',\n  slovak: 'sk',\n  slovenian: 'sl',\n  spanish: 'es',\n  swahili: 'sw',\n  swedish: 'sv',\n  tagalog: 'tl',\n  tamil: 'ta',\n  thai: 'th',\n  turkish: 'tr',\n  ukrainian: 'uk',\n  urdu: 'ur',\n  vietnamese: 'vi',\n  welsh: 'cy',\n};\n\nexport class OpenAITranscriptionModel implements TranscriptionModelV1 {\n  readonly specificationVersion = 'v1';\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  constructor(\n    readonly modelId: OpenAITranscriptionModelId,\n    private readonly config: OpenAITranscriptionModelConfig,\n  ) {}\n\n  private getArgs({\n    audio,\n    mediaType,\n    providerOptions,\n  }: OpenAITranscriptionCallOptions) {\n    const warnings: TranscriptionModelV1CallWarning[] = [];\n\n    // Parse provider options\n    const openAIOptions = parseProviderOptions({\n      provider: 'openai',\n      providerOptions,\n      schema: openAIProviderOptionsSchema,\n    });\n\n    // Create form data with base fields\n    const formData = new FormData();\n    const blob =\n      audio instanceof Uint8Array\n        ? new Blob([audio])\n        : new Blob([convertBase64ToUint8Array(audio)]);\n\n    formData.append('model', this.modelId);\n    formData.append('file', new File([blob], 'audio', { type: mediaType }));\n\n    // Add provider-specific options\n    if (openAIOptions) {\n      const transcriptionModelOptions: OpenAITranscriptionModelOptions = {\n        include: openAIOptions.include ?? undefined,\n        language: openAIOptions.language ?? undefined,\n        prompt: openAIOptions.prompt ?? undefined,\n        temperature: openAIOptions.temperature ?? undefined,\n        timestamp_granularities:\n          openAIOptions.timestampGranularities ?? undefined,\n      };\n\n      for (const key in transcriptionModelOptions) {\n        const value =\n          transcriptionModelOptions[\n            key as keyof OpenAITranscriptionModelOptions\n          ];\n        if (value !== undefined) {\n          formData.append(key, String(value));\n        }\n      }\n    }\n\n    return {\n      formData,\n      warnings,\n    };\n  }\n\n  async doGenerate(\n    options: OpenAITranscriptionCallOptions,\n  ): Promise<Awaited<ReturnType<TranscriptionModelV1['doGenerate']>>> {\n    const currentDate = this.config._internal?.currentDate?.() ?? new Date();\n    const { formData, warnings } = this.getArgs(options);\n\n    const {\n      value: response,\n      responseHeaders,\n      rawValue: rawResponse,\n    } = await postFormDataToApi({\n      url: this.config.url({\n        path: '/audio/transcriptions',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      formData,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        openaiTranscriptionResponseSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const language =\n      response.language != null && response.language in languageMap\n        ? languageMap[response.language as keyof typeof languageMap]\n        : undefined;\n\n    return {\n      text: response.text,\n      segments:\n        response.words?.map(word => ({\n          text: word.word,\n          startSecond: word.start,\n          endSecond: word.end,\n        })) ?? [],\n      language,\n      durationInSeconds: response.duration ?? undefined,\n      warnings,\n      response: {\n        timestamp: currentDate,\n        modelId: this.modelId,\n        headers: responseHeaders,\n        body: rawResponse,\n      },\n    };\n  }\n}\n\nconst openaiTranscriptionResponseSchema = z.object({\n  text: z.string(),\n  language: z.string().nullish(),\n  duration: z.number().nullish(),\n  words: z\n    .array(\n      z.object({\n        word: z.string(),\n        start: z.number(),\n        end: z.number(),\n      }),\n    )\n    .nullish(),\n});\n","import { SpeechModelV1, SpeechModelV1CallWarning } from '@ai-sdk/provider';\nimport {\n  combineHeaders,\n  createBinaryResponseHandler,\n  parseProviderOptions,\n  postJsonToApi,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\nimport { OpenAIConfig } from './openai-config';\nimport { openaiFailedResponseHandler } from './openai-error';\nimport { OpenAISpeechModelId } from './openai-speech-settings';\nimport { OpenAISpeechAPITypes } from './openai-api-types';\n\n// https://platform.openai.com/docs/api-reference/audio/createSpeech\nconst OpenAIProviderOptionsSchema = z.object({\n  instructions: z.string().nullish(),\n  speed: z.number().min(0.25).max(4.0).default(1.0).nullish(),\n});\n\nexport type OpenAISpeechCallOptions = z.infer<\n  typeof OpenAIProviderOptionsSchema\n>;\n\ninterface OpenAISpeechModelConfig extends OpenAIConfig {\n  _internal?: {\n    currentDate?: () => Date;\n  };\n}\n\nexport class OpenAISpeechModel implements SpeechModelV1 {\n  readonly specificationVersion = 'v1';\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  constructor(\n    readonly modelId: OpenAISpeechModelId,\n    private readonly config: OpenAISpeechModelConfig,\n  ) {}\n\n  private getArgs({\n    text,\n    voice = 'alloy',\n    outputFormat = 'mp3',\n    speed,\n    instructions,\n    providerOptions,\n  }: Parameters<SpeechModelV1['doGenerate']>[0]) {\n    const warnings: SpeechModelV1CallWarning[] = [];\n\n    // Parse provider options\n    const openAIOptions = parseProviderOptions({\n      provider: 'openai',\n      providerOptions,\n      schema: OpenAIProviderOptionsSchema,\n    });\n\n    // Create request body\n    const requestBody: Record<string, unknown> = {\n      model: this.modelId,\n      input: text,\n      voice,\n      response_format: 'mp3',\n      speed,\n      instructions,\n    };\n\n    if (outputFormat) {\n      if (['mp3', 'opus', 'aac', 'flac', 'wav', 'pcm'].includes(outputFormat)) {\n        requestBody.response_format = outputFormat;\n      } else {\n        warnings.push({\n          type: 'unsupported-setting',\n          setting: 'outputFormat',\n          details: `Unsupported output format: ${outputFormat}. Using mp3 instead.`,\n        });\n      }\n    }\n\n    // Add provider-specific options\n    if (openAIOptions) {\n      const speechModelOptions: OpenAISpeechAPITypes = {};\n\n      for (const key in speechModelOptions) {\n        const value = speechModelOptions[key as keyof OpenAISpeechAPITypes];\n        if (value !== undefined) {\n          requestBody[key] = value;\n        }\n      }\n    }\n\n    return {\n      requestBody,\n      warnings,\n    };\n  }\n\n  async doGenerate(\n    options: Parameters<SpeechModelV1['doGenerate']>[0],\n  ): Promise<Awaited<ReturnType<SpeechModelV1['doGenerate']>>> {\n    const currentDate = this.config._internal?.currentDate?.() ?? new Date();\n    const { requestBody, warnings } = this.getArgs(options);\n\n    const {\n      value: audio,\n      responseHeaders,\n      rawValue: rawResponse,\n    } = await postJsonToApi({\n      url: this.config.url({\n        path: '/audio/speech',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body: requestBody,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createBinaryResponseHandler(),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    return {\n      audio,\n      warnings,\n      request: {\n        body: JSON.stringify(requestBody),\n      },\n      response: {\n        timestamp: currentDate,\n        modelId: this.modelId,\n        headers: responseHeaders,\n        body: rawResponse,\n      },\n    };\n  }\n}\n","import {\n  APICallError,\n  LanguageModelV1,\n  LanguageModelV1CallWarning,\n  LanguageModelV1FinishReason,\n  LanguageModelV1StreamPart,\n} from '@ai-sdk/provider';\nimport {\n  combineHeaders,\n  createEventSourceResponseHandler,\n  createJsonResponseHandler,\n  generateId,\n  parseProviderOptions,\n  ParseResult,\n  postJsonToApi,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\nimport { OpenAIConfig } from '../openai-config';\nimport { openaiFailedResponseHandler } from '../openai-error';\nimport { convertToOpenAIResponsesMessages } from './convert-to-openai-responses-messages';\nimport { mapOpenAIResponseFinishReason } from './map-openai-responses-finish-reason';\nimport { prepareResponsesTools } from './openai-responses-prepare-tools';\nimport { OpenAIResponsesModelId } from './openai-responses-settings';\n\nexport class OpenAIResponsesLanguageModel implements LanguageModelV1 {\n  readonly specificationVersion = 'v1';\n  readonly defaultObjectGenerationMode = 'json';\n  readonly supportsStructuredOutputs = true;\n\n  readonly modelId: OpenAIResponsesModelId;\n\n  private readonly config: OpenAIConfig;\n\n  constructor(modelId: OpenAIResponsesModelId, config: OpenAIConfig) {\n    this.modelId = modelId;\n    this.config = config;\n  }\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  private getArgs({\n    mode,\n    maxTokens,\n    temperature,\n    stopSequences,\n    topP,\n    topK,\n    presencePenalty,\n    frequencyPenalty,\n    seed,\n    prompt,\n    providerMetadata,\n    responseFormat,\n  }: Parameters<LanguageModelV1['doGenerate']>[0]) {\n    const warnings: LanguageModelV1CallWarning[] = [];\n    const modelConfig = getResponsesModelConfig(this.modelId);\n    const type = mode.type;\n\n    if (topK != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'topK',\n      });\n    }\n\n    if (seed != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'seed',\n      });\n    }\n\n    if (presencePenalty != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'presencePenalty',\n      });\n    }\n\n    if (frequencyPenalty != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'frequencyPenalty',\n      });\n    }\n\n    if (stopSequences != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'stopSequences',\n      });\n    }\n\n    const { messages, warnings: messageWarnings } =\n      convertToOpenAIResponsesMessages({\n        prompt,\n        systemMessageMode: modelConfig.systemMessageMode,\n      });\n\n    warnings.push(...messageWarnings);\n\n    const openaiOptions = parseProviderOptions({\n      provider: 'openai',\n      providerOptions: providerMetadata,\n      schema: openaiResponsesProviderOptionsSchema,\n    });\n\n    const isStrict = openaiOptions?.strictSchemas ?? true;\n\n    const baseArgs = {\n      model: this.modelId,\n      input: messages,\n      temperature,\n      top_p: topP,\n      max_output_tokens: maxTokens,\n\n      ...(responseFormat?.type === 'json' && {\n        text: {\n          format:\n            responseFormat.schema != null\n              ? {\n                  type: 'json_schema',\n                  strict: isStrict,\n                  name: responseFormat.name ?? 'response',\n                  description: responseFormat.description,\n                  schema: responseFormat.schema,\n                }\n              : { type: 'json_object' },\n        },\n      }),\n\n      // provider options:\n      metadata: openaiOptions?.metadata,\n      parallel_tool_calls: openaiOptions?.parallelToolCalls,\n      previous_response_id: openaiOptions?.previousResponseId,\n      store: openaiOptions?.store,\n      user: openaiOptions?.user,\n      instructions: openaiOptions?.instructions,\n\n      // model-specific settings:\n      ...(modelConfig.isReasoningModel &&\n        (openaiOptions?.reasoningEffort != null ||\n          openaiOptions?.reasoningSummary != null) && {\n          reasoning: {\n            ...(openaiOptions?.reasoningEffort != null && {\n              effort: openaiOptions.reasoningEffort,\n            }),\n            ...(openaiOptions?.reasoningSummary != null && {\n              summary: openaiOptions.reasoningSummary,\n            }),\n          },\n        }),\n      ...(modelConfig.requiredAutoTruncation && {\n        truncation: 'auto',\n      }),\n    };\n\n    if (modelConfig.isReasoningModel) {\n      // remove unsupported settings for reasoning models\n      // see https://platform.openai.com/docs/guides/reasoning#limitations\n      if (baseArgs.temperature != null) {\n        baseArgs.temperature = undefined;\n        warnings.push({\n          type: 'unsupported-setting',\n          setting: 'temperature',\n          details: 'temperature is not supported for reasoning models',\n        });\n      }\n\n      if (baseArgs.top_p != null) {\n        baseArgs.top_p = undefined;\n        warnings.push({\n          type: 'unsupported-setting',\n          setting: 'topP',\n          details: 'topP is not supported for reasoning models',\n        });\n      }\n    }\n\n    switch (type) {\n      case 'regular': {\n        const { tools, tool_choice, toolWarnings } = prepareResponsesTools({\n          mode,\n          strict: isStrict, // TODO support provider options on tools\n        });\n\n        return {\n          args: {\n            ...baseArgs,\n            tools,\n            tool_choice,\n          },\n          warnings: [...warnings, ...toolWarnings],\n        };\n      }\n\n      case 'object-json': {\n        return {\n          args: {\n            ...baseArgs,\n            text: {\n              format:\n                mode.schema != null\n                  ? {\n                      type: 'json_schema',\n                      strict: isStrict,\n                      name: mode.name ?? 'response',\n                      description: mode.description,\n                      schema: mode.schema,\n                    }\n                  : { type: 'json_object' },\n            },\n          },\n          warnings,\n        };\n      }\n\n      case 'object-tool': {\n        return {\n          args: {\n            ...baseArgs,\n            tool_choice: { type: 'function', name: mode.tool.name },\n            tools: [\n              {\n                type: 'function',\n                name: mode.tool.name,\n                description: mode.tool.description,\n                parameters: mode.tool.parameters,\n                strict: isStrict,\n              },\n            ],\n          },\n          warnings,\n        };\n      }\n\n      default: {\n        const _exhaustiveCheck: never = type;\n        throw new Error(`Unsupported type: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  async doGenerate(\n    options: Parameters<LanguageModelV1['doGenerate']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV1['doGenerate']>>> {\n    const { args: body, warnings } = this.getArgs(options);\n    const url = this.config.url({\n      path: '/responses',\n      modelId: this.modelId,\n    });\n\n    const {\n      responseHeaders,\n      value: response,\n      rawValue: rawResponse,\n    } = await postJsonToApi({\n      url,\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        z.object({\n          id: z.string(),\n          created_at: z.number(),\n          error: z\n            .object({\n              message: z.string(),\n              code: z.string(),\n            })\n            .nullish(),\n          model: z.string(),\n          output: z.array(\n            z.discriminatedUnion('type', [\n              z.object({\n                type: z.literal('message'),\n                role: z.literal('assistant'),\n                content: z.array(\n                  z.object({\n                    type: z.literal('output_text'),\n                    text: z.string(),\n                    annotations: z.array(\n                      z.object({\n                        type: z.literal('url_citation'),\n                        start_index: z.number(),\n                        end_index: z.number(),\n                        url: z.string(),\n                        title: z.string(),\n                      }),\n                    ),\n                  }),\n                ),\n              }),\n              z.object({\n                type: z.literal('function_call'),\n                call_id: z.string(),\n                name: z.string(),\n                arguments: z.string(),\n              }),\n              z.object({\n                type: z.literal('web_search_call'),\n              }),\n              z.object({\n                type: z.literal('computer_call'),\n              }),\n              z.object({\n                type: z.literal('reasoning'),\n                summary: z.array(\n                  z.object({\n                    type: z.literal('summary_text'),\n                    text: z.string(),\n                  }),\n                ),\n              }),\n            ]),\n          ),\n          incomplete_details: z.object({ reason: z.string() }).nullable(),\n          usage: usageSchema,\n        }),\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    if (response.error) {\n      throw new APICallError({\n        message: response.error.message,\n        url,\n        requestBodyValues: body,\n        statusCode: 400,\n        responseHeaders,\n        responseBody: rawResponse as string,\n        isRetryable: false,\n      });\n    }\n\n    const outputTextElements = response.output\n      .filter(output => output.type === 'message')\n      .flatMap(output => output.content)\n      .filter(content => content.type === 'output_text');\n\n    const toolCalls = response.output\n      .filter(output => output.type === 'function_call')\n      .map(output => ({\n        toolCallType: 'function' as const,\n        toolCallId: output.call_id,\n        toolName: output.name,\n        args: output.arguments,\n      }));\n\n    const reasoningSummary =\n      response.output.find(item => item.type === 'reasoning')?.summary ?? null;\n\n    return {\n      text: outputTextElements.map(content => content.text).join('\\n'),\n      sources: outputTextElements.flatMap(content =>\n        content.annotations.map(annotation => ({\n          sourceType: 'url',\n          id: this.config.generateId?.() ?? generateId(),\n          url: annotation.url,\n          title: annotation.title,\n        })),\n      ),\n      finishReason: mapOpenAIResponseFinishReason({\n        finishReason: response.incomplete_details?.reason,\n        hasToolCalls: toolCalls.length > 0,\n      }),\n      toolCalls: toolCalls.length > 0 ? toolCalls : undefined,\n      reasoning: reasoningSummary\n        ? reasoningSummary.map(summary => ({\n            type: 'text' as const,\n            text: summary.text,\n          }))\n        : undefined,\n      usage: {\n        promptTokens: response.usage.input_tokens,\n        completionTokens: response.usage.output_tokens,\n      },\n      rawCall: {\n        rawPrompt: undefined,\n        rawSettings: {},\n      },\n      rawResponse: {\n        headers: responseHeaders,\n        body: rawResponse,\n      },\n      request: {\n        body: JSON.stringify(body),\n      },\n      response: {\n        id: response.id,\n        timestamp: new Date(response.created_at * 1000),\n        modelId: response.model,\n      },\n      providerMetadata: {\n        openai: {\n          responseId: response.id,\n          cachedPromptTokens:\n            response.usage.input_tokens_details?.cached_tokens ?? null,\n          reasoningTokens:\n            response.usage.output_tokens_details?.reasoning_tokens ?? null,\n        },\n      },\n      warnings,\n    };\n  }\n\n  async doStream(\n    options: Parameters<LanguageModelV1['doStream']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV1['doStream']>>> {\n    const { args: body, warnings } = this.getArgs(options);\n\n    const { responseHeaders, value: response } = await postJsonToApi({\n      url: this.config.url({\n        path: '/responses',\n        modelId: this.modelId,\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body: {\n        ...body,\n        stream: true,\n      },\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: createEventSourceResponseHandler(\n        openaiResponsesChunkSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const self = this;\n\n    let finishReason: LanguageModelV1FinishReason = 'unknown';\n    let promptTokens = NaN;\n    let completionTokens = NaN;\n    let cachedPromptTokens: number | null = null;\n    let reasoningTokens: number | null = null;\n    let responseId: string | null = null;\n    const ongoingToolCalls: Record<\n      number,\n      { toolName: string; toolCallId: string } | undefined\n    > = {};\n    let hasToolCalls = false;\n\n    return {\n      stream: response.pipeThrough(\n        new TransformStream<\n          ParseResult<z.infer<typeof openaiResponsesChunkSchema>>,\n          LanguageModelV1StreamPart\n        >({\n          transform(chunk, controller) {\n            // handle failed chunk parsing / validation:\n            if (!chunk.success) {\n              finishReason = 'error';\n              controller.enqueue({ type: 'error', error: chunk.error });\n              return;\n            }\n\n            const value = chunk.value;\n\n            if (isResponseOutputItemAddedChunk(value)) {\n              if (value.item.type === 'function_call') {\n                ongoingToolCalls[value.output_index] = {\n                  toolName: value.item.name,\n                  toolCallId: value.item.call_id,\n                };\n\n                controller.enqueue({\n                  type: 'tool-call-delta',\n                  toolCallType: 'function',\n                  toolCallId: value.item.call_id,\n                  toolName: value.item.name,\n                  argsTextDelta: value.item.arguments,\n                });\n              }\n            } else if (isResponseFunctionCallArgumentsDeltaChunk(value)) {\n              const toolCall = ongoingToolCalls[value.output_index];\n\n              if (toolCall != null) {\n                controller.enqueue({\n                  type: 'tool-call-delta',\n                  toolCallType: 'function',\n                  toolCallId: toolCall.toolCallId,\n                  toolName: toolCall.toolName,\n                  argsTextDelta: value.delta,\n                });\n              }\n            } else if (isResponseCreatedChunk(value)) {\n              responseId = value.response.id;\n              controller.enqueue({\n                type: 'response-metadata',\n                id: value.response.id,\n                timestamp: new Date(value.response.created_at * 1000),\n                modelId: value.response.model,\n              });\n            } else if (isTextDeltaChunk(value)) {\n              controller.enqueue({\n                type: 'text-delta',\n                textDelta: value.delta,\n              });\n            } else if (isResponseReasoningSummaryTextDeltaChunk(value)) {\n              controller.enqueue({\n                type: 'reasoning',\n                textDelta: value.delta,\n              });\n            } else if (\n              isResponseOutputItemDoneChunk(value) &&\n              value.item.type === 'function_call'\n            ) {\n              ongoingToolCalls[value.output_index] = undefined;\n              hasToolCalls = true;\n              controller.enqueue({\n                type: 'tool-call',\n                toolCallType: 'function',\n                toolCallId: value.item.call_id,\n                toolName: value.item.name,\n                args: value.item.arguments,\n              });\n            } else if (isResponseFinishedChunk(value)) {\n              finishReason = mapOpenAIResponseFinishReason({\n                finishReason: value.response.incomplete_details?.reason,\n                hasToolCalls,\n              });\n              promptTokens = value.response.usage.input_tokens;\n              completionTokens = value.response.usage.output_tokens;\n              cachedPromptTokens =\n                value.response.usage.input_tokens_details?.cached_tokens ??\n                cachedPromptTokens;\n              reasoningTokens =\n                value.response.usage.output_tokens_details?.reasoning_tokens ??\n                reasoningTokens;\n            } else if (isResponseAnnotationAddedChunk(value)) {\n              controller.enqueue({\n                type: 'source',\n                source: {\n                  sourceType: 'url',\n                  id: self.config.generateId?.() ?? generateId(),\n                  url: value.annotation.url,\n                  title: value.annotation.title,\n                },\n              });\n            } else if (isErrorChunk(value)) {\n              controller.enqueue({ type: 'error', error: value });\n            }\n          },\n\n          flush(controller) {\n            controller.enqueue({\n              type: 'finish',\n              finishReason,\n              usage: { promptTokens, completionTokens },\n              ...((cachedPromptTokens != null || reasoningTokens != null) && {\n                providerMetadata: {\n                  openai: {\n                    responseId,\n                    cachedPromptTokens,\n                    reasoningTokens,\n                  },\n                },\n              }),\n            });\n          },\n        }),\n      ),\n      rawCall: {\n        rawPrompt: undefined,\n        rawSettings: {},\n      },\n      rawResponse: { headers: responseHeaders },\n      request: { body: JSON.stringify(body) },\n      warnings,\n    };\n  }\n}\n\nconst usageSchema = z.object({\n  input_tokens: z.number(),\n  input_tokens_details: z\n    .object({ cached_tokens: z.number().nullish() })\n    .nullish(),\n  output_tokens: z.number(),\n  output_tokens_details: z\n    .object({ reasoning_tokens: z.number().nullish() })\n    .nullish(),\n});\n\nconst textDeltaChunkSchema = z.object({\n  type: z.literal('response.output_text.delta'),\n  delta: z.string(),\n});\n\nconst responseFinishedChunkSchema = z.object({\n  type: z.enum(['response.completed', 'response.incomplete']),\n  response: z.object({\n    incomplete_details: z.object({ reason: z.string() }).nullish(),\n    usage: usageSchema,\n  }),\n});\n\nconst responseCreatedChunkSchema = z.object({\n  type: z.literal('response.created'),\n  response: z.object({\n    id: z.string(),\n    created_at: z.number(),\n    model: z.string(),\n  }),\n});\n\nconst responseOutputItemDoneSchema = z.object({\n  type: z.literal('response.output_item.done'),\n  output_index: z.number(),\n  item: z.discriminatedUnion('type', [\n    z.object({\n      type: z.literal('message'),\n    }),\n    z.object({\n      type: z.literal('function_call'),\n      id: z.string(),\n      call_id: z.string(),\n      name: z.string(),\n      arguments: z.string(),\n      status: z.literal('completed'),\n    }),\n  ]),\n});\n\nconst responseFunctionCallArgumentsDeltaSchema = z.object({\n  type: z.literal('response.function_call_arguments.delta'),\n  item_id: z.string(),\n  output_index: z.number(),\n  delta: z.string(),\n});\n\nconst responseOutputItemAddedSchema = z.object({\n  type: z.literal('response.output_item.added'),\n  output_index: z.number(),\n  item: z.discriminatedUnion('type', [\n    z.object({\n      type: z.literal('message'),\n    }),\n    z.object({\n      type: z.literal('function_call'),\n      id: z.string(),\n      call_id: z.string(),\n      name: z.string(),\n      arguments: z.string(),\n    }),\n  ]),\n});\n\nconst responseAnnotationAddedSchema = z.object({\n  type: z.literal('response.output_text.annotation.added'),\n  annotation: z.object({\n    type: z.literal('url_citation'),\n    url: z.string(),\n    title: z.string(),\n  }),\n});\n\nconst responseReasoningSummaryTextDeltaSchema = z.object({\n  type: z.literal('response.reasoning_summary_text.delta'),\n  item_id: z.string(),\n  output_index: z.number(),\n  summary_index: z.number(),\n  delta: z.string(),\n});\n\nconst errorChunkSchema = z.object({\n  type: z.literal('error'),\n  code: z.string(),\n  message: z.string(),\n  param: z.string().nullish(),\n  sequence_number: z.number(),\n});\n\nconst openaiResponsesChunkSchema = z.union([\n  textDeltaChunkSchema,\n  responseFinishedChunkSchema,\n  responseCreatedChunkSchema,\n  responseOutputItemDoneSchema,\n  responseFunctionCallArgumentsDeltaSchema,\n  responseOutputItemAddedSchema,\n  responseAnnotationAddedSchema,\n  responseReasoningSummaryTextDeltaSchema,\n  errorChunkSchema,\n  z.object({ type: z.string() }).passthrough(), // fallback for unknown chunks\n]);\n\nfunction isTextDeltaChunk(\n  chunk: z.infer<typeof openaiResponsesChunkSchema>,\n): chunk is z.infer<typeof textDeltaChunkSchema> {\n  return chunk.type === 'response.output_text.delta';\n}\n\nfunction isResponseOutputItemDoneChunk(\n  chunk: z.infer<typeof openaiResponsesChunkSchema>,\n): chunk is z.infer<typeof responseOutputItemDoneSchema> {\n  return chunk.type === 'response.output_item.done';\n}\n\nfunction isResponseFinishedChunk(\n  chunk: z.infer<typeof openaiResponsesChunkSchema>,\n): chunk is z.infer<typeof responseFinishedChunkSchema> {\n  return (\n    chunk.type === 'response.completed' || chunk.type === 'response.incomplete'\n  );\n}\n\nfunction isResponseCreatedChunk(\n  chunk: z.infer<typeof openaiResponsesChunkSchema>,\n): chunk is z.infer<typeof responseCreatedChunkSchema> {\n  return chunk.type === 'response.created';\n}\n\nfunction isResponseFunctionCallArgumentsDeltaChunk(\n  chunk: z.infer<typeof openaiResponsesChunkSchema>,\n): chunk is z.infer<typeof responseFunctionCallArgumentsDeltaSchema> {\n  return chunk.type === 'response.function_call_arguments.delta';\n}\n\nfunction isResponseOutputItemAddedChunk(\n  chunk: z.infer<typeof openaiResponsesChunkSchema>,\n): chunk is z.infer<typeof responseOutputItemAddedSchema> {\n  return chunk.type === 'response.output_item.added';\n}\n\nfunction isResponseAnnotationAddedChunk(\n  chunk: z.infer<typeof openaiResponsesChunkSchema>,\n): chunk is z.infer<typeof responseAnnotationAddedSchema> {\n  return chunk.type === 'response.output_text.annotation.added';\n}\n\nfunction isResponseReasoningSummaryTextDeltaChunk(\n  chunk: z.infer<typeof openaiResponsesChunkSchema>,\n): chunk is z.infer<typeof responseReasoningSummaryTextDeltaSchema> {\n  return chunk.type === 'response.reasoning_summary_text.delta';\n}\n\nfunction isErrorChunk(\n  chunk: z.infer<typeof openaiResponsesChunkSchema>,\n): chunk is z.infer<typeof errorChunkSchema> {\n  return chunk.type === 'error';\n}\n\ntype ResponsesModelConfig = {\n  isReasoningModel: boolean;\n  systemMessageMode: 'remove' | 'system' | 'developer';\n  requiredAutoTruncation: boolean;\n};\n\nfunction getResponsesModelConfig(modelId: string): ResponsesModelConfig {\n  // o series reasoning models:\n  if (modelId.startsWith('o')) {\n    if (modelId.startsWith('o1-mini') || modelId.startsWith('o1-preview')) {\n      return {\n        isReasoningModel: true,\n        systemMessageMode: 'remove',\n        requiredAutoTruncation: false,\n      };\n    }\n\n    return {\n      isReasoningModel: true,\n      systemMessageMode: 'developer',\n      requiredAutoTruncation: false,\n    };\n  }\n\n  // gpt models:\n  return {\n    isReasoningModel: false,\n    systemMessageMode: 'system',\n    requiredAutoTruncation: false,\n  };\n}\n\nconst openaiResponsesProviderOptionsSchema = z.object({\n  metadata: z.any().nullish(),\n  parallelToolCalls: z.boolean().nullish(),\n  previousResponseId: z.string().nullish(),\n  store: z.boolean().nullish(),\n  user: z.string().nullish(),\n  reasoningEffort: z.string().nullish(),\n  strictSchemas: z.boolean().nullish(),\n  instructions: z.string().nullish(),\n  reasoningSummary: z.string().nullish(),\n});\n\nexport type OpenAIResponsesProviderOptions = z.infer<\n  typeof openaiResponsesProviderOptionsSchema\n>;\n","import {\n  LanguageModelV1CallWarning,\n  LanguageModelV1Prompt,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport { convertUint8ArrayToBase64 } from '@ai-sdk/provider-utils';\nimport { OpenAIResponsesPrompt } from './openai-responses-api-types';\n\nexport function convertToOpenAIResponsesMessages({\n  prompt,\n  systemMessageMode,\n}: {\n  prompt: LanguageModelV1Prompt;\n  systemMessageMode: 'system' | 'developer' | 'remove';\n}): {\n  messages: OpenAIResponsesPrompt;\n  warnings: Array<LanguageModelV1CallWarning>;\n} {\n  const messages: OpenAIResponsesPrompt = [];\n  const warnings: Array<LanguageModelV1CallWarning> = [];\n\n  for (const { role, content } of prompt) {\n    switch (role) {\n      case 'system': {\n        switch (systemMessageMode) {\n          case 'system': {\n            messages.push({ role: 'system', content });\n            break;\n          }\n          case 'developer': {\n            messages.push({ role: 'developer', content });\n            break;\n          }\n          case 'remove': {\n            warnings.push({\n              type: 'other',\n              message: 'system messages are removed for this model',\n            });\n            break;\n          }\n          default: {\n            const _exhaustiveCheck: never = systemMessageMode;\n            throw new Error(\n              `Unsupported system message mode: ${_exhaustiveCheck}`,\n            );\n          }\n        }\n        break;\n      }\n\n      case 'user': {\n        messages.push({\n          role: 'user',\n          content: content.map((part, index) => {\n            switch (part.type) {\n              case 'text': {\n                return { type: 'input_text', text: part.text };\n              }\n              case 'image': {\n                return {\n                  type: 'input_image',\n                  image_url:\n                    part.image instanceof URL\n                      ? part.image.toString()\n                      : `data:${\n                          part.mimeType ?? 'image/jpeg'\n                        };base64,${convertUint8ArrayToBase64(part.image)}`,\n\n                  // OpenAI specific extension: image detail\n                  detail: part.providerMetadata?.openai?.imageDetail,\n                };\n              }\n              case 'file': {\n                if (part.data instanceof URL) {\n                  // The AI SDK automatically downloads files for user file parts with URLs\n                  throw new UnsupportedFunctionalityError({\n                    functionality: 'File URLs in user messages',\n                  });\n                }\n\n                switch (part.mimeType) {\n                  case 'application/pdf': {\n                    return {\n                      type: 'input_file',\n                      filename: part.filename ?? `part-${index}.pdf`,\n                      file_data: `data:application/pdf;base64,${part.data}`,\n                    };\n                  }\n                  default: {\n                    throw new UnsupportedFunctionalityError({\n                      functionality:\n                        'Only PDF files are supported in user messages',\n                    });\n                  }\n                }\n              }\n            }\n          }),\n        });\n\n        break;\n      }\n\n      case 'assistant': {\n        for (const part of content) {\n          switch (part.type) {\n            case 'text': {\n              messages.push({\n                role: 'assistant',\n                content: [{ type: 'output_text', text: part.text }],\n              });\n              break;\n            }\n            case 'tool-call': {\n              messages.push({\n                type: 'function_call',\n                call_id: part.toolCallId,\n                name: part.toolName,\n                arguments: JSON.stringify(part.args),\n              });\n              break;\n            }\n          }\n        }\n\n        break;\n      }\n\n      case 'tool': {\n        for (const part of content) {\n          messages.push({\n            type: 'function_call_output',\n            call_id: part.toolCallId,\n            output: JSON.stringify(part.result),\n          });\n        }\n\n        break;\n      }\n\n      default: {\n        const _exhaustiveCheck: never = role;\n        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  return { messages, warnings };\n}\n","import { LanguageModelV1FinishReason } from '@ai-sdk/provider';\n\nexport function mapOpenAIResponseFinishReason({\n  finishReason,\n  hasToolCalls,\n}: {\n  finishReason: string | null | undefined;\n  hasToolCalls: boolean;\n}): LanguageModelV1FinishReason {\n  switch (finishReason) {\n    case undefined:\n    case null:\n      return hasToolCalls ? 'tool-calls' : 'stop';\n    case 'max_output_tokens':\n      return 'length';\n    case 'content_filter':\n      return 'content-filter';\n    default:\n      return hasToolCalls ? 'tool-calls' : 'unknown';\n  }\n}\n","import {\n  LanguageModelV1,\n  LanguageModelV1CallWarning,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport { OpenAIResponsesTool } from './openai-responses-api-types';\n\nexport function prepareResponsesTools({\n  mode,\n  strict,\n}: {\n  mode: Parameters<LanguageModelV1['doGenerate']>[0]['mode'] & {\n    type: 'regular';\n  };\n  strict: boolean;\n}): {\n  tools?: Array<OpenAIResponsesTool>;\n  tool_choice?:\n    | 'auto'\n    | 'none'\n    | 'required'\n    | { type: 'web_search_preview' }\n    | { type: 'function'; name: string };\n  toolWarnings: LanguageModelV1CallWarning[];\n} {\n  // when the tools array is empty, change it to undefined to prevent errors:\n  const tools = mode.tools?.length ? mode.tools : undefined;\n\n  const toolWarnings: LanguageModelV1CallWarning[] = [];\n\n  if (tools == null) {\n    return { tools: undefined, tool_choice: undefined, toolWarnings };\n  }\n\n  const toolChoice = mode.toolChoice;\n\n  const openaiTools: Array<OpenAIResponsesTool> = [];\n\n  for (const tool of tools) {\n    switch (tool.type) {\n      case 'function':\n        openaiTools.push({\n          type: 'function',\n          name: tool.name,\n          description: tool.description,\n          parameters: tool.parameters,\n          strict: strict ? true : undefined,\n        });\n        break;\n      case 'provider-defined':\n        switch (tool.id) {\n          case 'openai.web_search_preview':\n            openaiTools.push({\n              type: 'web_search_preview',\n              search_context_size: tool.args.searchContextSize as\n                | 'low'\n                | 'medium'\n                | 'high',\n              user_location: tool.args.userLocation as {\n                type: 'approximate';\n                city: string;\n                region: string;\n              },\n            });\n            break;\n          default:\n            toolWarnings.push({ type: 'unsupported-tool', tool });\n            break;\n        }\n        break;\n      default:\n        toolWarnings.push({ type: 'unsupported-tool', tool });\n        break;\n    }\n  }\n\n  if (toolChoice == null) {\n    return { tools: openaiTools, tool_choice: undefined, toolWarnings };\n  }\n\n  const type = toolChoice.type;\n\n  switch (type) {\n    case 'auto':\n    case 'none':\n    case 'required':\n      return { tools: openaiTools, tool_choice: type, toolWarnings };\n    case 'tool': {\n      if (toolChoice.toolName === 'web_search_preview') {\n        return {\n          tools: openaiTools,\n          tool_choice: {\n            type: 'web_search_preview',\n          },\n          toolWarnings,\n        };\n      }\n      return {\n        tools: openaiTools,\n        tool_choice: {\n          type: 'function',\n          name: toolChoice.toolName,\n        },\n        toolWarnings,\n      };\n    }\n    default: {\n      const _exhaustiveCheck: never = type;\n      throw new UnsupportedFunctionalityError({\n        functionality: `Unsupported tool choice type: ${_exhaustiveCheck}`,\n      });\n    }\n  }\n}\n","/**\n * Symbol used for identifying AI SDK Error instances.\n * Enables checking if an error is an instance of AISDKError across package versions.\n */\nconst marker = 'vercel.ai.error';\nconst symbol = Symbol.for(marker);\n\n/**\n * Custom error class for AI SDK related errors.\n * @extends Error\n */\nexport class AISDKError extends Error {\n  private readonly [symbol] = true; // used in isInstance\n\n  /**\n   * The underlying cause of the error, if any.\n   */\n  readonly cause?: unknown;\n\n  /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */\n  constructor({\n    name,\n    message,\n    cause,\n  }: {\n    name: string;\n    message: string;\n    cause?: unknown;\n  }) {\n    super(message);\n\n    this.name = name;\n    this.cause = cause;\n  }\n\n  /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */\n  static isInstance(error: unknown): error is AISDKError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  protected static hasMarker(error: unknown, marker: string): boolean {\n    const markerSymbol = Symbol.for(marker);\n    return (\n      error != null &&\n      typeof error === 'object' &&\n      markerSymbol in error &&\n      typeof error[markerSymbol] === 'boolean' &&\n      error[markerSymbol] === true\n    );\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_APICallError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class APICallError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly url: string;\n  readonly requestBodyValues: unknown;\n  readonly statusCode?: number;\n\n  readonly responseHeaders?: Record<string, string>;\n  readonly responseBody?: string;\n\n  readonly isRetryable: boolean;\n  readonly data?: unknown;\n\n  constructor({\n    message,\n    url,\n    requestBodyValues,\n    statusCode,\n    responseHeaders,\n    responseBody,\n    cause,\n    isRetryable = statusCode != null &&\n      (statusCode === 408 || // request timeout\n        statusCode === 409 || // conflict\n        statusCode === 429 || // too many requests\n        statusCode >= 500), // server error\n    data,\n  }: {\n    message: string;\n    url: string;\n    requestBodyValues: unknown;\n    statusCode?: number;\n    responseHeaders?: Record<string, string>;\n    responseBody?: string;\n    cause?: unknown;\n    isRetryable?: boolean;\n    data?: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.url = url;\n    this.requestBodyValues = requestBodyValues;\n    this.statusCode = statusCode;\n    this.responseHeaders = responseHeaders;\n    this.responseBody = responseBody;\n    this.isRetryable = isRetryable;\n    this.data = data;\n  }\n\n  static isInstance(error: unknown): error is APICallError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_EmptyResponseBodyError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class EmptyResponseBodyError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message = 'Empty response body' }: { message?: string } = {}) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is EmptyResponseBodyError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","export function getErrorMessage(error: unknown | undefined) {\n  if (error == null) {\n    return 'unknown error';\n  }\n\n  if (typeof error === 'string') {\n    return error;\n  }\n\n  if (error instanceof Error) {\n    return error.message;\n  }\n\n  return JSON.stringify(error);\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidArgumentError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * A function argument is invalid.\n */\nexport class InvalidArgumentError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly argument: string;\n\n  constructor({\n    message,\n    cause,\n    argument,\n  }: {\n    argument: string;\n    message: string;\n    cause?: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.argument = argument;\n  }\n\n  static isInstance(error: unknown): error is InvalidArgumentError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidPromptError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * A prompt is invalid. This error should be thrown by providers when they cannot\n * process a prompt.\n */\nexport class InvalidPromptError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly prompt: unknown;\n\n  constructor({\n    prompt,\n    message,\n    cause,\n  }: {\n    prompt: unknown;\n    message: string;\n    cause?: unknown;\n  }) {\n    super({ name, message: `Invalid prompt: ${message}`, cause });\n\n    this.prompt = prompt;\n  }\n\n  static isInstance(error: unknown): error is InvalidPromptError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidResponseDataError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * Server returned a response with invalid data content.\n * This should be thrown by providers when they cannot parse the response from the API.\n */\nexport class InvalidResponseDataError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly data: unknown;\n\n  constructor({\n    data,\n    message = `Invalid response data: ${JSON.stringify(data)}.`,\n  }: {\n    data: unknown;\n    message?: string;\n  }) {\n    super({ name, message });\n\n    this.data = data;\n  }\n\n  static isInstance(error: unknown): error is InvalidResponseDataError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\nimport { getErrorMessage } from './get-error-message';\n\nconst name = 'AI_JSONParseError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n// TODO v5: rename to ParseError\nexport class JSONParseError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly text: string;\n\n  constructor({ text, cause }: { text: string; cause: unknown }) {\n    super({\n      name,\n      message:\n        `JSON parsing failed: ` +\n        `Text: ${text}.\\n` +\n        `Error message: ${getErrorMessage(cause)}`,\n      cause,\n    });\n\n    this.text = text;\n  }\n\n  static isInstance(error: unknown): error is JSONParseError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_LoadAPIKeyError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class LoadAPIKeyError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message }: { message: string }) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is LoadAPIKeyError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_LoadSettingError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class LoadSettingError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message }: { message: string }) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is LoadSettingError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_NoContentGeneratedError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\nThrown when the AI provider fails to generate any content.\n */\nexport class NoContentGeneratedError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({\n    message = 'No content generated.',\n  }: { message?: string } = {}) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is NoContentGeneratedError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_NoSuchModelError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class NoSuchModelError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly modelId: string;\n  readonly modelType: 'languageModel' | 'textEmbeddingModel' | 'imageModel';\n\n  constructor({\n    errorName = name,\n    modelId,\n    modelType,\n    message = `No such ${modelType}: ${modelId}`,\n  }: {\n    errorName?: string;\n    modelId: string;\n    modelType: 'languageModel' | 'textEmbeddingModel' | 'imageModel';\n    message?: string;\n  }) {\n    super({ name: errorName, message });\n\n    this.modelId = modelId;\n    this.modelType = modelType;\n  }\n\n  static isInstance(error: unknown): error is NoSuchModelError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_TooManyEmbeddingValuesForCallError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class TooManyEmbeddingValuesForCallError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly provider: string;\n  readonly modelId: string;\n  readonly maxEmbeddingsPerCall: number;\n  readonly values: Array<unknown>;\n\n  constructor(options: {\n    provider: string;\n    modelId: string;\n    maxEmbeddingsPerCall: number;\n    values: Array<unknown>;\n  }) {\n    super({\n      name,\n      message:\n        `Too many values for a single embedding call. ` +\n        `The ${options.provider} model \"${options.modelId}\" can only embed up to ` +\n        `${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`,\n    });\n\n    this.provider = options.provider;\n    this.modelId = options.modelId;\n    this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;\n    this.values = options.values;\n  }\n\n  static isInstance(\n    error: unknown,\n  ): error is TooManyEmbeddingValuesForCallError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\nimport { getErrorMessage } from './get-error-message';\n\nconst name = 'AI_TypeValidationError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class TypeValidationError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly value: unknown;\n\n  constructor({ value, cause }: { value: unknown; cause: unknown }) {\n    super({\n      name,\n      message:\n        `Type validation failed: ` +\n        `Value: ${JSON.stringify(value)}.\\n` +\n        `Error message: ${getErrorMessage(cause)}`,\n      cause,\n    });\n\n    this.value = value;\n  }\n\n  static isInstance(error: unknown): error is TypeValidationError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * Wraps an error into a TypeValidationError.\n   * If the cause is already a TypeValidationError with the same value, it returns the cause.\n   * Otherwise, it creates a new TypeValidationError.\n   *\n   * @param {Object} params - The parameters for wrapping the error.\n   * @param {unknown} params.value - The value that failed validation.\n   * @param {unknown} params.cause - The original error or cause of the validation failure.\n   * @returns {TypeValidationError} A TypeValidationError instance.\n   */\n  static wrap({\n    value,\n    cause,\n  }: {\n    value: unknown;\n    cause: unknown;\n  }): TypeValidationError {\n    return TypeValidationError.isInstance(cause) && cause.value === value\n      ? cause\n      : new TypeValidationError({ value, cause });\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_UnsupportedFunctionalityError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class UnsupportedFunctionalityError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly functionality: string;\n\n  constructor({\n    functionality,\n    message = `'${functionality}' functionality not supported.`,\n  }: {\n    functionality: string;\n    message?: string;\n  }) {\n    super({ name, message });\n    this.functionality = functionality;\n  }\n\n  static isInstance(error: unknown): error is UnsupportedFunctionalityError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { JSONArray, JSONObject, JSONValue } from './json-value';\n\nexport function isJSONValue(value: unknown): value is JSONValue {\n  if (\n    value === null ||\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    typeof value === 'boolean'\n  ) {\n    return true;\n  }\n\n  if (Array.isArray(value)) {\n    return value.every(isJSONValue);\n  }\n\n  if (typeof value === 'object') {\n    return Object.entries(value).every(\n      ([key, val]) => typeof key === 'string' && isJSONValue(val),\n    );\n  }\n\n  return false;\n}\n\nexport function isJSONArray(value: unknown): value is JSONArray {\n  return Array.isArray(value) && value.every(isJSONValue);\n}\n\nexport function isJSONObject(value: unknown): value is JSONObject {\n  return (\n    value != null &&\n    typeof value === 'object' &&\n    Object.entries(value).every(\n      ([key, val]) => typeof key === 'string' && isJSONValue(val),\n    )\n  );\n}\n","export function combineHeaders(\n  ...headers: Array<Record<string, string | undefined> | undefined>\n): Record<string, string | undefined> {\n  return headers.reduce(\n    (combinedHeaders, currentHeaders) => ({\n      ...combinedHeaders,\n      ...(currentHeaders ?? {}),\n    }),\n    {},\n  ) as Record<string, string | undefined>;\n}\n","/**\n * Converts an AsyncIterator to a ReadableStream.\n *\n * @template T - The type of elements produced by the AsyncIterator.\n * @param { <T>} iterator - The AsyncIterator to convert.\n * @returns {ReadableStream<T>} - A ReadableStream that provides the same data as the AsyncIterator.\n */\nexport function convertAsyncIteratorToReadableStream<T>(\n  iterator: AsyncIterator<T>,\n): ReadableStream<T> {\n  return new ReadableStream<T>({\n    /**\n     * Called when the consumer wants to pull more data from the stream.\n     *\n     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.\n     * @returns {Promise<void>}\n     */\n    async pull(controller) {\n      try {\n        const { value, done } = await iterator.next();\n        if (done) {\n          controller.close();\n        } else {\n          controller.enqueue(value);\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    /**\n     * Called when the consumer cancels the stream.\n     */\n    cancel() {},\n  });\n}\n","/**\n * Creates a Promise that resolves after a specified delay\n * @param delayInMs - The delay duration in milliseconds. If null or undefined, resolves immediately.\n * @returns A Promise that resolves after the specified delay\n */\nexport async function delay(delayInMs?: number | null): Promise<void> {\n  return delayInMs == null\n    ? Promise.resolve()\n    : new Promise(resolve => setTimeout(resolve, delayInMs));\n}\n","export type EventSourceChunk = {\n  event: string | undefined;\n  data: string;\n  id?: string;\n  retry?: number;\n};\n\nexport function createEventSourceParserStream() {\n  let buffer = '';\n  let event: string | undefined = undefined;\n  let data: string[] = [];\n  let lastEventId: string | undefined = undefined;\n  let retry: number | undefined = undefined;\n\n  function parseLine(\n    line: string,\n    controller: TransformStreamDefaultController<EventSourceChunk>,\n  ) {\n    // Empty line means dispatch the event\n    if (line === '') {\n      dispatchEvent(controller);\n      return;\n    }\n\n    // Comments start with colon\n    if (line.startsWith(':')) {\n      return;\n    }\n\n    // Field parsing\n    const colonIndex = line.indexOf(':');\n    if (colonIndex === -1) {\n      // field with no value\n      handleField(line, '');\n      return;\n    }\n\n    const field = line.slice(0, colonIndex);\n    // If there's a space after the colon, it should be ignored\n    const valueStart = colonIndex + 1;\n    const value =\n      valueStart < line.length && line[valueStart] === ' '\n        ? line.slice(valueStart + 1)\n        : line.slice(valueStart);\n\n    handleField(field, value);\n  }\n\n  function dispatchEvent(\n    controller: TransformStreamDefaultController<EventSourceChunk>,\n  ) {\n    if (data.length > 0) {\n      controller.enqueue({\n        event,\n        data: data.join('\\n'),\n        id: lastEventId,\n        retry,\n      });\n\n      // Reset data but keep lastEventId as per spec\n      data = [];\n      event = undefined;\n      retry = undefined;\n    }\n  }\n\n  function handleField(field: string, value: string) {\n    switch (field) {\n      case 'event':\n        event = value;\n        break;\n      case 'data':\n        data.push(value);\n        break;\n      case 'id':\n        lastEventId = value;\n        break;\n      case 'retry':\n        const parsedRetry = parseInt(value, 10);\n        if (!isNaN(parsedRetry)) {\n          retry = parsedRetry;\n        }\n        break;\n    }\n  }\n\n  return new TransformStream<string, EventSourceChunk>({\n    transform(chunk, controller) {\n      const { lines, incompleteLine } = splitLines(buffer, chunk);\n\n      buffer = incompleteLine;\n\n      // using for loop for performance\n      for (let i = 0; i < lines.length; i++) {\n        parseLine(lines[i], controller);\n      }\n    },\n\n    flush(controller) {\n      parseLine(buffer, controller);\n      dispatchEvent(controller);\n    },\n  });\n}\n\n// performance: send in already scanned buffer separately, do not scan again\nfunction splitLines(buffer: string, chunk: string) {\n  const lines: Array<string> = [];\n  let currentLine = buffer;\n\n  // using for loop for performance\n  for (let i = 0; i < chunk.length; ) {\n    const char = chunk[i++];\n\n    // order is performance-optimized\n    if (char === '\\n') {\n      // Standalone LF\n      lines.push(currentLine);\n      currentLine = '';\n    } else if (char === '\\r') {\n      lines.push(currentLine);\n      currentLine = '';\n      if (chunk[i] === '\\n') {\n        i++; // CRLF case: Skip the LF character\n      }\n    } else {\n      currentLine += char;\n    }\n  }\n\n  return { lines, incompleteLine: currentLine };\n}\n","/**\nExtracts the headers from a response object and returns them as a key-value object.\n\n@param response - The response object to extract headers from.\n@returns The headers as a key-value object.\n*/\nexport function extractResponseHeaders(\n  response: Response,\n): Record<string, string> {\n  const headers: Record<string, string> = {};\n  response.headers.forEach((value, key) => {\n    headers[key] = value;\n  });\n  return headers;\n}\n","import { InvalidArgumentError } from '@ai-sdk/provider';\nimport { customAlphabet } from 'nanoid/non-secure';\n\n/**\nCreates an ID generator.\nThe total length of the ID is the sum of the prefix, separator, and random part length.\nNon-secure.\n\n@param alphabet - The alphabet to use for the ID. Default: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.\n@param prefix - The prefix of the ID to generate. Default: ''.\n@param separator - The separator between the prefix and the random part of the ID. Default: '-'.\n@param size - The size of the random part of the ID to generate. Default: 16.\n */\n// TODO 5.0 breaking change: change the return type to IDGenerator\nexport const createIdGenerator = ({\n  prefix,\n  size: defaultSize = 16,\n  alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n  separator = '-',\n}: {\n  prefix?: string;\n  separator?: string;\n  size?: number;\n  alphabet?: string;\n} = {}): ((size?: number) => string) => {\n  const generator = customAlphabet(alphabet, defaultSize);\n\n  if (prefix == null) {\n    return generator;\n  }\n\n  // check that the prefix is not part of the alphabet (otherwise prefix checking can fail randomly)\n  if (alphabet.includes(separator)) {\n    throw new InvalidArgumentError({\n      argument: 'separator',\n      message: `The separator \"${separator}\" must not be part of the alphabet \"${alphabet}\".`,\n    });\n  }\n\n  return size => `${prefix}${separator}${generator(size)}`;\n};\n\n/**\nA function that generates an ID.\n */\nexport type IDGenerator = () => string;\n\n/**\nGenerates a 16-character random string to use for IDs. Not secure.\n\n@param size - The size of the ID to generate. Default: 16.\n */\nexport const generateId = createIdGenerator();\n","export function getErrorMessage(error: unknown | undefined) {\n  if (error == null) {\n    return 'unknown error';\n  }\n\n  if (typeof error === 'string') {\n    return error;\n  }\n\n  if (error instanceof Error) {\n    return error.message;\n  }\n\n  return JSON.stringify(error);\n}\n","import { APICallError } from '@ai-sdk/provider';\nimport { FetchFunction } from './fetch-function';\nimport { removeUndefinedEntries } from './remove-undefined-entries';\nimport { ResponseHandler } from './response-handler';\nimport { isAbortError } from './is-abort-error';\nimport { extractResponseHeaders } from './extract-response-headers';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => globalThis.fetch;\n\nexport const getFromApi = async <T>({\n  url,\n  headers = {},\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch(),\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  failedResponseHandler: ResponseHandler<Error>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: 'GET',\n      headers: removeUndefinedEntries(headers),\n      signal: abortSignal,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.ok) {\n      let errorInformation: {\n        value: Error;\n        responseHeaders?: Record<string, string> | undefined;\n      };\n\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: {},\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n\n        throw new APICallError({\n          message: 'Failed to process error response',\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: {},\n        });\n      }\n\n      throw errorInformation.value;\n    }\n\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: {},\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n\n      throw new APICallError({\n        message: 'Failed to process successful response',\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: {},\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n\n    if (error instanceof TypeError && error.message === 'fetch failed') {\n      const cause = (error as any).cause;\n      if (cause != null) {\n        throw new APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          isRetryable: true,\n          requestBodyValues: {},\n        });\n      }\n    }\n\n    throw error;\n  }\n};\n","/**\n * Removes entries from a record where the value is null or undefined.\n * @param record - The input object whose entries may be null or undefined.\n * @returns A new object containing only entries with non-null and non-undefined values.\n */\nexport function removeUndefinedEntries<T>(\n  record: Record<string, T | undefined>,\n): Record<string, T> {\n  return Object.fromEntries(\n    Object.entries(record).filter(([_key, value]) => value != null),\n  ) as Record<string, T>;\n}\n","export function isAbortError(error: unknown): error is Error {\n  return (\n    error instanceof Error &&\n    (error.name === 'AbortError' || error.name === 'TimeoutError')\n  );\n}\n","import { LoadAPIKeyError } from '@ai-sdk/provider';\n\nexport function loadApiKey({\n  apiKey,\n  environmentVariableName,\n  apiKeyParameterName = 'apiKey',\n  description,\n}: {\n  apiKey: string | undefined;\n  environmentVariableName: string;\n  apiKeyParameterName?: string;\n  description: string;\n}): string {\n  if (typeof apiKey === 'string') {\n    return apiKey;\n  }\n\n  if (apiKey != null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string.`,\n    });\n  }\n\n  if (typeof process === 'undefined') {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`,\n    });\n  }\n\n  apiKey = process.env[environmentVariableName];\n\n  if (apiKey == null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`,\n    });\n  }\n\n  if (typeof apiKey !== 'string') {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`,\n    });\n  }\n\n  return apiKey;\n}\n","/**\n * Loads an optional `string` setting from the environment or a parameter.\n *\n * @param settingValue - The setting value.\n * @param environmentVariableName - The environment variable name.\n * @returns The setting value.\n */\nexport function loadOptionalSetting({\n  settingValue,\n  environmentVariableName,\n}: {\n  settingValue: string | undefined;\n  environmentVariableName: string;\n}): string | undefined {\n  if (typeof settingValue === 'string') {\n    return settingValue;\n  }\n\n  if (settingValue != null || typeof process === 'undefined') {\n    return undefined;\n  }\n\n  settingValue = process.env[environmentVariableName];\n\n  if (settingValue == null || typeof settingValue !== 'string') {\n    return undefined;\n  }\n\n  return settingValue;\n}\n","import { LoadSettingError } from '@ai-sdk/provider';\n\n/**\n * Loads a `string` setting from the environment or a parameter.\n *\n * @param settingValue - The setting value.\n * @param environmentVariableName - The environment variable name.\n * @param settingName - The setting name.\n * @param description - The description of the setting.\n * @returns The setting value.\n */\nexport function loadSetting({\n  settingValue,\n  environmentVariableName,\n  settingName,\n  description,\n}: {\n  settingValue: string | undefined;\n  environmentVariableName: string;\n  settingName: string;\n  description: string;\n}): string {\n  if (typeof settingValue === 'string') {\n    return settingValue;\n  }\n\n  if (settingValue != null) {\n    throw new LoadSettingError({\n      message: `${description} setting must be a string.`,\n    });\n  }\n\n  if (typeof process === 'undefined') {\n    throw new LoadSettingError({\n      message:\n        `${description} setting is missing. ` +\n        `Pass it using the '${settingName}' parameter. ` +\n        `Environment variables is not supported in this environment.`,\n    });\n  }\n\n  settingValue = process.env[environmentVariableName];\n\n  if (settingValue == null) {\n    throw new LoadSettingError({\n      message:\n        `${description} setting is missing. ` +\n        `Pass it using the '${settingName}' parameter ` +\n        `or the ${environmentVariableName} environment variable.`,\n    });\n  }\n\n  if (typeof settingValue !== 'string') {\n    throw new LoadSettingError({\n      message:\n        `${description} setting must be a string. ` +\n        `The value of the ${environmentVariableName} environment variable is not a string.`,\n    });\n  }\n\n  return settingValue;\n}\n","import {\n  JSONParseError,\n  JSONValue,\n  TypeValidationError,\n} from '@ai-sdk/provider';\nimport SecureJSON from 'secure-json-parse';\nimport { ZodSchema } from 'zod';\nimport { safeValidateTypes, validateTypes } from './validate-types';\nimport { Validator } from './validator';\n\n/**\n * Parses a JSON string into an unknown object.\n *\n * @param text - The JSON string to parse.\n * @returns {JSONValue} - The parsed JSON object.\n */\nexport function parseJSON(options: {\n  text: string;\n  schema?: undefined;\n}): JSONValue;\n/**\n * Parses a JSON string into a strongly-typed object using the provided schema.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Validator<T>} schema - The schema to use for parsing the JSON.\n * @returns {T} - The parsed object.\n */\nexport function parseJSON<T>(options: {\n  text: string;\n  schema: ZodSchema<T> | Validator<T>;\n}): T;\nexport function parseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: ZodSchema<T> | Validator<T>;\n}): T {\n  try {\n    const value = SecureJSON.parse(text);\n\n    if (schema == null) {\n      return value;\n    }\n\n    return validateTypes({ value, schema });\n  } catch (error) {\n    if (\n      JSONParseError.isInstance(error) ||\n      TypeValidationError.isInstance(error)\n    ) {\n      throw error;\n    }\n\n    throw new JSONParseError({ text, cause: error });\n  }\n}\n\nexport type ParseResult<T> =\n  | { success: true; value: T; rawValue: unknown }\n  | { success: false; error: JSONParseError | TypeValidationError };\n\n/**\n * Safely parses a JSON string and returns the result as an object of type `unknown`.\n *\n * @param text - The JSON string to parse.\n * @returns {object} Either an object with `success: true` and the parsed data, or an object with `success: false` and the error that occurred.\n */\nexport function safeParseJSON(options: {\n  text: string;\n  schema?: undefined;\n}): ParseResult<JSONValue>;\n/**\n * Safely parses a JSON string into a strongly-typed object, using a provided schema to validate the object.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Validator<T>} schema - The schema to use for parsing the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport function safeParseJSON<T>(options: {\n  text: string;\n  schema: ZodSchema<T> | Validator<T>;\n}): ParseResult<T>;\nexport function safeParseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: ZodSchema<T> | Validator<T>;\n}): ParseResult<T> {\n  try {\n    const value = SecureJSON.parse(text);\n\n    if (schema == null) {\n      return { success: true, value: value as T, rawValue: value };\n    }\n\n    const validationResult = safeValidateTypes({ value, schema });\n\n    return validationResult.success\n      ? { ...validationResult, rawValue: value }\n      : validationResult;\n  } catch (error) {\n    return {\n      success: false,\n      error: JSONParseError.isInstance(error)\n        ? error\n        : new JSONParseError({ text, cause: error }),\n    };\n  }\n}\n\nexport function isParsableJson(input: string): boolean {\n  try {\n    SecureJSON.parse(input);\n    return true;\n  } catch {\n    return false;\n  }\n}\n","import { TypeValidationError } from '@ai-sdk/provider';\nimport { z } from 'zod';\nimport { Validator, asValidator } from './validator';\n\n/**\n * Validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The object to validate.\n * @param {Validator<T>} options.schema - The schema to use for validating the JSON.\n * @returns {T} - The typed object.\n */\nexport function validateTypes<T>({\n  value,\n  schema: inputSchema,\n}: {\n  value: unknown;\n  schema: z.Schema<T, z.ZodTypeDef, any> | Validator<T>;\n}): T {\n  const result = safeValidateTypes({ value, schema: inputSchema });\n\n  if (!result.success) {\n    throw TypeValidationError.wrap({ value, cause: result.error });\n  }\n\n  return result.value;\n}\n\n/**\n * Safely validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The JSON object to validate.\n * @param {Validator<T>} options.schema - The schema to use for validating the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport function safeValidateTypes<T>({\n  value,\n  schema,\n}: {\n  value: unknown;\n  schema: z.Schema<T, z.ZodTypeDef, any> | Validator<T>;\n}):\n  | { success: true; value: T }\n  | { success: false; error: TypeValidationError } {\n  const validator = asValidator(schema);\n\n  try {\n    if (validator.validate == null) {\n      return { success: true, value: value as T };\n    }\n\n    const result = validator.validate(value);\n\n    if (result.success) {\n      return result;\n    }\n\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: result.error }),\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: error }),\n    };\n  }\n}\n","import { z } from 'zod';\n\n/**\n * Used to mark validator functions so we can support both Zod and custom schemas.\n */\nexport const validatorSymbol = Symbol.for('vercel.ai.validator');\n\nexport type ValidationResult<OBJECT> =\n  | { success: true; value: OBJECT }\n  | { success: false; error: Error };\n\nexport type Validator<OBJECT = unknown> = {\n  /**\n   * Used to mark validator functions so we can support both Zod and custom schemas.\n   */\n  [validatorSymbol]: true;\n\n  /**\n   * Optional. Validates that the structure of a value matches this schema,\n   * and returns a typed version of the value if it does.\n   */\n  readonly validate?: (value: unknown) => ValidationResult<OBJECT>;\n};\n\n/**\n * Create a validator.\n *\n * @param validate A validation function for the schema.\n */\nexport function validator<OBJECT>(\n  validate?: undefined | ((value: unknown) => ValidationResult<OBJECT>),\n): Validator<OBJECT> {\n  return { [validatorSymbol]: true, validate };\n}\n\nexport function isValidator(value: unknown): value is Validator {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    validatorSymbol in value &&\n    value[validatorSymbol] === true &&\n    'validate' in value\n  );\n}\n\nexport function asValidator<OBJECT>(\n  value: Validator<OBJECT> | z.Schema<OBJECT, z.ZodTypeDef, any>,\n): Validator<OBJECT> {\n  return isValidator(value) ? value : zodValidator(value);\n}\n\nexport function zodValidator<OBJECT>(\n  zodSchema: z.Schema<OBJECT, z.ZodTypeDef, any>,\n): Validator<OBJECT> {\n  return validator(value => {\n    const result = zodSchema.safeParse(value);\n    return result.success\n      ? { success: true, value: result.data }\n      : { success: false, error: result.error };\n  });\n}\n","import { InvalidArgumentError } from '@ai-sdk/provider';\nimport { safeValidateTypes } from './validate-types';\nimport { z } from 'zod';\n\nexport function parseProviderOptions<T>({\n  provider,\n  providerOptions,\n  schema,\n}: {\n  provider: string;\n  providerOptions: Record<string, unknown> | undefined;\n  schema: z.ZodSchema<T>;\n}): T | undefined {\n  if (providerOptions?.[provider] == null) {\n    return undefined;\n  }\n\n  const parsedProviderOptions = safeValidateTypes({\n    value: providerOptions[provider],\n    schema,\n  });\n\n  if (!parsedProviderOptions.success) {\n    throw new InvalidArgumentError({\n      argument: 'providerOptions',\n      message: `invalid ${provider} provider options`,\n      cause: parsedProviderOptions.error,\n    });\n  }\n\n  return parsedProviderOptions.value;\n}\n","import { APICallError } from '@ai-sdk/provider';\nimport { extractResponseHeaders } from './extract-response-headers';\nimport { FetchFunction } from './fetch-function';\nimport { isAbortError } from './is-abort-error';\nimport { removeUndefinedEntries } from './remove-undefined-entries';\nimport { ResponseHandler } from './response-handler';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => globalThis.fetch;\n\nexport const postJsonToApi = async <T>({\n  url,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch,\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  body: unknown;\n  failedResponseHandler: ResponseHandler<APICallError>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) =>\n  postToApi({\n    url,\n    headers: {\n      'Content-Type': 'application/json',\n      ...headers,\n    },\n    body: {\n      content: JSON.stringify(body),\n      values: body,\n    },\n    failedResponseHandler,\n    successfulResponseHandler,\n    abortSignal,\n    fetch,\n  });\n\nexport const postFormDataToApi = async <T>({\n  url,\n  headers,\n  formData,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch,\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  formData: FormData;\n  failedResponseHandler: ResponseHandler<APICallError>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) =>\n  postToApi({\n    url,\n    headers,\n    body: {\n      content: formData,\n      values: Object.fromEntries((formData as any).entries()),\n    },\n    failedResponseHandler,\n    successfulResponseHandler,\n    abortSignal,\n    fetch,\n  });\n\nexport const postToApi = async <T>({\n  url,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch(),\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  body: {\n    content: string | FormData | Uint8Array;\n    values: unknown;\n  };\n  failedResponseHandler: ResponseHandler<Error>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: removeUndefinedEntries(headers),\n      body: body.content,\n      signal: abortSignal,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.ok) {\n      let errorInformation: {\n        value: Error;\n        responseHeaders?: Record<string, string> | undefined;\n      };\n\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: body.values,\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n\n        throw new APICallError({\n          message: 'Failed to process error response',\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: body.values,\n        });\n      }\n\n      throw errorInformation.value;\n    }\n\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: body.values,\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n\n      throw new APICallError({\n        message: 'Failed to process successful response',\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: body.values,\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n\n    // unwrap original error when fetch failed (for easier debugging):\n    if (error instanceof TypeError && error.message === 'fetch failed') {\n      const cause = (error as any).cause;\n\n      if (cause != null) {\n        // Failed to connect to server:\n        throw new APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          requestBodyValues: body.values,\n          isRetryable: true, // retry when network error\n        });\n      }\n    }\n\n    throw error;\n  }\n};\n","export type Resolvable<T> =\n  | T // Raw value\n  | Promise<T> // Promise of value\n  | (() => T) // Function returning value\n  | (() => Promise<T>); // Function returning promise of value\n\n/**\n * Resolves a value that could be a raw value, a Promise, a function returning a value,\n * or a function returning a Promise.\n */\nexport async function resolve<T>(value: Resolvable<T>): Promise<T> {\n  // If it's a function, call it to get the value/promise\n  if (typeof value === 'function') {\n    value = (value as Function)();\n  }\n\n  // Otherwise just resolve whatever we got (value or promise)\n  return Promise.resolve(value as T);\n}\n","import { APICallError, EmptyResponseBodyError } from '@ai-sdk/provider';\nimport { ZodSchema } from 'zod';\nimport {\n  createEventSourceParserStream,\n  EventSourceChunk,\n} from './event-source-parser-stream';\nimport { extractResponseHeaders } from './extract-response-headers';\nimport { parseJSON, ParseResult, safeParseJSON } from './parse-json';\n\nexport type ResponseHandler<RETURN_TYPE> = (options: {\n  url: string;\n  requestBodyValues: unknown;\n  response: Response;\n}) => PromiseLike<{\n  value: RETURN_TYPE;\n  rawValue?: unknown;\n  responseHeaders?: Record<string, string>;\n}>;\n\nexport const createJsonErrorResponseHandler =\n  <T>({\n    errorSchema,\n    errorToMessage,\n    isRetryable,\n  }: {\n    errorSchema: ZodSchema<T>;\n    errorToMessage: (error: T) => string;\n    isRetryable?: (response: Response, error?: T) => boolean;\n  }): ResponseHandler<APICallError> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseBody = await response.text();\n    const responseHeaders = extractResponseHeaders(response);\n\n    // Some providers return an empty response body for some errors:\n    if (responseBody.trim() === '') {\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: response.statusText,\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          isRetryable: isRetryable?.(response),\n        }),\n      };\n    }\n\n    // resilient parsing in case the response is not JSON or does not match the schema:\n    try {\n      const parsedError = parseJSON({\n        text: responseBody,\n        schema: errorSchema,\n      });\n\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: errorToMessage(parsedError),\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          data: parsedError,\n          isRetryable: isRetryable?.(response, parsedError),\n        }),\n      };\n    } catch (parseError) {\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: response.statusText,\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          isRetryable: isRetryable?.(response),\n        }),\n      };\n    }\n  };\n\nexport const createEventSourceResponseHandler =\n  <T>(\n    chunkSchema: ZodSchema<T>,\n  ): ResponseHandler<ReadableStream<ParseResult<T>>> =>\n  async ({ response }: { response: Response }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (response.body == null) {\n      throw new EmptyResponseBodyError({});\n    }\n\n    return {\n      responseHeaders,\n      value: response.body\n        .pipeThrough(new TextDecoderStream())\n        .pipeThrough(createEventSourceParserStream())\n        .pipeThrough(\n          new TransformStream<EventSourceChunk, ParseResult<T>>({\n            transform({ data }, controller) {\n              // ignore the 'DONE' event that e.g. OpenAI sends:\n              if (data === '[DONE]') {\n                return;\n              }\n\n              controller.enqueue(\n                safeParseJSON({\n                  text: data,\n                  schema: chunkSchema,\n                }),\n              );\n            },\n          }),\n        ),\n    };\n  };\n\nexport const createJsonStreamResponseHandler =\n  <T>(\n    chunkSchema: ZodSchema<T>,\n  ): ResponseHandler<ReadableStream<ParseResult<T>>> =>\n  async ({ response }: { response: Response }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (response.body == null) {\n      throw new EmptyResponseBodyError({});\n    }\n\n    let buffer = '';\n\n    return {\n      responseHeaders,\n      value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(\n        new TransformStream<string, ParseResult<T>>({\n          transform(chunkText, controller) {\n            if (chunkText.endsWith('\\n')) {\n              controller.enqueue(\n                safeParseJSON({\n                  text: buffer + chunkText,\n                  schema: chunkSchema,\n                }),\n              );\n              buffer = '';\n            } else {\n              buffer += chunkText;\n            }\n          },\n        }),\n      ),\n    };\n  };\n\nexport const createJsonResponseHandler =\n  <T>(responseSchema: ZodSchema<T>): ResponseHandler<T> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseBody = await response.text();\n\n    const parsedResult = safeParseJSON({\n      text: responseBody,\n      schema: responseSchema,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!parsedResult.success) {\n      throw new APICallError({\n        message: 'Invalid JSON response',\n        cause: parsedResult.error,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        url,\n        requestBodyValues,\n      });\n    }\n\n    return {\n      responseHeaders,\n      value: parsedResult.value,\n      rawValue: parsedResult.rawValue,\n    };\n  };\n\nexport const createBinaryResponseHandler =\n  (): ResponseHandler<Uint8Array> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.body) {\n      throw new APICallError({\n        message: 'Response body is empty',\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody: undefined,\n      });\n    }\n\n    try {\n      const buffer = await response.arrayBuffer();\n      return {\n        responseHeaders,\n        value: new Uint8Array(buffer),\n      };\n    } catch (error) {\n      throw new APICallError({\n        message: 'Failed to read response as array buffer',\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody: undefined,\n        cause: error,\n      });\n    }\n  };\n\nexport const createStatusCodeErrorResponseHandler =\n  (): ResponseHandler<APICallError> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseHeaders = extractResponseHeaders(response);\n    const responseBody = await response.text();\n\n    return {\n      responseHeaders,\n      value: new APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues: requestBodyValues as Record<string, unknown>,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n      }),\n    };\n  };\n","// btoa and atob need to be invoked as a function call, not as a method call.\n// Otherwise CloudFlare will throw a\n// \"TypeError: Illegal invocation: function called with incorrect this reference\"\nconst { btoa, atob } = globalThis;\n\nexport function convertBase64ToUint8Array(base64String: string) {\n  const base64Url = base64String.replace(/-/g, '+').replace(/_/g, '/');\n  const latin1string = atob(base64Url);\n  return Uint8Array.from(latin1string, byte => byte.codePointAt(0)!);\n}\n\nexport function convertUint8ArrayToBase64(array: Uint8Array): string {\n  let latin1string = '';\n\n  // Note: regular for loop to support older JavaScript versions that\n  // do not support for..of on Uint8Array\n  for (let i = 0; i < array.length; i++) {\n    latin1string += String.fromCodePoint(array[i]);\n  }\n\n  return btoa(latin1string);\n}\n","export function withoutTrailingSlash(url: string | undefined) {\n  return url?.replace(/\\/$/, '');\n}\n","import {\n  OpenAIChatLanguageModel,\n  OpenAIChatSettings,\n  OpenAICompletionLanguageModel,\n  OpenAICompletionSettings,\n  OpenAIEmbeddingModel,\n  OpenAIEmbeddingSettings,\n  OpenAIImageModel,\n  OpenAIImageSettings,\n  OpenAIResponsesLanguageModel,\n  OpenAITranscriptionModel,\n} from '@ai-sdk/openai/internal';\nimport {\n  EmbeddingModelV1,\n  LanguageModelV1,\n  ProviderV1,\n  ImageModelV1,\n  TranscriptionModelV1,\n} from '@ai-sdk/provider';\nimport { FetchFunction, loadApiKey, loadSetting } from '@ai-sdk/provider-utils';\n\nexport interface AzureOpenAIProvider extends ProviderV1 {\n  (deploymentId: string, settings?: OpenAIChatSettings): LanguageModelV1;\n\n  /**\nCreates an Azure OpenAI chat model for text generation.\n   */\n  languageModel(\n    deploymentId: string,\n    settings?: OpenAIChatSettings,\n  ): LanguageModelV1;\n\n  /**\nCreates an Azure OpenAI chat model for text generation.\n   */\n  chat(deploymentId: string, settings?: OpenAIChatSettings): LanguageModelV1;\n\n  /**\nCreates an Azure OpenAI responses API model for text generation.\n   */\n  responses(deploymentId: string): LanguageModelV1;\n\n  /**\nCreates an Azure OpenAI completion model for text generation.\n   */\n  completion(\n    deploymentId: string,\n    settings?: OpenAICompletionSettings,\n  ): LanguageModelV1;\n\n  /**\n@deprecated Use `textEmbeddingModel` instead.\n   */\n  embedding(\n    deploymentId: string,\n    settings?: OpenAIEmbeddingSettings,\n  ): EmbeddingModelV1<string>;\n\n  /**\n   * Creates an Azure OpenAI DALL-E model for image generation.\n   * @deprecated Use `imageModel` instead.\n   */\n  image(deploymentId: string, settings?: OpenAIImageSettings): ImageModelV1;\n\n  /**\n   * Creates an Azure OpenAI DALL-E model for image generation.\n   */\n  imageModel(\n    deploymentId: string,\n    settings?: OpenAIImageSettings,\n  ): ImageModelV1;\n\n  /**\n@deprecated Use `textEmbeddingModel` instead.\n   */\n  textEmbedding(\n    deploymentId: string,\n    settings?: OpenAIEmbeddingSettings,\n  ): EmbeddingModelV1<string>;\n\n  /**\nCreates an Azure OpenAI model for text embeddings.\n   */\n  textEmbeddingModel(\n    deploymentId: string,\n    settings?: OpenAIEmbeddingSettings,\n  ): EmbeddingModelV1<string>;\n\n  /**\n   * Creates an Azure OpenAI model for audio transcription.\n   */\n  transcription(deploymentId: string): TranscriptionModelV1;\n}\n\nexport interface AzureOpenAIProviderSettings {\n  /**\nName of the Azure OpenAI resource. Either this or `baseURL` can be used.\n\nThe resource name is used in the assembled URL: `https://{resourceName}.openai.azure.com/openai/deployments/{modelId}{path}`.\n     */\n  resourceName?: string;\n\n  /**\nUse a different URL prefix for API calls, e.g. to use proxy servers. Either this or `resourceName` can be used.\nWhen a baseURL is provided, the resourceName is ignored.\n\nWith a baseURL, the resolved URL is `{baseURL}/{modelId}{path}`.\n   */\n  baseURL?: string;\n\n  /**\nAPI key for authenticating requests.\n     */\n  apiKey?: string;\n\n  /**\nCustom headers to include in the requests.\n     */\n  headers?: Record<string, string>;\n\n  /**\nCustom fetch implementation. You can use it as a middleware to intercept requests,\nor to provide a custom fetch implementation for e.g. testing.\n    */\n  fetch?: FetchFunction;\n\n  /**\nCustom api version to use. Defaults to `2024-10-01-preview`.\n    */\n  apiVersion?: string;\n}\n\n/**\nCreate an Azure OpenAI provider instance.\n */\nexport function createAzure(\n  options: AzureOpenAIProviderSettings = {},\n): AzureOpenAIProvider {\n  const getHeaders = () => ({\n    'api-key': loadApiKey({\n      apiKey: options.apiKey,\n      environmentVariableName: 'AZURE_API_KEY',\n      description: 'Azure OpenAI',\n    }),\n    ...options.headers,\n  });\n\n  const getResourceName = () =>\n    loadSetting({\n      settingValue: options.resourceName,\n      settingName: 'resourceName',\n      environmentVariableName: 'AZURE_RESOURCE_NAME',\n      description: 'Azure OpenAI resource name',\n    });\n\n  const apiVersion = options.apiVersion ?? '2025-03-01-preview';\n  const url = ({ path, modelId }: { path: string; modelId: string }) => {\n    if (path === '/responses') {\n      return options.baseURL\n        ? `${options.baseURL}${path}?api-version=${apiVersion}`\n        : `https://${getResourceName()}.openai.azure.com/openai/responses?api-version=${apiVersion}`;\n    }\n\n    // Default URL format for other endpoints\n    return options.baseURL\n      ? `${options.baseURL}/${modelId}${path}?api-version=${apiVersion}`\n      : `https://${getResourceName()}.openai.azure.com/openai/deployments/${modelId}${path}?api-version=${apiVersion}`;\n  };\n\n  const createChatModel = (\n    deploymentName: string,\n    settings: OpenAIChatSettings = {},\n  ) =>\n    new OpenAIChatLanguageModel(deploymentName, settings, {\n      provider: 'azure-openai.chat',\n      url,\n      headers: getHeaders,\n      compatibility: 'strict',\n      fetch: options.fetch,\n    });\n\n  const createCompletionModel = (\n    modelId: string,\n    settings: OpenAICompletionSettings = {},\n  ) =>\n    new OpenAICompletionLanguageModel(modelId, settings, {\n      provider: 'azure-openai.completion',\n      url,\n      compatibility: 'strict',\n      headers: getHeaders,\n      fetch: options.fetch,\n    });\n\n  const createEmbeddingModel = (\n    modelId: string,\n    settings: OpenAIEmbeddingSettings = {},\n  ) =>\n    new OpenAIEmbeddingModel(modelId, settings, {\n      provider: 'azure-openai.embeddings',\n      headers: getHeaders,\n      url,\n      fetch: options.fetch,\n    });\n\n  const createResponsesModel = (modelId: string) =>\n    new OpenAIResponsesLanguageModel(modelId, {\n      provider: 'azure-openai.responses',\n      url,\n      headers: getHeaders,\n      fetch: options.fetch,\n    });\n\n  const createImageModel = (\n    modelId: string,\n    settings: OpenAIImageSettings = {},\n  ) =>\n    new OpenAIImageModel(modelId, settings, {\n      provider: 'azure-openai.image',\n      url,\n      headers: getHeaders,\n      fetch: options.fetch,\n    });\n\n  const createTranscriptionModel = (modelId: string) =>\n    new OpenAITranscriptionModel(modelId, {\n      provider: 'azure-openai.transcription',\n      url,\n      headers: getHeaders,\n      fetch: options.fetch,\n    });\n\n  const provider = function (\n    deploymentId: string,\n    settings?: OpenAIChatSettings | OpenAICompletionSettings,\n  ) {\n    if (new.target) {\n      throw new Error(\n        'The Azure OpenAI model function cannot be called with the new keyword.',\n      );\n    }\n\n    return createChatModel(deploymentId, settings as OpenAIChatSettings);\n  };\n\n  provider.languageModel = createChatModel;\n  provider.chat = createChatModel;\n  provider.completion = createCompletionModel;\n  provider.embedding = createEmbeddingModel;\n  provider.image = createImageModel;\n  provider.imageModel = createImageModel;\n  provider.textEmbedding = createEmbeddingModel;\n  provider.textEmbeddingModel = createEmbeddingModel;\n  provider.responses = createResponsesModel;\n  provider.transcription = createTranscriptionModel;\n  return provider;\n}\n\n/**\nDefault Azure OpenAI provider instance.\n */\nexport const azure = createAzure();\n","/**\n * Symbol used for identifying AI SDK Error instances.\n * Enables checking if an error is an instance of AISDKError across package versions.\n */\nconst marker = 'vercel.ai.error';\nconst symbol = Symbol.for(marker);\n\n/**\n * Custom error class for AI SDK related errors.\n * @extends Error\n */\nexport class AISDKError extends Error {\n  private readonly [symbol] = true; // used in isInstance\n\n  /**\n   * The underlying cause of the error, if any.\n   */\n  readonly cause?: unknown;\n\n  /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */\n  constructor({\n    name,\n    message,\n    cause,\n  }: {\n    name: string;\n    message: string;\n    cause?: unknown;\n  }) {\n    super(message);\n\n    this.name = name;\n    this.cause = cause;\n  }\n\n  /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */\n  static isInstance(error: unknown): error is AISDKError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  protected static hasMarker(error: unknown, marker: string): boolean {\n    const markerSymbol = Symbol.for(marker);\n    return (\n      error != null &&\n      typeof error === 'object' &&\n      markerSymbol in error &&\n      typeof error[markerSymbol] === 'boolean' &&\n      error[markerSymbol] === true\n    );\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_APICallError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class APICallError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly url: string;\n  readonly requestBodyValues: unknown;\n  readonly statusCode?: number;\n\n  readonly responseHeaders?: Record<string, string>;\n  readonly responseBody?: string;\n\n  readonly isRetryable: boolean;\n  readonly data?: unknown;\n\n  constructor({\n    message,\n    url,\n    requestBodyValues,\n    statusCode,\n    responseHeaders,\n    responseBody,\n    cause,\n    isRetryable = statusCode != null &&\n      (statusCode === 408 || // request timeout\n        statusCode === 409 || // conflict\n        statusCode === 429 || // too many requests\n        statusCode >= 500), // server error\n    data,\n  }: {\n    message: string;\n    url: string;\n    requestBodyValues: unknown;\n    statusCode?: number;\n    responseHeaders?: Record<string, string>;\n    responseBody?: string;\n    cause?: unknown;\n    isRetryable?: boolean;\n    data?: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.url = url;\n    this.requestBodyValues = requestBodyValues;\n    this.statusCode = statusCode;\n    this.responseHeaders = responseHeaders;\n    this.responseBody = responseBody;\n    this.isRetryable = isRetryable;\n    this.data = data;\n  }\n\n  static isInstance(error: unknown): error is APICallError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_EmptyResponseBodyError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class EmptyResponseBodyError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message = 'Empty response body' }: { message?: string } = {}) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is EmptyResponseBodyError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","export function getErrorMessage(error: unknown | undefined) {\n  if (error == null) {\n    return 'unknown error';\n  }\n\n  if (typeof error === 'string') {\n    return error;\n  }\n\n  if (error instanceof Error) {\n    return error.message;\n  }\n\n  return JSON.stringify(error);\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidArgumentError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * A function argument is invalid.\n */\nexport class InvalidArgumentError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly argument: string;\n\n  constructor({\n    message,\n    cause,\n    argument,\n  }: {\n    argument: string;\n    message: string;\n    cause?: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.argument = argument;\n  }\n\n  static isInstance(error: unknown): error is InvalidArgumentError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidPromptError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * A prompt is invalid. This error should be thrown by providers when they cannot\n * process a prompt.\n */\nexport class InvalidPromptError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly prompt: unknown;\n\n  constructor({\n    prompt,\n    message,\n    cause,\n  }: {\n    prompt: unknown;\n    message: string;\n    cause?: unknown;\n  }) {\n    super({ name, message: `Invalid prompt: ${message}`, cause });\n\n    this.prompt = prompt;\n  }\n\n  static isInstance(error: unknown): error is InvalidPromptError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidResponseDataError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * Server returned a response with invalid data content.\n * This should be thrown by providers when they cannot parse the response from the API.\n */\nexport class InvalidResponseDataError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly data: unknown;\n\n  constructor({\n    data,\n    message = `Invalid response data: ${JSON.stringify(data)}.`,\n  }: {\n    data: unknown;\n    message?: string;\n  }) {\n    super({ name, message });\n\n    this.data = data;\n  }\n\n  static isInstance(error: unknown): error is InvalidResponseDataError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\nimport { getErrorMessage } from './get-error-message';\n\nconst name = 'AI_JSONParseError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n// TODO v5: rename to ParseError\nexport class JSONParseError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly text: string;\n\n  constructor({ text, cause }: { text: string; cause: unknown }) {\n    super({\n      name,\n      message:\n        `JSON parsing failed: ` +\n        `Text: ${text}.\\n` +\n        `Error message: ${getErrorMessage(cause)}`,\n      cause,\n    });\n\n    this.text = text;\n  }\n\n  static isInstance(error: unknown): error is JSONParseError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_LoadAPIKeyError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class LoadAPIKeyError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message }: { message: string }) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is LoadAPIKeyError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_LoadSettingError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class LoadSettingError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message }: { message: string }) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is LoadSettingError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_NoContentGeneratedError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\nThrown when the AI provider fails to generate any content.\n */\nexport class NoContentGeneratedError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({\n    message = 'No content generated.',\n  }: { message?: string } = {}) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is NoContentGeneratedError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_NoSuchModelError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class NoSuchModelError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly modelId: string;\n  readonly modelType: 'languageModel' | 'textEmbeddingModel' | 'imageModel';\n\n  constructor({\n    errorName = name,\n    modelId,\n    modelType,\n    message = `No such ${modelType}: ${modelId}`,\n  }: {\n    errorName?: string;\n    modelId: string;\n    modelType: 'languageModel' | 'textEmbeddingModel' | 'imageModel';\n    message?: string;\n  }) {\n    super({ name: errorName, message });\n\n    this.modelId = modelId;\n    this.modelType = modelType;\n  }\n\n  static isInstance(error: unknown): error is NoSuchModelError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_TooManyEmbeddingValuesForCallError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class TooManyEmbeddingValuesForCallError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly provider: string;\n  readonly modelId: string;\n  readonly maxEmbeddingsPerCall: number;\n  readonly values: Array<unknown>;\n\n  constructor(options: {\n    provider: string;\n    modelId: string;\n    maxEmbeddingsPerCall: number;\n    values: Array<unknown>;\n  }) {\n    super({\n      name,\n      message:\n        `Too many values for a single embedding call. ` +\n        `The ${options.provider} model \"${options.modelId}\" can only embed up to ` +\n        `${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`,\n    });\n\n    this.provider = options.provider;\n    this.modelId = options.modelId;\n    this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;\n    this.values = options.values;\n  }\n\n  static isInstance(\n    error: unknown,\n  ): error is TooManyEmbeddingValuesForCallError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\nimport { getErrorMessage } from './get-error-message';\n\nconst name = 'AI_TypeValidationError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class TypeValidationError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly value: unknown;\n\n  constructor({ value, cause }: { value: unknown; cause: unknown }) {\n    super({\n      name,\n      message:\n        `Type validation failed: ` +\n        `Value: ${JSON.stringify(value)}.\\n` +\n        `Error message: ${getErrorMessage(cause)}`,\n      cause,\n    });\n\n    this.value = value;\n  }\n\n  static isInstance(error: unknown): error is TypeValidationError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * Wraps an error into a TypeValidationError.\n   * If the cause is already a TypeValidationError with the same value, it returns the cause.\n   * Otherwise, it creates a new TypeValidationError.\n   *\n   * @param {Object} params - The parameters for wrapping the error.\n   * @param {unknown} params.value - The value that failed validation.\n   * @param {unknown} params.cause - The original error or cause of the validation failure.\n   * @returns {TypeValidationError} A TypeValidationError instance.\n   */\n  static wrap({\n    value,\n    cause,\n  }: {\n    value: unknown;\n    cause: unknown;\n  }): TypeValidationError {\n    return TypeValidationError.isInstance(cause) && cause.value === value\n      ? cause\n      : new TypeValidationError({ value, cause });\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_UnsupportedFunctionalityError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class UnsupportedFunctionalityError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly functionality: string;\n\n  constructor({\n    functionality,\n    message = `'${functionality}' functionality not supported.`,\n  }: {\n    functionality: string;\n    message?: string;\n  }) {\n    super({ name, message });\n    this.functionality = functionality;\n  }\n\n  static isInstance(error: unknown): error is UnsupportedFunctionalityError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { JSONArray, JSONObject, JSONValue } from './json-value';\n\nexport function isJSONValue(value: unknown): value is JSONValue {\n  if (\n    value === null ||\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    typeof value === 'boolean'\n  ) {\n    return true;\n  }\n\n  if (Array.isArray(value)) {\n    return value.every(isJSONValue);\n  }\n\n  if (typeof value === 'object') {\n    return Object.entries(value).every(\n      ([key, val]) => typeof key === 'string' && isJSONValue(val),\n    );\n  }\n\n  return false;\n}\n\nexport function isJSONArray(value: unknown): value is JSONArray {\n  return Array.isArray(value) && value.every(isJSONValue);\n}\n\nexport function isJSONObject(value: unknown): value is JSONObject {\n  return (\n    value != null &&\n    typeof value === 'object' &&\n    Object.entries(value).every(\n      ([key, val]) => typeof key === 'string' && isJSONValue(val),\n    )\n  );\n}\n","export function combineHeaders(\n  ...headers: Array<Record<string, string | undefined> | undefined>\n): Record<string, string | undefined> {\n  return headers.reduce(\n    (combinedHeaders, currentHeaders) => ({\n      ...combinedHeaders,\n      ...(currentHeaders ?? {}),\n    }),\n    {},\n  ) as Record<string, string | undefined>;\n}\n","/**\n * Converts an AsyncIterator to a ReadableStream.\n *\n * @template T - The type of elements produced by the AsyncIterator.\n * @param { <T>} iterator - The AsyncIterator to convert.\n * @returns {ReadableStream<T>} - A ReadableStream that provides the same data as the AsyncIterator.\n */\nexport function convertAsyncIteratorToReadableStream<T>(\n  iterator: AsyncIterator<T>,\n): ReadableStream<T> {\n  return new ReadableStream<T>({\n    /**\n     * Called when the consumer wants to pull more data from the stream.\n     *\n     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.\n     * @returns {Promise<void>}\n     */\n    async pull(controller) {\n      try {\n        const { value, done } = await iterator.next();\n        if (done) {\n          controller.close();\n        } else {\n          controller.enqueue(value);\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    /**\n     * Called when the consumer cancels the stream.\n     */\n    cancel() {},\n  });\n}\n","/**\n * Creates a Promise that resolves after a specified delay\n * @param delayInMs - The delay duration in milliseconds. If null or undefined, resolves immediately.\n * @returns A Promise that resolves after the specified delay\n */\nexport async function delay(delayInMs?: number | null): Promise<void> {\n  return delayInMs == null\n    ? Promise.resolve()\n    : new Promise(resolve => setTimeout(resolve, delayInMs));\n}\n","export type EventSourceChunk = {\n  event: string | undefined;\n  data: string;\n  id?: string;\n  retry?: number;\n};\n\nexport function createEventSourceParserStream() {\n  let buffer = '';\n  let event: string | undefined = undefined;\n  let data: string[] = [];\n  let lastEventId: string | undefined = undefined;\n  let retry: number | undefined = undefined;\n\n  function parseLine(\n    line: string,\n    controller: TransformStreamDefaultController<EventSourceChunk>,\n  ) {\n    // Empty line means dispatch the event\n    if (line === '') {\n      dispatchEvent(controller);\n      return;\n    }\n\n    // Comments start with colon\n    if (line.startsWith(':')) {\n      return;\n    }\n\n    // Field parsing\n    const colonIndex = line.indexOf(':');\n    if (colonIndex === -1) {\n      // field with no value\n      handleField(line, '');\n      return;\n    }\n\n    const field = line.slice(0, colonIndex);\n    // If there's a space after the colon, it should be ignored\n    const valueStart = colonIndex + 1;\n    const value =\n      valueStart < line.length && line[valueStart] === ' '\n        ? line.slice(valueStart + 1)\n        : line.slice(valueStart);\n\n    handleField(field, value);\n  }\n\n  function dispatchEvent(\n    controller: TransformStreamDefaultController<EventSourceChunk>,\n  ) {\n    if (data.length > 0) {\n      controller.enqueue({\n        event,\n        data: data.join('\\n'),\n        id: lastEventId,\n        retry,\n      });\n\n      // Reset data but keep lastEventId as per spec\n      data = [];\n      event = undefined;\n      retry = undefined;\n    }\n  }\n\n  function handleField(field: string, value: string) {\n    switch (field) {\n      case 'event':\n        event = value;\n        break;\n      case 'data':\n        data.push(value);\n        break;\n      case 'id':\n        lastEventId = value;\n        break;\n      case 'retry':\n        const parsedRetry = parseInt(value, 10);\n        if (!isNaN(parsedRetry)) {\n          retry = parsedRetry;\n        }\n        break;\n    }\n  }\n\n  return new TransformStream<string, EventSourceChunk>({\n    transform(chunk, controller) {\n      const { lines, incompleteLine } = splitLines(buffer, chunk);\n\n      buffer = incompleteLine;\n\n      // using for loop for performance\n      for (let i = 0; i < lines.length; i++) {\n        parseLine(lines[i], controller);\n      }\n    },\n\n    flush(controller) {\n      parseLine(buffer, controller);\n      dispatchEvent(controller);\n    },\n  });\n}\n\n// performance: send in already scanned buffer separately, do not scan again\nfunction splitLines(buffer: string, chunk: string) {\n  const lines: Array<string> = [];\n  let currentLine = buffer;\n\n  // using for loop for performance\n  for (let i = 0; i < chunk.length; ) {\n    const char = chunk[i++];\n\n    // order is performance-optimized\n    if (char === '\\n') {\n      // Standalone LF\n      lines.push(currentLine);\n      currentLine = '';\n    } else if (char === '\\r') {\n      lines.push(currentLine);\n      currentLine = '';\n      if (chunk[i] === '\\n') {\n        i++; // CRLF case: Skip the LF character\n      }\n    } else {\n      currentLine += char;\n    }\n  }\n\n  return { lines, incompleteLine: currentLine };\n}\n","/**\nExtracts the headers from a response object and returns them as a key-value object.\n\n@param response - The response object to extract headers from.\n@returns The headers as a key-value object.\n*/\nexport function extractResponseHeaders(\n  response: Response,\n): Record<string, string> {\n  const headers: Record<string, string> = {};\n  response.headers.forEach((value, key) => {\n    headers[key] = value;\n  });\n  return headers;\n}\n","import { InvalidArgumentError } from '@ai-sdk/provider';\nimport { customAlphabet } from 'nanoid/non-secure';\n\n/**\nCreates an ID generator.\nThe total length of the ID is the sum of the prefix, separator, and random part length.\nNon-secure.\n\n@param alphabet - The alphabet to use for the ID. Default: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.\n@param prefix - The prefix of the ID to generate. Default: ''.\n@param separator - The separator between the prefix and the random part of the ID. Default: '-'.\n@param size - The size of the random part of the ID to generate. Default: 16.\n */\n// TODO 5.0 breaking change: change the return type to IDGenerator\nexport const createIdGenerator = ({\n  prefix,\n  size: defaultSize = 16,\n  alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n  separator = '-',\n}: {\n  prefix?: string;\n  separator?: string;\n  size?: number;\n  alphabet?: string;\n} = {}): ((size?: number) => string) => {\n  const generator = customAlphabet(alphabet, defaultSize);\n\n  if (prefix == null) {\n    return generator;\n  }\n\n  // check that the prefix is not part of the alphabet (otherwise prefix checking can fail randomly)\n  if (alphabet.includes(separator)) {\n    throw new InvalidArgumentError({\n      argument: 'separator',\n      message: `The separator \"${separator}\" must not be part of the alphabet \"${alphabet}\".`,\n    });\n  }\n\n  return size => `${prefix}${separator}${generator(size)}`;\n};\n\n/**\nA function that generates an ID.\n */\nexport type IDGenerator = () => string;\n\n/**\nGenerates a 16-character random string to use for IDs. Not secure.\n\n@param size - The size of the ID to generate. Default: 16.\n */\nexport const generateId = createIdGenerator();\n","export function getErrorMessage(error: unknown | undefined) {\n  if (error == null) {\n    return 'unknown error';\n  }\n\n  if (typeof error === 'string') {\n    return error;\n  }\n\n  if (error instanceof Error) {\n    return error.message;\n  }\n\n  return JSON.stringify(error);\n}\n","import { APICallError } from '@ai-sdk/provider';\nimport { FetchFunction } from './fetch-function';\nimport { removeUndefinedEntries } from './remove-undefined-entries';\nimport { ResponseHandler } from './response-handler';\nimport { isAbortError } from './is-abort-error';\nimport { extractResponseHeaders } from './extract-response-headers';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => globalThis.fetch;\n\nexport const getFromApi = async <T>({\n  url,\n  headers = {},\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch(),\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  failedResponseHandler: ResponseHandler<Error>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: 'GET',\n      headers: removeUndefinedEntries(headers),\n      signal: abortSignal,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.ok) {\n      let errorInformation: {\n        value: Error;\n        responseHeaders?: Record<string, string> | undefined;\n      };\n\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: {},\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n\n        throw new APICallError({\n          message: 'Failed to process error response',\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: {},\n        });\n      }\n\n      throw errorInformation.value;\n    }\n\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: {},\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n\n      throw new APICallError({\n        message: 'Failed to process successful response',\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: {},\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n\n    if (error instanceof TypeError && error.message === 'fetch failed') {\n      const cause = (error as any).cause;\n      if (cause != null) {\n        throw new APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          isRetryable: true,\n          requestBodyValues: {},\n        });\n      }\n    }\n\n    throw error;\n  }\n};\n","/**\n * Removes entries from a record where the value is null or undefined.\n * @param record - The input object whose entries may be null or undefined.\n * @returns A new object containing only entries with non-null and non-undefined values.\n */\nexport function removeUndefinedEntries<T>(\n  record: Record<string, T | undefined>,\n): Record<string, T> {\n  return Object.fromEntries(\n    Object.entries(record).filter(([_key, value]) => value != null),\n  ) as Record<string, T>;\n}\n","export function isAbortError(error: unknown): error is Error {\n  return (\n    error instanceof Error &&\n    (error.name === 'AbortError' || error.name === 'TimeoutError')\n  );\n}\n","import { LoadAPIKeyError } from '@ai-sdk/provider';\n\nexport function loadApiKey({\n  apiKey,\n  environmentVariableName,\n  apiKeyParameterName = 'apiKey',\n  description,\n}: {\n  apiKey: string | undefined;\n  environmentVariableName: string;\n  apiKeyParameterName?: string;\n  description: string;\n}): string {\n  if (typeof apiKey === 'string') {\n    return apiKey;\n  }\n\n  if (apiKey != null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string.`,\n    });\n  }\n\n  if (typeof process === 'undefined') {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`,\n    });\n  }\n\n  apiKey = process.env[environmentVariableName];\n\n  if (apiKey == null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`,\n    });\n  }\n\n  if (typeof apiKey !== 'string') {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`,\n    });\n  }\n\n  return apiKey;\n}\n","/**\n * Loads an optional `string` setting from the environment or a parameter.\n *\n * @param settingValue - The setting value.\n * @param environmentVariableName - The environment variable name.\n * @returns The setting value.\n */\nexport function loadOptionalSetting({\n  settingValue,\n  environmentVariableName,\n}: {\n  settingValue: string | undefined;\n  environmentVariableName: string;\n}): string | undefined {\n  if (typeof settingValue === 'string') {\n    return settingValue;\n  }\n\n  if (settingValue != null || typeof process === 'undefined') {\n    return undefined;\n  }\n\n  settingValue = process.env[environmentVariableName];\n\n  if (settingValue == null || typeof settingValue !== 'string') {\n    return undefined;\n  }\n\n  return settingValue;\n}\n","import { LoadSettingError } from '@ai-sdk/provider';\n\n/**\n * Loads a `string` setting from the environment or a parameter.\n *\n * @param settingValue - The setting value.\n * @param environmentVariableName - The environment variable name.\n * @param settingName - The setting name.\n * @param description - The description of the setting.\n * @returns The setting value.\n */\nexport function loadSetting({\n  settingValue,\n  environmentVariableName,\n  settingName,\n  description,\n}: {\n  settingValue: string | undefined;\n  environmentVariableName: string;\n  settingName: string;\n  description: string;\n}): string {\n  if (typeof settingValue === 'string') {\n    return settingValue;\n  }\n\n  if (settingValue != null) {\n    throw new LoadSettingError({\n      message: `${description} setting must be a string.`,\n    });\n  }\n\n  if (typeof process === 'undefined') {\n    throw new LoadSettingError({\n      message:\n        `${description} setting is missing. ` +\n        `Pass it using the '${settingName}' parameter. ` +\n        `Environment variables is not supported in this environment.`,\n    });\n  }\n\n  settingValue = process.env[environmentVariableName];\n\n  if (settingValue == null) {\n    throw new LoadSettingError({\n      message:\n        `${description} setting is missing. ` +\n        `Pass it using the '${settingName}' parameter ` +\n        `or the ${environmentVariableName} environment variable.`,\n    });\n  }\n\n  if (typeof settingValue !== 'string') {\n    throw new LoadSettingError({\n      message:\n        `${description} setting must be a string. ` +\n        `The value of the ${environmentVariableName} environment variable is not a string.`,\n    });\n  }\n\n  return settingValue;\n}\n","import {\n  JSONParseError,\n  JSONValue,\n  TypeValidationError,\n} from '@ai-sdk/provider';\nimport SecureJSON from 'secure-json-parse';\nimport { ZodSchema } from 'zod';\nimport { safeValidateTypes, validateTypes } from './validate-types';\nimport { Validator } from './validator';\n\n/**\n * Parses a JSON string into an unknown object.\n *\n * @param text - The JSON string to parse.\n * @returns {JSONValue} - The parsed JSON object.\n */\nexport function parseJSON(options: {\n  text: string;\n  schema?: undefined;\n}): JSONValue;\n/**\n * Parses a JSON string into a strongly-typed object using the provided schema.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Validator<T>} schema - The schema to use for parsing the JSON.\n * @returns {T} - The parsed object.\n */\nexport function parseJSON<T>(options: {\n  text: string;\n  schema: ZodSchema<T> | Validator<T>;\n}): T;\nexport function parseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: ZodSchema<T> | Validator<T>;\n}): T {\n  try {\n    const value = SecureJSON.parse(text);\n\n    if (schema == null) {\n      return value;\n    }\n\n    return validateTypes({ value, schema });\n  } catch (error) {\n    if (\n      JSONParseError.isInstance(error) ||\n      TypeValidationError.isInstance(error)\n    ) {\n      throw error;\n    }\n\n    throw new JSONParseError({ text, cause: error });\n  }\n}\n\nexport type ParseResult<T> =\n  | { success: true; value: T; rawValue: unknown }\n  | { success: false; error: JSONParseError | TypeValidationError };\n\n/**\n * Safely parses a JSON string and returns the result as an object of type `unknown`.\n *\n * @param text - The JSON string to parse.\n * @returns {object} Either an object with `success: true` and the parsed data, or an object with `success: false` and the error that occurred.\n */\nexport function safeParseJSON(options: {\n  text: string;\n  schema?: undefined;\n}): ParseResult<JSONValue>;\n/**\n * Safely parses a JSON string into a strongly-typed object, using a provided schema to validate the object.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Validator<T>} schema - The schema to use for parsing the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport function safeParseJSON<T>(options: {\n  text: string;\n  schema: ZodSchema<T> | Validator<T>;\n}): ParseResult<T>;\nexport function safeParseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: ZodSchema<T> | Validator<T>;\n}): ParseResult<T> {\n  try {\n    const value = SecureJSON.parse(text);\n\n    if (schema == null) {\n      return { success: true, value: value as T, rawValue: value };\n    }\n\n    const validationResult = safeValidateTypes({ value, schema });\n\n    return validationResult.success\n      ? { ...validationResult, rawValue: value }\n      : validationResult;\n  } catch (error) {\n    return {\n      success: false,\n      error: JSONParseError.isInstance(error)\n        ? error\n        : new JSONParseError({ text, cause: error }),\n    };\n  }\n}\n\nexport function isParsableJson(input: string): boolean {\n  try {\n    SecureJSON.parse(input);\n    return true;\n  } catch {\n    return false;\n  }\n}\n","import { TypeValidationError } from '@ai-sdk/provider';\nimport { z } from 'zod';\nimport { Validator, asValidator } from './validator';\n\n/**\n * Validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The object to validate.\n * @param {Validator<T>} options.schema - The schema to use for validating the JSON.\n * @returns {T} - The typed object.\n */\nexport function validateTypes<T>({\n  value,\n  schema: inputSchema,\n}: {\n  value: unknown;\n  schema: z.Schema<T, z.ZodTypeDef, any> | Validator<T>;\n}): T {\n  const result = safeValidateTypes({ value, schema: inputSchema });\n\n  if (!result.success) {\n    throw TypeValidationError.wrap({ value, cause: result.error });\n  }\n\n  return result.value;\n}\n\n/**\n * Safely validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The JSON object to validate.\n * @param {Validator<T>} options.schema - The schema to use for validating the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport function safeValidateTypes<T>({\n  value,\n  schema,\n}: {\n  value: unknown;\n  schema: z.Schema<T, z.ZodTypeDef, any> | Validator<T>;\n}):\n  | { success: true; value: T }\n  | { success: false; error: TypeValidationError } {\n  const validator = asValidator(schema);\n\n  try {\n    if (validator.validate == null) {\n      return { success: true, value: value as T };\n    }\n\n    const result = validator.validate(value);\n\n    if (result.success) {\n      return result;\n    }\n\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: result.error }),\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: error }),\n    };\n  }\n}\n","import { z } from 'zod';\n\n/**\n * Used to mark validator functions so we can support both Zod and custom schemas.\n */\nexport const validatorSymbol = Symbol.for('vercel.ai.validator');\n\nexport type ValidationResult<OBJECT> =\n  | { success: true; value: OBJECT }\n  | { success: false; error: Error };\n\nexport type Validator<OBJECT = unknown> = {\n  /**\n   * Used to mark validator functions so we can support both Zod and custom schemas.\n   */\n  [validatorSymbol]: true;\n\n  /**\n   * Optional. Validates that the structure of a value matches this schema,\n   * and returns a typed version of the value if it does.\n   */\n  readonly validate?: (value: unknown) => ValidationResult<OBJECT>;\n};\n\n/**\n * Create a validator.\n *\n * @param validate A validation function for the schema.\n */\nexport function validator<OBJECT>(\n  validate?: undefined | ((value: unknown) => ValidationResult<OBJECT>),\n): Validator<OBJECT> {\n  return { [validatorSymbol]: true, validate };\n}\n\nexport function isValidator(value: unknown): value is Validator {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    validatorSymbol in value &&\n    value[validatorSymbol] === true &&\n    'validate' in value\n  );\n}\n\nexport function asValidator<OBJECT>(\n  value: Validator<OBJECT> | z.Schema<OBJECT, z.ZodTypeDef, any>,\n): Validator<OBJECT> {\n  return isValidator(value) ? value : zodValidator(value);\n}\n\nexport function zodValidator<OBJECT>(\n  zodSchema: z.Schema<OBJECT, z.ZodTypeDef, any>,\n): Validator<OBJECT> {\n  return validator(value => {\n    const result = zodSchema.safeParse(value);\n    return result.success\n      ? { success: true, value: result.data }\n      : { success: false, error: result.error };\n  });\n}\n","import { InvalidArgumentError } from '@ai-sdk/provider';\nimport { safeValidateTypes } from './validate-types';\nimport { z } from 'zod';\n\nexport function parseProviderOptions<T>({\n  provider,\n  providerOptions,\n  schema,\n}: {\n  provider: string;\n  providerOptions: Record<string, unknown> | undefined;\n  schema: z.ZodSchema<T>;\n}): T | undefined {\n  if (providerOptions?.[provider] == null) {\n    return undefined;\n  }\n\n  const parsedProviderOptions = safeValidateTypes({\n    value: providerOptions[provider],\n    schema,\n  });\n\n  if (!parsedProviderOptions.success) {\n    throw new InvalidArgumentError({\n      argument: 'providerOptions',\n      message: `invalid ${provider} provider options`,\n      cause: parsedProviderOptions.error,\n    });\n  }\n\n  return parsedProviderOptions.value;\n}\n","import { APICallError } from '@ai-sdk/provider';\nimport { extractResponseHeaders } from './extract-response-headers';\nimport { FetchFunction } from './fetch-function';\nimport { isAbortError } from './is-abort-error';\nimport { removeUndefinedEntries } from './remove-undefined-entries';\nimport { ResponseHandler } from './response-handler';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => globalThis.fetch;\n\nexport const postJsonToApi = async <T>({\n  url,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch,\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  body: unknown;\n  failedResponseHandler: ResponseHandler<APICallError>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) =>\n  postToApi({\n    url,\n    headers: {\n      'Content-Type': 'application/json',\n      ...headers,\n    },\n    body: {\n      content: JSON.stringify(body),\n      values: body,\n    },\n    failedResponseHandler,\n    successfulResponseHandler,\n    abortSignal,\n    fetch,\n  });\n\nexport const postFormDataToApi = async <T>({\n  url,\n  headers,\n  formData,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch,\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  formData: FormData;\n  failedResponseHandler: ResponseHandler<APICallError>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) =>\n  postToApi({\n    url,\n    headers,\n    body: {\n      content: formData,\n      values: Object.fromEntries((formData as any).entries()),\n    },\n    failedResponseHandler,\n    successfulResponseHandler,\n    abortSignal,\n    fetch,\n  });\n\nexport const postToApi = async <T>({\n  url,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch(),\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  body: {\n    content: string | FormData | Uint8Array;\n    values: unknown;\n  };\n  failedResponseHandler: ResponseHandler<Error>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: removeUndefinedEntries(headers),\n      body: body.content,\n      signal: abortSignal,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.ok) {\n      let errorInformation: {\n        value: Error;\n        responseHeaders?: Record<string, string> | undefined;\n      };\n\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: body.values,\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n\n        throw new APICallError({\n          message: 'Failed to process error response',\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: body.values,\n        });\n      }\n\n      throw errorInformation.value;\n    }\n\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: body.values,\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n\n      throw new APICallError({\n        message: 'Failed to process successful response',\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: body.values,\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n\n    // unwrap original error when fetch failed (for easier debugging):\n    if (error instanceof TypeError && error.message === 'fetch failed') {\n      const cause = (error as any).cause;\n\n      if (cause != null) {\n        // Failed to connect to server:\n        throw new APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          requestBodyValues: body.values,\n          isRetryable: true, // retry when network error\n        });\n      }\n    }\n\n    throw error;\n  }\n};\n","export type Resolvable<T> =\n  | T // Raw value\n  | Promise<T> // Promise of value\n  | (() => T) // Function returning value\n  | (() => Promise<T>); // Function returning promise of value\n\n/**\n * Resolves a value that could be a raw value, a Promise, a function returning a value,\n * or a function returning a Promise.\n */\nexport async function resolve<T>(value: Resolvable<T>): Promise<T> {\n  // If it's a function, call it to get the value/promise\n  if (typeof value === 'function') {\n    value = (value as Function)();\n  }\n\n  // Otherwise just resolve whatever we got (value or promise)\n  return Promise.resolve(value as T);\n}\n","import { APICallError, EmptyResponseBodyError } from '@ai-sdk/provider';\nimport { ZodSchema } from 'zod';\nimport {\n  createEventSourceParserStream,\n  EventSourceChunk,\n} from './event-source-parser-stream';\nimport { extractResponseHeaders } from './extract-response-headers';\nimport { parseJSON, ParseResult, safeParseJSON } from './parse-json';\n\nexport type ResponseHandler<RETURN_TYPE> = (options: {\n  url: string;\n  requestBodyValues: unknown;\n  response: Response;\n}) => PromiseLike<{\n  value: RETURN_TYPE;\n  rawValue?: unknown;\n  responseHeaders?: Record<string, string>;\n}>;\n\nexport const createJsonErrorResponseHandler =\n  <T>({\n    errorSchema,\n    errorToMessage,\n    isRetryable,\n  }: {\n    errorSchema: ZodSchema<T>;\n    errorToMessage: (error: T) => string;\n    isRetryable?: (response: Response, error?: T) => boolean;\n  }): ResponseHandler<APICallError> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseBody = await response.text();\n    const responseHeaders = extractResponseHeaders(response);\n\n    // Some providers return an empty response body for some errors:\n    if (responseBody.trim() === '') {\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: response.statusText,\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          isRetryable: isRetryable?.(response),\n        }),\n      };\n    }\n\n    // resilient parsing in case the response is not JSON or does not match the schema:\n    try {\n      const parsedError = parseJSON({\n        text: responseBody,\n        schema: errorSchema,\n      });\n\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: errorToMessage(parsedError),\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          data: parsedError,\n          isRetryable: isRetryable?.(response, parsedError),\n        }),\n      };\n    } catch (parseError) {\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: response.statusText,\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          isRetryable: isRetryable?.(response),\n        }),\n      };\n    }\n  };\n\nexport const createEventSourceResponseHandler =\n  <T>(\n    chunkSchema: ZodSchema<T>,\n  ): ResponseHandler<ReadableStream<ParseResult<T>>> =>\n  async ({ response }: { response: Response }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (response.body == null) {\n      throw new EmptyResponseBodyError({});\n    }\n\n    return {\n      responseHeaders,\n      value: response.body\n        .pipeThrough(new TextDecoderStream())\n        .pipeThrough(createEventSourceParserStream())\n        .pipeThrough(\n          new TransformStream<EventSourceChunk, ParseResult<T>>({\n            transform({ data }, controller) {\n              // ignore the 'DONE' event that e.g. OpenAI sends:\n              if (data === '[DONE]') {\n                return;\n              }\n\n              controller.enqueue(\n                safeParseJSON({\n                  text: data,\n                  schema: chunkSchema,\n                }),\n              );\n            },\n          }),\n        ),\n    };\n  };\n\nexport const createJsonStreamResponseHandler =\n  <T>(\n    chunkSchema: ZodSchema<T>,\n  ): ResponseHandler<ReadableStream<ParseResult<T>>> =>\n  async ({ response }: { response: Response }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (response.body == null) {\n      throw new EmptyResponseBodyError({});\n    }\n\n    let buffer = '';\n\n    return {\n      responseHeaders,\n      value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(\n        new TransformStream<string, ParseResult<T>>({\n          transform(chunkText, controller) {\n            if (chunkText.endsWith('\\n')) {\n              controller.enqueue(\n                safeParseJSON({\n                  text: buffer + chunkText,\n                  schema: chunkSchema,\n                }),\n              );\n              buffer = '';\n            } else {\n              buffer += chunkText;\n            }\n          },\n        }),\n      ),\n    };\n  };\n\nexport const createJsonResponseHandler =\n  <T>(responseSchema: ZodSchema<T>): ResponseHandler<T> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseBody = await response.text();\n\n    const parsedResult = safeParseJSON({\n      text: responseBody,\n      schema: responseSchema,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!parsedResult.success) {\n      throw new APICallError({\n        message: 'Invalid JSON response',\n        cause: parsedResult.error,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        url,\n        requestBodyValues,\n      });\n    }\n\n    return {\n      responseHeaders,\n      value: parsedResult.value,\n      rawValue: parsedResult.rawValue,\n    };\n  };\n\nexport const createBinaryResponseHandler =\n  (): ResponseHandler<Uint8Array> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.body) {\n      throw new APICallError({\n        message: 'Response body is empty',\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody: undefined,\n      });\n    }\n\n    try {\n      const buffer = await response.arrayBuffer();\n      return {\n        responseHeaders,\n        value: new Uint8Array(buffer),\n      };\n    } catch (error) {\n      throw new APICallError({\n        message: 'Failed to read response as array buffer',\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody: undefined,\n        cause: error,\n      });\n    }\n  };\n\nexport const createStatusCodeErrorResponseHandler =\n  (): ResponseHandler<APICallError> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseHeaders = extractResponseHeaders(response);\n    const responseBody = await response.text();\n\n    return {\n      responseHeaders,\n      value: new APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues: requestBodyValues as Record<string, unknown>,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n      }),\n    };\n  };\n","// btoa and atob need to be invoked as a function call, not as a method call.\n// Otherwise CloudFlare will throw a\n// \"TypeError: Illegal invocation: function called with incorrect this reference\"\nconst { btoa, atob } = globalThis;\n\nexport function convertBase64ToUint8Array(base64String: string) {\n  const base64Url = base64String.replace(/-/g, '+').replace(/_/g, '/');\n  const latin1string = atob(base64Url);\n  return Uint8Array.from(latin1string, byte => byte.codePointAt(0)!);\n}\n\nexport function convertUint8ArrayToBase64(array: Uint8Array): string {\n  let latin1string = '';\n\n  // Note: regular for loop to support older JavaScript versions that\n  // do not support for..of on Uint8Array\n  for (let i = 0; i < array.length; i++) {\n    latin1string += String.fromCodePoint(array[i]);\n  }\n\n  return btoa(latin1string);\n}\n","export function withoutTrailingSlash(url: string | undefined) {\n  return url?.replace(/\\/$/, '');\n}\n","/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n  return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nvar ownKeys = function(o) {\n  ownKeys = Object.getOwnPropertyNames || function (o) {\n    var ar = [];\n    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n    return ar;\n  };\n  return ownKeys(o);\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport function __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose, inner;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n      if (async) inner = dispose;\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nexport function __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  var r, s = 0;\n  function next() {\n    while (r = env.stack.pop()) {\n      try {\n        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n        if (r.dispose) {\n          var result = r.dispose.call(r.value);\n          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n        }\n        else s |= 1;\n      }\n      catch (e) {\n        fail(e);\n      }\n    }\n    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\n  if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\n      return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\n          return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\n      });\n  }\n  return path;\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __esDecorate,\n  __runInitializers,\n  __propKey,\n  __setFunctionName,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n  __rewriteRelativeImportExtension,\n};\n","export const isArrayBuffer = (arg) => (typeof ArrayBuffer === \"function\" && arg instanceof ArrayBuffer) ||\n    Object.prototype.toString.call(arg) === \"[object ArrayBuffer]\";\n","import { isArrayBuffer } from \"@smithy/is-array-buffer\";\nimport { Buffer } from \"buffer\";\nexport const fromArrayBuffer = (input, offset = 0, length = input.byteLength - offset) => {\n    if (!isArrayBuffer(input)) {\n        throw new TypeError(`The \"input\" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);\n    }\n    return Buffer.from(input, offset, length);\n};\nexport const fromString = (input, encoding) => {\n    if (typeof input !== \"string\") {\n        throw new TypeError(`The \"input\" argument must be of type string. Received type ${typeof input} (${input})`);\n    }\n    return encoding ? Buffer.from(input, encoding) : Buffer.from(input);\n};\n","import { fromString } from \"@smithy/util-buffer-from\";\nexport const fromUtf8 = (input) => {\n    const buf = fromString(input, \"utf8\");\n    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);\n};\n","import { fromUtf8 } from \"./fromUtf8\";\nexport const toUint8Array = (data) => {\n    if (typeof data === \"string\") {\n        return fromUtf8(data);\n    }\n    if (ArrayBuffer.isView(data)) {\n        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);\n    }\n    return new Uint8Array(data);\n};\n","import { fromArrayBuffer } from \"@smithy/util-buffer-from\";\nexport const toUtf8 = (input) => {\n    if (typeof input === \"string\") {\n        return input;\n    }\n    if (typeof input !== \"object\" || typeof input.byteOffset !== \"number\" || typeof input.byteLength !== \"number\") {\n        throw new Error(\"@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.\");\n    }\n    return fromArrayBuffer(input.buffer, input.byteOffset, input.byteLength).toString(\"utf8\");\n};\n","export * from \"./fromUtf8\";\nexport * from \"./toUint8Array\";\nexport * from \"./toUtf8\";\n","// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { SourceData } from \"@aws-sdk/types\";\nimport { fromUtf8 as fromUtf8Browser } from \"@smithy/util-utf8\";\n\n// Quick polyfill\nconst fromUtf8 =\n  typeof Buffer !== \"undefined\" && Buffer.from\n    ? (input: string) => Buffer.from(input, \"utf8\")\n    : fromUtf8Browser;\n\nexport function convertToBuffer(data: SourceData): Uint8Array {\n  // Already a Uint8, do nothing\n  if (data instanceof Uint8Array) return data;\n\n  if (typeof data === \"string\") {\n    return fromUtf8(data);\n  }\n\n  if (ArrayBuffer.isView(data)) {\n    return new Uint8Array(\n      data.buffer,\n      data.byteOffset,\n      data.byteLength / Uint8Array.BYTES_PER_ELEMENT\n    );\n  }\n\n  return new Uint8Array(data);\n}\n","// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { SourceData } from \"@aws-sdk/types\";\n\nexport function isEmptyData(data: SourceData): boolean {\n  if (typeof data === \"string\") {\n    return data.length === 0;\n  }\n\n  return data.byteLength === 0;\n}\n","// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nexport function numToUint8(num: number) {\n  return new Uint8Array([\n    (num & 0xff000000) >> 24,\n    (num & 0x00ff0000) >> 16,\n    (num & 0x0000ff00) >> 8,\n    num & 0x000000ff,\n  ]);\n}\n","// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\n// IE 11 does not support Array.from, so we do it manually\nexport function uint32ArrayFrom(a_lookUpTable: Array<number>): Uint32Array {\n  if (!Uint32Array.from) {\n    const return_array = new Uint32Array(a_lookUpTable.length)\n    let a_index = 0\n    while (a_index < a_lookUpTable.length) {\n      return_array[a_index] = a_lookUpTable[a_index]\n      a_index += 1\n    }\n    return return_array\n  }\n  return Uint32Array.from(a_lookUpTable)\n}\n","// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nexport { convertToBuffer } from \"./convertToBuffer\";\nexport { isEmptyData } from \"./isEmptyData\";\nexport { numToUint8 } from \"./numToUint8\";\nexport {uint32ArrayFrom} from './uint32ArrayFrom';\n","// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { SourceData, Checksum } from \"@aws-sdk/types\";\nimport { convertToBuffer, isEmptyData, numToUint8 } from \"@aws-crypto/util\";\nimport { Crc32 } from \"./index\";\n\nexport class AwsCrc32 implements Checksum {\n  private crc32 = new Crc32();\n\n  update(toHash: SourceData) {\n    if (isEmptyData(toHash)) return;\n\n    this.crc32.update(convertToBuffer(toHash));\n  }\n\n  async digest(): Promise<Uint8Array> {\n    return numToUint8(this.crc32.digest());\n  }\n\n  reset(): void {\n    this.crc32 = new Crc32();\n  }\n}\n","import {uint32ArrayFrom} from \"@aws-crypto/util\";\n\nexport function crc32(data: Uint8Array): number {\n  return new Crc32().update(data).digest();\n}\n\nexport class Crc32 {\n  private checksum = 0xffffffff;\n\n  update(data: Uint8Array): this {\n    for (const byte of data) {\n      this.checksum =\n        (this.checksum >>> 8) ^ lookupTable[(this.checksum ^ byte) & 0xff];\n    }\n\n    return this;\n  }\n\n  digest(): number {\n    return (this.checksum ^ 0xffffffff) >>> 0;\n  }\n}\n\n// prettier-ignore\nconst a_lookUpTable = [\n  0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,\n  0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,\n  0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,\n  0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,\n  0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,\n  0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,\n  0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,\n  0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,\n  0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,\n  0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,\n  0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940,\n  0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,\n  0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116,\n  0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,\n  0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,\n  0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,\n  0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A,\n  0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,\n  0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818,\n  0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,\n  0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,\n  0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,\n  0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C,\n  0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,\n  0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,\n  0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,\n  0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,\n  0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,\n  0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086,\n  0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,\n  0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4,\n  0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,\n  0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,\n  0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,\n  0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,\n  0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,\n  0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE,\n  0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,\n  0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,\n  0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,\n  0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252,\n  0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,\n  0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60,\n  0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,\n  0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,\n  0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,\n  0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04,\n  0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,\n  0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,\n  0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,\n  0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,\n  0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,\n  0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E,\n  0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,\n  0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,\n  0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,\n  0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,\n  0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,\n  0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0,\n  0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,\n  0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6,\n  0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,\n  0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,\n  0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D,\n];\nconst lookupTable: Uint32Array = uint32ArrayFrom(a_lookUpTable)\nexport { AwsCrc32 } from \"./aws_crc32\";\n","const SHORT_TO_HEX = {};\nconst HEX_TO_SHORT = {};\nfor (let i = 0; i < 256; i++) {\n    let encodedByte = i.toString(16).toLowerCase();\n    if (encodedByte.length === 1) {\n        encodedByte = `0${encodedByte}`;\n    }\n    SHORT_TO_HEX[i] = encodedByte;\n    HEX_TO_SHORT[encodedByte] = i;\n}\nexport function fromHex(encoded) {\n    if (encoded.length % 2 !== 0) {\n        throw new Error(\"Hex encoded strings must have an even number length\");\n    }\n    const out = new Uint8Array(encoded.length / 2);\n    for (let i = 0; i < encoded.length; i += 2) {\n        const encodedByte = encoded.slice(i, i + 2).toLowerCase();\n        if (encodedByte in HEX_TO_SHORT) {\n            out[i / 2] = HEX_TO_SHORT[encodedByte];\n        }\n        else {\n            throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);\n        }\n    }\n    return out;\n}\nexport function toHex(bytes) {\n    let out = \"\";\n    for (let i = 0; i < bytes.byteLength; i++) {\n        out += SHORT_TO_HEX[bytes[i]];\n    }\n    return out;\n}\n","import { toHex } from \"@smithy/util-hex-encoding\";\nexport class Int64 {\n    constructor(bytes) {\n        this.bytes = bytes;\n        if (bytes.byteLength !== 8) {\n            throw new Error(\"Int64 buffers must be exactly 8 bytes\");\n        }\n    }\n    static fromNumber(number) {\n        if (number > 9223372036854776000 || number < -9223372036854776000) {\n            throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);\n        }\n        const bytes = new Uint8Array(8);\n        for (let i = 7, remaining = Math.abs(Math.round(number)); i > -1 && remaining > 0; i--, remaining /= 256) {\n            bytes[i] = remaining;\n        }\n        if (number < 0) {\n            negate(bytes);\n        }\n        return new Int64(bytes);\n    }\n    valueOf() {\n        const bytes = this.bytes.slice(0);\n        const negative = bytes[0] & 0b10000000;\n        if (negative) {\n            negate(bytes);\n        }\n        return parseInt(toHex(bytes), 16) * (negative ? -1 : 1);\n    }\n    toString() {\n        return String(this.valueOf());\n    }\n}\nfunction negate(bytes) {\n    for (let i = 0; i < 8; i++) {\n        bytes[i] ^= 0xff;\n    }\n    for (let i = 7; i > -1; i--) {\n        bytes[i]++;\n        if (bytes[i] !== 0)\n            break;\n    }\n}\n","import { fromHex, toHex } from \"@smithy/util-hex-encoding\";\nimport { Int64 } from \"./Int64\";\nexport class HeaderMarshaller {\n    constructor(toUtf8, fromUtf8) {\n        this.toUtf8 = toUtf8;\n        this.fromUtf8 = fromUtf8;\n    }\n    format(headers) {\n        const chunks = [];\n        for (const headerName of Object.keys(headers)) {\n            const bytes = this.fromUtf8(headerName);\n            chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));\n        }\n        const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));\n        let position = 0;\n        for (const chunk of chunks) {\n            out.set(chunk, position);\n            position += chunk.byteLength;\n        }\n        return out;\n    }\n    formatHeaderValue(header) {\n        switch (header.type) {\n            case \"boolean\":\n                return Uint8Array.from([header.value ? 0 : 1]);\n            case \"byte\":\n                return Uint8Array.from([2, header.value]);\n            case \"short\":\n                const shortView = new DataView(new ArrayBuffer(3));\n                shortView.setUint8(0, 3);\n                shortView.setInt16(1, header.value, false);\n                return new Uint8Array(shortView.buffer);\n            case \"integer\":\n                const intView = new DataView(new ArrayBuffer(5));\n                intView.setUint8(0, 4);\n                intView.setInt32(1, header.value, false);\n                return new Uint8Array(intView.buffer);\n            case \"long\":\n                const longBytes = new Uint8Array(9);\n                longBytes[0] = 5;\n                longBytes.set(header.value.bytes, 1);\n                return longBytes;\n            case \"binary\":\n                const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));\n                binView.setUint8(0, 6);\n                binView.setUint16(1, header.value.byteLength, false);\n                const binBytes = new Uint8Array(binView.buffer);\n                binBytes.set(header.value, 3);\n                return binBytes;\n            case \"string\":\n                const utf8Bytes = this.fromUtf8(header.value);\n                const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));\n                strView.setUint8(0, 7);\n                strView.setUint16(1, utf8Bytes.byteLength, false);\n                const strBytes = new Uint8Array(strView.buffer);\n                strBytes.set(utf8Bytes, 3);\n                return strBytes;\n            case \"timestamp\":\n                const tsBytes = new Uint8Array(9);\n                tsBytes[0] = 8;\n                tsBytes.set(Int64.fromNumber(header.value.valueOf()).bytes, 1);\n                return tsBytes;\n            case \"uuid\":\n                if (!UUID_PATTERN.test(header.value)) {\n                    throw new Error(`Invalid UUID received: ${header.value}`);\n                }\n                const uuidBytes = new Uint8Array(17);\n                uuidBytes[0] = 9;\n                uuidBytes.set(fromHex(header.value.replace(/\\-/g, \"\")), 1);\n                return uuidBytes;\n        }\n    }\n    parse(headers) {\n        const out = {};\n        let position = 0;\n        while (position < headers.byteLength) {\n            const nameLength = headers.getUint8(position++);\n            const name = this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, nameLength));\n            position += nameLength;\n            switch (headers.getUint8(position++)) {\n                case 0:\n                    out[name] = {\n                        type: BOOLEAN_TAG,\n                        value: true,\n                    };\n                    break;\n                case 1:\n                    out[name] = {\n                        type: BOOLEAN_TAG,\n                        value: false,\n                    };\n                    break;\n                case 2:\n                    out[name] = {\n                        type: BYTE_TAG,\n                        value: headers.getInt8(position++),\n                    };\n                    break;\n                case 3:\n                    out[name] = {\n                        type: SHORT_TAG,\n                        value: headers.getInt16(position, false),\n                    };\n                    position += 2;\n                    break;\n                case 4:\n                    out[name] = {\n                        type: INT_TAG,\n                        value: headers.getInt32(position, false),\n                    };\n                    position += 4;\n                    break;\n                case 5:\n                    out[name] = {\n                        type: LONG_TAG,\n                        value: new Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8)),\n                    };\n                    position += 8;\n                    break;\n                case 6:\n                    const binaryLength = headers.getUint16(position, false);\n                    position += 2;\n                    out[name] = {\n                        type: BINARY_TAG,\n                        value: new Uint8Array(headers.buffer, headers.byteOffset + position, binaryLength),\n                    };\n                    position += binaryLength;\n                    break;\n                case 7:\n                    const stringLength = headers.getUint16(position, false);\n                    position += 2;\n                    out[name] = {\n                        type: STRING_TAG,\n                        value: this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, stringLength)),\n                    };\n                    position += stringLength;\n                    break;\n                case 8:\n                    out[name] = {\n                        type: TIMESTAMP_TAG,\n                        value: new Date(new Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8)).valueOf()),\n                    };\n                    position += 8;\n                    break;\n                case 9:\n                    const uuidBytes = new Uint8Array(headers.buffer, headers.byteOffset + position, 16);\n                    position += 16;\n                    out[name] = {\n                        type: UUID_TAG,\n                        value: `${toHex(uuidBytes.subarray(0, 4))}-${toHex(uuidBytes.subarray(4, 6))}-${toHex(uuidBytes.subarray(6, 8))}-${toHex(uuidBytes.subarray(8, 10))}-${toHex(uuidBytes.subarray(10))}`,\n                    };\n                    break;\n                default:\n                    throw new Error(`Unrecognized header type tag`);\n            }\n        }\n        return out;\n    }\n}\nvar HEADER_VALUE_TYPE;\n(function (HEADER_VALUE_TYPE) {\n    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"boolTrue\"] = 0] = \"boolTrue\";\n    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"boolFalse\"] = 1] = \"boolFalse\";\n    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"byte\"] = 2] = \"byte\";\n    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"short\"] = 3] = \"short\";\n    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"integer\"] = 4] = \"integer\";\n    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"long\"] = 5] = \"long\";\n    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"byteArray\"] = 6] = \"byteArray\";\n    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"string\"] = 7] = \"string\";\n    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"timestamp\"] = 8] = \"timestamp\";\n    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE[\"uuid\"] = 9] = \"uuid\";\n})(HEADER_VALUE_TYPE || (HEADER_VALUE_TYPE = {}));\nconst BOOLEAN_TAG = \"boolean\";\nconst BYTE_TAG = \"byte\";\nconst SHORT_TAG = \"short\";\nconst INT_TAG = \"integer\";\nconst LONG_TAG = \"long\";\nconst BINARY_TAG = \"binary\";\nconst STRING_TAG = \"string\";\nconst TIMESTAMP_TAG = \"timestamp\";\nconst UUID_TAG = \"uuid\";\nconst UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;\n","import { Crc32 } from \"@aws-crypto/crc32\";\nconst PRELUDE_MEMBER_LENGTH = 4;\nconst PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;\nconst CHECKSUM_LENGTH = 4;\nconst MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;\nexport function splitMessage({ byteLength, byteOffset, buffer }) {\n    if (byteLength < MINIMUM_MESSAGE_LENGTH) {\n        throw new Error(\"Provided message too short to accommodate event stream message overhead\");\n    }\n    const view = new DataView(buffer, byteOffset, byteLength);\n    const messageLength = view.getUint32(0, false);\n    if (byteLength !== messageLength) {\n        throw new Error(\"Reported message length does not match received message length\");\n    }\n    const headerLength = view.getUint32(PRELUDE_MEMBER_LENGTH, false);\n    const expectedPreludeChecksum = view.getUint32(PRELUDE_LENGTH, false);\n    const expectedMessageChecksum = view.getUint32(byteLength - CHECKSUM_LENGTH, false);\n    const checksummer = new Crc32().update(new Uint8Array(buffer, byteOffset, PRELUDE_LENGTH));\n    if (expectedPreludeChecksum !== checksummer.digest()) {\n        throw new Error(`The prelude checksum specified in the message (${expectedPreludeChecksum}) does not match the calculated CRC32 checksum (${checksummer.digest()})`);\n    }\n    checksummer.update(new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH, byteLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH)));\n    if (expectedMessageChecksum !== checksummer.digest()) {\n        throw new Error(`The message checksum (${checksummer.digest()}) did not match the expected value of ${expectedMessageChecksum}`);\n    }\n    return {\n        headers: new DataView(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH, headerLength),\n        body: new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH + headerLength, messageLength - headerLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH + CHECKSUM_LENGTH)),\n    };\n}\n","import { Crc32 } from \"@aws-crypto/crc32\";\nimport { HeaderMarshaller } from \"./HeaderMarshaller\";\nimport { splitMessage } from \"./splitMessage\";\nexport class EventStreamCodec {\n    constructor(toUtf8, fromUtf8) {\n        this.headerMarshaller = new HeaderMarshaller(toUtf8, fromUtf8);\n        this.messageBuffer = [];\n        this.isEndOfStream = false;\n    }\n    feed(message) {\n        this.messageBuffer.push(this.decode(message));\n    }\n    endOfStream() {\n        this.isEndOfStream = true;\n    }\n    getMessage() {\n        const message = this.messageBuffer.pop();\n        const isEndOfStream = this.isEndOfStream;\n        return {\n            getMessage() {\n                return message;\n            },\n            isEndOfStream() {\n                return isEndOfStream;\n            },\n        };\n    }\n    getAvailableMessages() {\n        const messages = this.messageBuffer;\n        this.messageBuffer = [];\n        const isEndOfStream = this.isEndOfStream;\n        return {\n            getMessages() {\n                return messages;\n            },\n            isEndOfStream() {\n                return isEndOfStream;\n            },\n        };\n    }\n    encode({ headers: rawHeaders, body }) {\n        const headers = this.headerMarshaller.format(rawHeaders);\n        const length = headers.byteLength + body.byteLength + 16;\n        const out = new Uint8Array(length);\n        const view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n        const checksum = new Crc32();\n        view.setUint32(0, length, false);\n        view.setUint32(4, headers.byteLength, false);\n        view.setUint32(8, checksum.update(out.subarray(0, 8)).digest(), false);\n        out.set(headers, 12);\n        out.set(body, headers.byteLength + 12);\n        view.setUint32(length - 4, checksum.update(out.subarray(8, length - 4)).digest(), false);\n        return out;\n    }\n    decode(message) {\n        const { headers, body } = splitMessage(message);\n        return { headers: this.headerMarshaller.parse(headers), body };\n    }\n    formatHeaders(rawHeaders) {\n        return this.headerMarshaller.format(rawHeaders);\n    }\n}\n","export {};\n","export class MessageDecoderStream {\n    constructor(options) {\n        this.options = options;\n    }\n    [Symbol.asyncIterator]() {\n        return this.asyncIterator();\n    }\n    async *asyncIterator() {\n        for await (const bytes of this.options.inputStream) {\n            const decoded = this.options.decoder.decode(bytes);\n            yield decoded;\n        }\n    }\n}\n","export class MessageEncoderStream {\n    constructor(options) {\n        this.options = options;\n    }\n    [Symbol.asyncIterator]() {\n        return this.asyncIterator();\n    }\n    async *asyncIterator() {\n        for await (const msg of this.options.messageStream) {\n            const encoded = this.options.encoder.encode(msg);\n            yield encoded;\n        }\n        if (this.options.includeEndFrame) {\n            yield new Uint8Array(0);\n        }\n    }\n}\n","export class SmithyMessageDecoderStream {\n    constructor(options) {\n        this.options = options;\n    }\n    [Symbol.asyncIterator]() {\n        return this.asyncIterator();\n    }\n    async *asyncIterator() {\n        for await (const message of this.options.messageStream) {\n            const deserialized = await this.options.deserializer(message);\n            if (deserialized === undefined)\n                continue;\n            yield deserialized;\n        }\n    }\n}\n","export class SmithyMessageEncoderStream {\n    constructor(options) {\n        this.options = options;\n    }\n    [Symbol.asyncIterator]() {\n        return this.asyncIterator();\n    }\n    async *asyncIterator() {\n        for await (const chunk of this.options.inputStream) {\n            const payloadBuf = this.options.serializer(chunk);\n            yield payloadBuf;\n        }\n    }\n}\n","export * from \"./EventStreamCodec\";\nexport * from \"./HeaderMarshaller\";\nexport * from \"./Int64\";\nexport * from \"./Message\";\nexport * from \"./MessageDecoderStream\";\nexport * from \"./MessageEncoderStream\";\nexport * from \"./SmithyMessageDecoderStream\";\nexport * from \"./SmithyMessageEncoderStream\";\n","export const isArrayBuffer = (arg) => (typeof ArrayBuffer === \"function\" && arg instanceof ArrayBuffer) ||\n    Object.prototype.toString.call(arg) === \"[object ArrayBuffer]\";\n","import { isArrayBuffer } from \"@smithy/is-array-buffer\";\nimport { Buffer } from \"buffer\";\nexport const fromArrayBuffer = (input, offset = 0, length = input.byteLength - offset) => {\n    if (!isArrayBuffer(input)) {\n        throw new TypeError(`The \"input\" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);\n    }\n    return Buffer.from(input, offset, length);\n};\nexport const fromString = (input, encoding) => {\n    if (typeof input !== \"string\") {\n        throw new TypeError(`The \"input\" argument must be of type string. Received type ${typeof input} (${input})`);\n    }\n    return encoding ? Buffer.from(input, encoding) : Buffer.from(input);\n};\n","import { fromString } from \"@smithy/util-buffer-from\";\nexport const fromUtf8 = (input) => {\n    const buf = fromString(input, \"utf8\");\n    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);\n};\n","import { fromUtf8 } from \"./fromUtf8\";\nexport const toUint8Array = (data) => {\n    if (typeof data === \"string\") {\n        return fromUtf8(data);\n    }\n    if (ArrayBuffer.isView(data)) {\n        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);\n    }\n    return new Uint8Array(data);\n};\n","import { fromArrayBuffer } from \"@smithy/util-buffer-from\";\nexport const toUtf8 = (input) => {\n    if (typeof input === \"string\") {\n        return input;\n    }\n    if (typeof input !== \"object\" || typeof input.byteOffset !== \"number\" || typeof input.byteLength !== \"number\") {\n        throw new Error(\"@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.\");\n    }\n    return fromArrayBuffer(input.buffer, input.byteOffset, input.byteLength).toString(\"utf8\");\n};\n","export * from \"./fromUtf8\";\nexport * from \"./toUint8Array\";\nexport * from \"./toUtf8\";\n","/**\n * @license MIT <https://opensource.org/licenses/MIT>\n * @copyright Michael Hart 2024\n */\nconst encoder = new TextEncoder();\nconst HOST_SERVICES = {\n  appstream2: 'appstream',\n  cloudhsmv2: 'cloudhsm',\n  email: 'ses',\n  marketplace: 'aws-marketplace',\n  mobile: 'AWSMobileHubService',\n  pinpoint: 'mobiletargeting',\n  queue: 'sqs',\n  'git-codecommit': 'codecommit',\n  'mturk-requester-sandbox': 'mturk-requester',\n  'personalize-runtime': 'personalize',\n};\nconst UNSIGNABLE_HEADERS = new Set([\n  'authorization',\n  'content-type',\n  'content-length',\n  'user-agent',\n  'presigned-expires',\n  'expect',\n  'x-amzn-trace-id',\n  'range',\n  'connection',\n]);\nclass AwsClient {\n  constructor({ accessKeyId, secretAccessKey, sessionToken, service, region, cache, retries, initRetryMs }) {\n    if (accessKeyId == null) throw new TypeError('accessKeyId is a required option')\n    if (secretAccessKey == null) throw new TypeError('secretAccessKey is a required option')\n    this.accessKeyId = accessKeyId;\n    this.secretAccessKey = secretAccessKey;\n    this.sessionToken = sessionToken;\n    this.service = service;\n    this.region = region;\n    this.cache = cache || new Map();\n    this.retries = retries != null ? retries : 10;\n    this.initRetryMs = initRetryMs || 50;\n  }\n  async sign(input, init) {\n    if (input instanceof Request) {\n      const { method, url, headers, body } = input;\n      init = Object.assign({ method, url, headers }, init);\n      if (init.body == null && headers.has('Content-Type')) {\n        init.body = body != null && headers.has('X-Amz-Content-Sha256') ? body : await input.clone().arrayBuffer();\n      }\n      input = url;\n    }\n    const signer = new AwsV4Signer(Object.assign({ url: input.toString() }, init, this, init && init.aws));\n    const signed = Object.assign({}, init, await signer.sign());\n    delete signed.aws;\n    try {\n      return new Request(signed.url.toString(), signed)\n    } catch (e) {\n      if (e instanceof TypeError) {\n        return new Request(signed.url.toString(), Object.assign({ duplex: 'half' }, signed))\n      }\n      throw e\n    }\n  }\n  async fetch(input, init) {\n    for (let i = 0; i <= this.retries; i++) {\n      const fetched = fetch(await this.sign(input, init));\n      if (i === this.retries) {\n        return fetched\n      }\n      const res = await fetched;\n      if (res.status < 500 && res.status !== 429) {\n        return res\n      }\n      await new Promise(resolve => setTimeout(resolve, Math.random() * this.initRetryMs * Math.pow(2, i)));\n    }\n    throw new Error('An unknown error occurred, ensure retries is not negative')\n  }\n}\nclass AwsV4Signer {\n  constructor({ method, url, headers, body, accessKeyId, secretAccessKey, sessionToken, service, region, cache, datetime, signQuery, appendSessionToken, allHeaders, singleEncode }) {\n    if (url == null) throw new TypeError('url is a required option')\n    if (accessKeyId == null) throw new TypeError('accessKeyId is a required option')\n    if (secretAccessKey == null) throw new TypeError('secretAccessKey is a required option')\n    this.method = method || (body ? 'POST' : 'GET');\n    this.url = new URL(url);\n    this.headers = new Headers(headers || {});\n    this.body = body;\n    this.accessKeyId = accessKeyId;\n    this.secretAccessKey = secretAccessKey;\n    this.sessionToken = sessionToken;\n    let guessedService, guessedRegion;\n    if (!service || !region) {\n[guessedService, guessedRegion] = guessServiceRegion(this.url, this.headers);\n    }\n    this.service = service || guessedService || '';\n    this.region = region || guessedRegion || 'us-east-1';\n    this.cache = cache || new Map();\n    this.datetime = datetime || new Date().toISOString().replace(/[:-]|\\.\\d{3}/g, '');\n    this.signQuery = signQuery;\n    this.appendSessionToken = appendSessionToken || this.service === 'iotdevicegateway';\n    this.headers.delete('Host');\n    if (this.service === 's3' && !this.signQuery && !this.headers.has('X-Amz-Content-Sha256')) {\n      this.headers.set('X-Amz-Content-Sha256', 'UNSIGNED-PAYLOAD');\n    }\n    const params = this.signQuery ? this.url.searchParams : this.headers;\n    params.set('X-Amz-Date', this.datetime);\n    if (this.sessionToken && !this.appendSessionToken) {\n      params.set('X-Amz-Security-Token', this.sessionToken);\n    }\n    this.signableHeaders = ['host', ...this.headers.keys()]\n      .filter(header => allHeaders || !UNSIGNABLE_HEADERS.has(header))\n      .sort();\n    this.signedHeaders = this.signableHeaders.join(';');\n    this.canonicalHeaders = this.signableHeaders\n      .map(header => header + ':' + (header === 'host' ? this.url.host : (this.headers.get(header) || '').replace(/\\s+/g, ' ')))\n      .join('\\n');\n    this.credentialString = [this.datetime.slice(0, 8), this.region, this.service, 'aws4_request'].join('/');\n    if (this.signQuery) {\n      if (this.service === 's3' && !params.has('X-Amz-Expires')) {\n        params.set('X-Amz-Expires', '86400');\n      }\n      params.set('X-Amz-Algorithm', 'AWS4-HMAC-SHA256');\n      params.set('X-Amz-Credential', this.accessKeyId + '/' + this.credentialString);\n      params.set('X-Amz-SignedHeaders', this.signedHeaders);\n    }\n    if (this.service === 's3') {\n      try {\n        this.encodedPath = decodeURIComponent(this.url.pathname.replace(/\\+/g, ' '));\n      } catch (e) {\n        this.encodedPath = this.url.pathname;\n      }\n    } else {\n      this.encodedPath = this.url.pathname.replace(/\\/+/g, '/');\n    }\n    if (!singleEncode) {\n      this.encodedPath = encodeURIComponent(this.encodedPath).replace(/%2F/g, '/');\n    }\n    this.encodedPath = encodeRfc3986(this.encodedPath);\n    const seenKeys = new Set();\n    this.encodedSearch = [...this.url.searchParams]\n      .filter(([k]) => {\n        if (!k) return false\n        if (this.service === 's3') {\n          if (seenKeys.has(k)) return false\n          seenKeys.add(k);\n        }\n        return true\n      })\n      .map(pair => pair.map(p => encodeRfc3986(encodeURIComponent(p))))\n      .sort(([k1, v1], [k2, v2]) => k1 < k2 ? -1 : k1 > k2 ? 1 : v1 < v2 ? -1 : v1 > v2 ? 1 : 0)\n      .map(pair => pair.join('='))\n      .join('&');\n  }\n  async sign() {\n    if (this.signQuery) {\n      this.url.searchParams.set('X-Amz-Signature', await this.signature());\n      if (this.sessionToken && this.appendSessionToken) {\n        this.url.searchParams.set('X-Amz-Security-Token', this.sessionToken);\n      }\n    } else {\n      this.headers.set('Authorization', await this.authHeader());\n    }\n    return {\n      method: this.method,\n      url: this.url,\n      headers: this.headers,\n      body: this.body,\n    }\n  }\n  async authHeader() {\n    return [\n      'AWS4-HMAC-SHA256 Credential=' + this.accessKeyId + '/' + this.credentialString,\n      'SignedHeaders=' + this.signedHeaders,\n      'Signature=' + (await this.signature()),\n    ].join(', ')\n  }\n  async signature() {\n    const date = this.datetime.slice(0, 8);\n    const cacheKey = [this.secretAccessKey, date, this.region, this.service].join();\n    let kCredentials = this.cache.get(cacheKey);\n    if (!kCredentials) {\n      const kDate = await hmac('AWS4' + this.secretAccessKey, date);\n      const kRegion = await hmac(kDate, this.region);\n      const kService = await hmac(kRegion, this.service);\n      kCredentials = await hmac(kService, 'aws4_request');\n      this.cache.set(cacheKey, kCredentials);\n    }\n    return buf2hex(await hmac(kCredentials, await this.stringToSign()))\n  }\n  async stringToSign() {\n    return [\n      'AWS4-HMAC-SHA256',\n      this.datetime,\n      this.credentialString,\n      buf2hex(await hash(await this.canonicalString())),\n    ].join('\\n')\n  }\n  async canonicalString() {\n    return [\n      this.method.toUpperCase(),\n      this.encodedPath,\n      this.encodedSearch,\n      this.canonicalHeaders + '\\n',\n      this.signedHeaders,\n      await this.hexBodyHash(),\n    ].join('\\n')\n  }\n  async hexBodyHash() {\n    let hashHeader = this.headers.get('X-Amz-Content-Sha256') || (this.service === 's3' && this.signQuery ? 'UNSIGNED-PAYLOAD' : null);\n    if (hashHeader == null) {\n      if (this.body && typeof this.body !== 'string' && !('byteLength' in this.body)) {\n        throw new Error('body must be a string, ArrayBuffer or ArrayBufferView, unless you include the X-Amz-Content-Sha256 header')\n      }\n      hashHeader = buf2hex(await hash(this.body || ''));\n    }\n    return hashHeader\n  }\n}\nasync function hmac(key, string) {\n  const cryptoKey = await crypto.subtle.importKey(\n    'raw',\n    typeof key === 'string' ? encoder.encode(key) : key,\n    { name: 'HMAC', hash: { name: 'SHA-256' } },\n    false,\n    ['sign'],\n  );\n  return crypto.subtle.sign('HMAC', cryptoKey, encoder.encode(string))\n}\nasync function hash(content) {\n  return crypto.subtle.digest('SHA-256', typeof content === 'string' ? encoder.encode(content) : content)\n}\nconst HEX_CHARS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\nfunction buf2hex(arrayBuffer) {\n  const buffer = new Uint8Array(arrayBuffer);\n  let out = '';\n  for (let idx = 0; idx < buffer.length; idx++) {\n    const n = buffer[idx];\n    out += HEX_CHARS[(n >>> 4) & 0xF];\n    out += HEX_CHARS[n & 0xF];\n  }\n  return out\n}\nfunction encodeRfc3986(urlEncodedStr) {\n  return urlEncodedStr.replace(/[!'()*]/g, c => '%' + c.charCodeAt(0).toString(16).toUpperCase())\n}\nfunction guessServiceRegion(url, headers) {\n  const { hostname, pathname } = url;\n  if (hostname.endsWith('.on.aws')) {\n    const match = hostname.match(/^[^.]{1,63}\\.lambda-url\\.([^.]{1,63})\\.on\\.aws$/);\n    return match != null ? ['lambda', match[1] || ''] : ['', '']\n  }\n  if (hostname.endsWith('.r2.cloudflarestorage.com')) {\n    return ['s3', 'auto']\n  }\n  if (hostname.endsWith('.backblazeb2.com')) {\n    const match = hostname.match(/^(?:[^.]{1,63}\\.)?s3\\.([^.]{1,63})\\.backblazeb2\\.com$/);\n    return match != null ? ['s3', match[1] || ''] : ['', '']\n  }\n  const match = hostname.replace('dualstack.', '').match(/([^.]{1,63})\\.(?:([^.]{0,63})\\.)?amazonaws\\.com(?:\\.cn)?$/);\n  let service = (match && match[1]) || '';\n  let region = match && match[2];\n  if (region === 'us-gov') {\n    region = 'us-gov-west-1';\n  } else if (region === 's3' || region === 's3-accelerate') {\n    region = 'us-east-1';\n    service = 's3';\n  } else if (service === 'iot') {\n    if (hostname.startsWith('iot.')) {\n      service = 'execute-api';\n    } else if (hostname.startsWith('data.jobs.iot.')) {\n      service = 'iot-jobs-data';\n    } else {\n      service = pathname === '/mqtt' ? 'iotdevicegateway' : 'iotdata';\n    }\n  } else if (service === 'autoscaling') {\n    const targetPrefix = (headers.get('X-Amz-Target') || '').split('.')[0];\n    if (targetPrefix === 'AnyScaleFrontendService') {\n      service = 'application-autoscaling';\n    } else if (targetPrefix === 'AnyScaleScalingPlannerFrontendService') {\n      service = 'autoscaling-plans';\n    }\n  } else if (region == null && service.startsWith('s3-')) {\n    region = service.slice(3).replace(/^fips-|^external-1/, '');\n    service = 's3';\n  } else if (service.endsWith('-fips')) {\n    service = service.slice(0, -5);\n  } else if (region && /-\\d$/.test(service) && !/-\\d$/.test(region)) {\n[service, region] = [region, service];\n  }\n  return [HOST_SERVICES[service] || service, region || '']\n}\n\nexport { AwsClient, AwsV4Signer };\n","import {\n  EmbeddingModelV1,\n  ImageModelV1,\n  LanguageModelV1,\n  ProviderV1,\n} from '@ai-sdk/provider';\nimport {\n  FetchFunction,\n  generateId,\n  loadOptionalSetting,\n  loadSetting,\n  withoutTrailingSlash,\n} from '@ai-sdk/provider-utils';\nimport { BedrockChatLanguageModel } from './bedrock-chat-language-model';\nimport {\n  BedrockChatModelId,\n  BedrockChatSettings,\n} from './bedrock-chat-settings';\nimport { BedrockEmbeddingModel } from './bedrock-embedding-model';\nimport {\n  BedrockEmbeddingModelId,\n  BedrockEmbeddingSettings,\n} from './bedrock-embedding-settings';\nimport { BedrockImageModel } from './bedrock-image-model';\nimport {\n  BedrockImageModelId,\n  BedrockImageSettings,\n} from './bedrock-image-settings';\nimport {\n  BedrockCredentials,\n  createSigV4FetchFunction,\n} from './bedrock-sigv4-fetch';\n\nexport interface AmazonBedrockProviderSettings {\n  /**\nThe AWS region to use for the Bedrock provider. Defaults to the value of the\n`AWS_REGION` environment variable.\n   */\n  region?: string;\n\n  /**\nThe AWS access key ID to use for the Bedrock provider. Defaults to the value of the\n`AWS_ACCESS_KEY_ID` environment variable.\n   */\n  accessKeyId?: string;\n\n  /**\nThe AWS secret access key to use for the Bedrock provider. Defaults to the value of the\n`AWS_SECRET_ACCESS_KEY` environment variable.\n   */\n  secretAccessKey?: string;\n\n  /**\nThe AWS session token to use for the Bedrock provider. Defaults to the value of the\n`AWS_SESSION_TOKEN` environment variable.\n   */\n  sessionToken?: string;\n\n  /**\nBase URL for the Bedrock API calls.\n   */\n  baseURL?: string;\n\n  /**\nCustom headers to include in the requests.\n   */\n  headers?: Record<string, string>;\n\n  /**\nCustom fetch implementation. You can use it as a middleware to intercept requests,\nor to provide a custom fetch implementation for e.g. testing.\n*/\n  fetch?: FetchFunction;\n\n  /**\nThe AWS credential provider to use for the Bedrock provider to get dynamic\ncredentials similar to the AWS SDK. Setting a provider here will cause its\ncredential values to be used instead of the `accessKeyId`, `secretAccessKey`,\nand `sessionToken` settings.\n   */\n  credentialProvider?: () => PromiseLike<Omit<BedrockCredentials, 'region'>>;\n\n  // for testing\n  generateId?: () => string;\n}\n\nexport interface AmazonBedrockProvider extends ProviderV1 {\n  (\n    modelId: BedrockChatModelId,\n    settings?: BedrockChatSettings,\n  ): LanguageModelV1;\n\n  languageModel(\n    modelId: BedrockChatModelId,\n    settings?: BedrockChatSettings,\n  ): LanguageModelV1;\n\n  embedding(\n    modelId: BedrockEmbeddingModelId,\n    settings?: BedrockEmbeddingSettings,\n  ): EmbeddingModelV1<string>;\n\n  image(\n    modelId: BedrockImageModelId,\n    settings?: BedrockImageSettings,\n  ): ImageModelV1;\n\n  imageModel(\n    modelId: BedrockImageModelId,\n    settings?: BedrockImageSettings,\n  ): ImageModelV1;\n}\n\n/**\nCreate an Amazon Bedrock provider instance.\n */\nexport function createAmazonBedrock(\n  options: AmazonBedrockProviderSettings = {},\n): AmazonBedrockProvider {\n  const sigv4Fetch = createSigV4FetchFunction(async () => {\n    const region = loadSetting({\n      settingValue: options.region,\n      settingName: 'region',\n      environmentVariableName: 'AWS_REGION',\n      description: 'AWS region',\n    });\n    // If a credential provider is provided, use it to get the credentials.\n    if (options.credentialProvider) {\n      return {\n        ...(await options.credentialProvider()),\n        region,\n      };\n    }\n    return {\n      region,\n      accessKeyId: loadSetting({\n        settingValue: options.accessKeyId,\n        settingName: 'accessKeyId',\n        environmentVariableName: 'AWS_ACCESS_KEY_ID',\n        description: 'AWS access key ID',\n      }),\n      secretAccessKey: loadSetting({\n        settingValue: options.secretAccessKey,\n        settingName: 'secretAccessKey',\n        environmentVariableName: 'AWS_SECRET_ACCESS_KEY',\n        description: 'AWS secret access key',\n      }),\n      sessionToken: loadOptionalSetting({\n        settingValue: options.sessionToken,\n        environmentVariableName: 'AWS_SESSION_TOKEN',\n      }),\n    };\n  }, options.fetch);\n\n  const getBaseUrl = (): string =>\n    withoutTrailingSlash(\n      options.baseURL ??\n        `https://bedrock-runtime.${loadSetting({\n          settingValue: options.region,\n          settingName: 'region',\n          environmentVariableName: 'AWS_REGION',\n          description: 'AWS region',\n        })}.amazonaws.com`,\n    ) ?? `https://bedrock-runtime.us-east-1.amazonaws.com`;\n\n  const createChatModel = (\n    modelId: BedrockChatModelId,\n    settings: BedrockChatSettings = {},\n  ) =>\n    new BedrockChatLanguageModel(modelId, settings, {\n      baseUrl: getBaseUrl,\n      headers: options.headers ?? {},\n      fetch: sigv4Fetch,\n      generateId,\n    });\n\n  const provider = function (\n    modelId: BedrockChatModelId,\n    settings?: BedrockChatSettings,\n  ) {\n    if (new.target) {\n      throw new Error(\n        'The Amazon Bedrock model function cannot be called with the new keyword.',\n      );\n    }\n\n    return createChatModel(modelId, settings);\n  };\n\n  const createEmbeddingModel = (\n    modelId: BedrockEmbeddingModelId,\n    settings: BedrockEmbeddingSettings = {},\n  ) =>\n    new BedrockEmbeddingModel(modelId, settings, {\n      baseUrl: getBaseUrl,\n      headers: options.headers ?? {},\n      fetch: sigv4Fetch,\n    });\n\n  const createImageModel = (\n    modelId: BedrockImageModelId,\n    settings: BedrockImageSettings = {},\n  ) =>\n    new BedrockImageModel(modelId, settings, {\n      baseUrl: getBaseUrl,\n      headers: options.headers ?? {},\n      fetch: sigv4Fetch,\n    });\n\n  provider.languageModel = createChatModel;\n  provider.embedding = createEmbeddingModel;\n  provider.textEmbedding = createEmbeddingModel;\n  provider.textEmbeddingModel = createEmbeddingModel;\n  provider.image = createImageModel;\n  provider.imageModel = createImageModel;\n\n  return provider;\n}\n\n/**\nDefault Bedrock provider instance.\n */\nexport const bedrock = createAmazonBedrock();\n","import {\n  InvalidArgumentError,\n  JSONObject,\n  LanguageModelV1,\n  LanguageModelV1CallWarning,\n  LanguageModelV1FinishReason,\n  LanguageModelV1ProviderMetadata,\n  LanguageModelV1StreamPart,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport {\n  FetchFunction,\n  ParseResult,\n  Resolvable,\n  combineHeaders,\n  createJsonErrorResponseHandler,\n  createJsonResponseHandler,\n  postJsonToApi,\n  resolve,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\nimport {\n  BEDROCK_STOP_REASONS,\n  BedrockConverseInput,\n  BedrockStopReason,\n} from './bedrock-api-types';\nimport {\n  BedrockChatModelId,\n  BedrockChatSettings,\n} from './bedrock-chat-settings';\nimport { BedrockErrorSchema } from './bedrock-error';\nimport { createBedrockEventStreamResponseHandler } from './bedrock-event-stream-response-handler';\nimport { prepareTools } from './bedrock-prepare-tools';\nimport { convertToBedrockChatMessages } from './convert-to-bedrock-chat-messages';\nimport { mapBedrockFinishReason } from './map-bedrock-finish-reason';\n\ntype BedrockChatConfig = {\n  baseUrl: () => string;\n  headers: Resolvable<Record<string, string | undefined>>;\n  fetch?: FetchFunction;\n  generateId: () => string;\n};\n\nexport class BedrockChatLanguageModel implements LanguageModelV1 {\n  readonly specificationVersion = 'v1';\n  readonly provider = 'amazon-bedrock';\n  readonly defaultObjectGenerationMode = 'tool';\n  readonly supportsImageUrls = false;\n\n  constructor(\n    readonly modelId: BedrockChatModelId,\n    private readonly settings: BedrockChatSettings,\n    private readonly config: BedrockChatConfig,\n  ) {}\n\n  private getArgs({\n    mode,\n    prompt,\n    maxTokens,\n    temperature,\n    topP,\n    topK,\n    frequencyPenalty,\n    presencePenalty,\n    stopSequences,\n    responseFormat,\n    seed,\n    providerMetadata,\n  }: Parameters<LanguageModelV1['doGenerate']>[0]): {\n    command: BedrockConverseInput;\n    warnings: LanguageModelV1CallWarning[];\n  } {\n    const type = mode.type;\n\n    const warnings: LanguageModelV1CallWarning[] = [];\n\n    if (frequencyPenalty != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'frequencyPenalty',\n      });\n    }\n\n    if (presencePenalty != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'presencePenalty',\n      });\n    }\n\n    if (seed != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'seed',\n      });\n    }\n\n    if (topK != null) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'topK',\n      });\n    }\n\n    if (responseFormat != null && responseFormat.type !== 'text') {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'responseFormat',\n        details: 'JSON response format is not supported.',\n      });\n    }\n\n    const { system, messages } = convertToBedrockChatMessages(prompt);\n\n    // Parse thinking options from provider metadata\n    const reasoningConfigOptions =\n      BedrockReasoningConfigOptionsSchema.safeParse(\n        providerMetadata?.bedrock?.reasoningConfig,\n      );\n\n    if (!reasoningConfigOptions.success) {\n      throw new InvalidArgumentError({\n        argument: 'providerOptions.bedrock.reasoningConfig',\n        message: 'invalid reasoning configuration options',\n        cause: reasoningConfigOptions.error,\n      });\n    }\n\n    const isThinking = reasoningConfigOptions.data?.type === 'enabled';\n    const thinkingBudget =\n      reasoningConfigOptions.data?.budgetTokens ??\n      reasoningConfigOptions.data?.budget_tokens;\n\n    const inferenceConfig = {\n      ...(maxTokens != null && { maxTokens }),\n      ...(temperature != null && { temperature }),\n      ...(topP != null && { topP }),\n      ...(stopSequences != null && { stopSequences }),\n    };\n\n    // Adjust maxTokens if thinking is enabled\n    if (isThinking && thinkingBudget != null) {\n      if (inferenceConfig.maxTokens != null) {\n        inferenceConfig.maxTokens += thinkingBudget;\n      } else {\n        inferenceConfig.maxTokens = thinkingBudget + 4096; // Default + thinking budget maxTokens = 4096, TODO update default in v5\n      }\n      // Add them to additional model request fields\n      // Add reasoning config to additionalModelRequestFields\n      this.settings.additionalModelRequestFields = {\n        ...this.settings.additionalModelRequestFields,\n        reasoningConfig: {\n          type: reasoningConfigOptions.data?.type,\n          budget_tokens: thinkingBudget,\n        },\n      };\n    }\n\n    // Remove temperature if thinking is enabled\n    if (isThinking && inferenceConfig.temperature != null) {\n      delete inferenceConfig.temperature;\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'temperature',\n        details: 'temperature is not supported when thinking is enabled',\n      });\n    }\n\n    // Remove topP if thinking is enabled\n    if (isThinking && inferenceConfig.topP != null) {\n      delete inferenceConfig.topP;\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'topP',\n        details: 'topP is not supported when thinking is enabled',\n      });\n    }\n\n    const baseArgs: BedrockConverseInput = {\n      system,\n      additionalModelRequestFields: this.settings.additionalModelRequestFields,\n      ...(Object.keys(inferenceConfig).length > 0 && {\n        inferenceConfig,\n      }),\n      messages,\n      ...providerMetadata?.bedrock,\n    };\n\n    switch (type) {\n      case 'regular': {\n        const { toolConfig, toolWarnings } = prepareTools(mode);\n        return {\n          command: {\n            ...baseArgs,\n            ...(toolConfig.tools?.length ? { toolConfig } : {}),\n          },\n          warnings: [...warnings, ...toolWarnings],\n        };\n      }\n\n      case 'object-json': {\n        throw new UnsupportedFunctionalityError({\n          functionality: 'json-mode object generation',\n        });\n      }\n\n      case 'object-tool': {\n        return {\n          command: {\n            ...baseArgs,\n            toolConfig: {\n              tools: [\n                {\n                  toolSpec: {\n                    name: mode.tool.name,\n                    description: mode.tool.description,\n                    inputSchema: {\n                      json: mode.tool.parameters as JSONObject,\n                    },\n                  },\n                },\n              ],\n              toolChoice: { tool: { name: mode.tool.name } },\n            },\n          },\n          warnings,\n        };\n      }\n\n      default: {\n        const _exhaustiveCheck: never = type;\n        throw new Error(`Unsupported type: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  async doGenerate(\n    options: Parameters<LanguageModelV1['doGenerate']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV1['doGenerate']>>> {\n    const { command: args, warnings } = this.getArgs(options);\n\n    const url = `${this.getUrl(this.modelId)}/converse`;\n    const { value: response, responseHeaders } = await postJsonToApi({\n      url,\n      headers: combineHeaders(\n        await resolve(this.config.headers),\n        options.headers,\n      ),\n      body: args,\n      failedResponseHandler: createJsonErrorResponseHandler({\n        errorSchema: BedrockErrorSchema,\n        errorToMessage: error => `${error.message ?? 'Unknown error'}`,\n      }),\n      successfulResponseHandler: createJsonResponseHandler(\n        BedrockResponseSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const { messages: rawPrompt, ...rawSettings } = args;\n\n    const providerMetadata =\n      response.trace || response.usage\n        ? {\n            bedrock: {\n              ...(response.trace && typeof response.trace === 'object'\n                ? { trace: response.trace as JSONObject }\n                : {}),\n              ...(response.usage && {\n                usage: {\n                  cacheReadInputTokens:\n                    response.usage?.cacheReadInputTokens ?? Number.NaN,\n                  cacheWriteInputTokens:\n                    response.usage?.cacheWriteInputTokens ?? Number.NaN,\n                },\n              }),\n            },\n          }\n        : undefined;\n\n    const reasoning = response.output.message.content\n      .filter(content => content.reasoningContent)\n      .map(content => {\n        if (\n          content.reasoningContent &&\n          'reasoningText' in content.reasoningContent\n        ) {\n          return {\n            type: 'text' as const,\n            text: content.reasoningContent.reasoningText.text,\n            ...(content.reasoningContent.reasoningText.signature && {\n              signature: content.reasoningContent.reasoningText.signature,\n            }),\n          };\n        } else if (\n          content.reasoningContent &&\n          'redactedReasoning' in content.reasoningContent\n        ) {\n          return {\n            type: 'redacted' as const,\n            data: content.reasoningContent.redactedReasoning.data ?? '',\n          };\n        } else {\n          // Return undefined for unexpected structures\n          return undefined;\n        }\n      })\n      // Filter out any undefined values\n      .filter((item): item is NonNullable<typeof item> => item !== undefined);\n\n    return {\n      text:\n        response.output?.message?.content\n          ?.map(part => part.text ?? '')\n          .join('') ?? undefined,\n      toolCalls: response.output?.message?.content\n        ?.filter(part => !!part.toolUse)\n        ?.map(part => ({\n          toolCallType: 'function',\n          toolCallId: part.toolUse?.toolUseId ?? this.config.generateId(),\n          toolName: part.toolUse?.name ?? `tool-${this.config.generateId()}`,\n          args: JSON.stringify(part.toolUse?.input ?? ''),\n        })),\n      finishReason: mapBedrockFinishReason(\n        response.stopReason as BedrockStopReason,\n      ),\n      usage: {\n        promptTokens: response.usage?.inputTokens ?? Number.NaN,\n        completionTokens: response.usage?.outputTokens ?? Number.NaN,\n      },\n      rawCall: { rawPrompt, rawSettings },\n      rawResponse: { headers: responseHeaders },\n      warnings,\n      reasoning: reasoning.length > 0 ? reasoning : undefined,\n      ...(providerMetadata && { providerMetadata }),\n    };\n  }\n\n  async doStream(\n    options: Parameters<LanguageModelV1['doStream']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV1['doStream']>>> {\n    const { command: args, warnings } = this.getArgs(options);\n    const url = `${this.getUrl(this.modelId)}/converse-stream`;\n\n    const { value: response, responseHeaders } = await postJsonToApi({\n      url,\n      headers: combineHeaders(\n        await resolve(this.config.headers),\n        options.headers,\n      ),\n      body: args,\n      failedResponseHandler: createJsonErrorResponseHandler({\n        errorSchema: BedrockErrorSchema,\n        errorToMessage: error => `${error.type}: ${error.message}`,\n      }),\n      successfulResponseHandler:\n        createBedrockEventStreamResponseHandler(BedrockStreamSchema),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const { messages: rawPrompt, ...rawSettings } = args;\n\n    let finishReason: LanguageModelV1FinishReason = 'unknown';\n    let usage = {\n      promptTokens: Number.NaN,\n      completionTokens: Number.NaN,\n    };\n    let providerMetadata: LanguageModelV1ProviderMetadata | undefined =\n      undefined;\n\n    const toolCallContentBlocks: Record<\n      number,\n      {\n        toolCallId: string;\n        toolName: string;\n        jsonText: string;\n      }\n    > = {};\n\n    return {\n      stream: response.pipeThrough(\n        new TransformStream<\n          ParseResult<z.infer<typeof BedrockStreamSchema>>,\n          LanguageModelV1StreamPart\n        >({\n          transform(chunk, controller) {\n            function enqueueError(bedrockError: Record<string, any>) {\n              finishReason = 'error';\n              controller.enqueue({ type: 'error', error: bedrockError });\n            }\n\n            // handle failed chunk parsing / validation:\n            if (!chunk.success) {\n              enqueueError(chunk.error);\n              return;\n            }\n\n            const value = chunk.value;\n\n            // handle errors:\n            if (value.internalServerException) {\n              enqueueError(value.internalServerException);\n              return;\n            }\n            if (value.modelStreamErrorException) {\n              enqueueError(value.modelStreamErrorException);\n              return;\n            }\n            if (value.throttlingException) {\n              enqueueError(value.throttlingException);\n              return;\n            }\n            if (value.validationException) {\n              enqueueError(value.validationException);\n              return;\n            }\n\n            if (value.messageStop) {\n              finishReason = mapBedrockFinishReason(\n                value.messageStop.stopReason as BedrockStopReason,\n              );\n            }\n\n            if (value.metadata) {\n              usage = {\n                promptTokens: value.metadata.usage?.inputTokens ?? Number.NaN,\n                completionTokens:\n                  value.metadata.usage?.outputTokens ?? Number.NaN,\n              };\n\n              const cacheUsage =\n                value.metadata.usage?.cacheReadInputTokens != null ||\n                value.metadata.usage?.cacheWriteInputTokens != null\n                  ? {\n                      usage: {\n                        cacheReadInputTokens:\n                          value.metadata.usage?.cacheReadInputTokens ??\n                          Number.NaN,\n                        cacheWriteInputTokens:\n                          value.metadata.usage?.cacheWriteInputTokens ??\n                          Number.NaN,\n                      },\n                    }\n                  : undefined;\n\n              const trace = value.metadata.trace\n                ? {\n                    trace: value.metadata.trace as JSONObject,\n                  }\n                : undefined;\n\n              if (cacheUsage || trace) {\n                providerMetadata = {\n                  bedrock: {\n                    ...cacheUsage,\n                    ...trace,\n                  },\n                };\n              }\n            }\n\n            if (\n              value.contentBlockDelta?.delta &&\n              'text' in value.contentBlockDelta.delta &&\n              value.contentBlockDelta.delta.text\n            ) {\n              controller.enqueue({\n                type: 'text-delta',\n                textDelta: value.contentBlockDelta.delta.text,\n              });\n            }\n\n            if (\n              value.contentBlockDelta?.delta &&\n              'reasoningContent' in value.contentBlockDelta.delta &&\n              value.contentBlockDelta.delta.reasoningContent\n            ) {\n              const reasoningContent =\n                value.contentBlockDelta.delta.reasoningContent;\n              if ('text' in reasoningContent && reasoningContent.text) {\n                controller.enqueue({\n                  type: 'reasoning',\n                  textDelta: reasoningContent.text,\n                });\n              } else if (\n                'signature' in reasoningContent &&\n                reasoningContent.signature\n              ) {\n                controller.enqueue({\n                  type: 'reasoning-signature',\n                  signature: reasoningContent.signature,\n                });\n              } else if ('data' in reasoningContent && reasoningContent.data) {\n                controller.enqueue({\n                  type: 'redacted-reasoning',\n                  data: reasoningContent.data,\n                });\n              }\n            }\n\n            const contentBlockStart = value.contentBlockStart;\n            if (contentBlockStart?.start?.toolUse != null) {\n              const toolUse = contentBlockStart.start.toolUse;\n              toolCallContentBlocks[contentBlockStart.contentBlockIndex!] = {\n                toolCallId: toolUse.toolUseId!,\n                toolName: toolUse.name!,\n                jsonText: '',\n              };\n            }\n\n            const contentBlockDelta = value.contentBlockDelta;\n            if (\n              contentBlockDelta?.delta &&\n              'toolUse' in contentBlockDelta.delta &&\n              contentBlockDelta.delta.toolUse\n            ) {\n              const contentBlock =\n                toolCallContentBlocks[contentBlockDelta.contentBlockIndex!];\n              const delta = contentBlockDelta.delta.toolUse.input ?? '';\n\n              controller.enqueue({\n                type: 'tool-call-delta',\n                toolCallType: 'function',\n                toolCallId: contentBlock.toolCallId,\n                toolName: contentBlock.toolName,\n                argsTextDelta: delta,\n              });\n\n              contentBlock.jsonText += delta;\n            }\n\n            const contentBlockStop = value.contentBlockStop;\n            if (contentBlockStop != null) {\n              const index = contentBlockStop.contentBlockIndex!;\n              const contentBlock = toolCallContentBlocks[index];\n\n              // when finishing a tool call block, send the full tool call:\n              if (contentBlock != null) {\n                controller.enqueue({\n                  type: 'tool-call',\n                  toolCallType: 'function',\n                  toolCallId: contentBlock.toolCallId,\n                  toolName: contentBlock.toolName,\n                  args: contentBlock.jsonText,\n                });\n\n                delete toolCallContentBlocks[index];\n              }\n            }\n          },\n          flush(controller) {\n            controller.enqueue({\n              type: 'finish',\n              finishReason,\n              usage,\n              ...(providerMetadata && { providerMetadata }),\n            });\n          },\n        }),\n      ),\n      rawCall: { rawPrompt, rawSettings },\n      rawResponse: { headers: responseHeaders },\n      warnings,\n    };\n  }\n\n  private getUrl(modelId: string) {\n    const encodedModelId = encodeURIComponent(modelId);\n    return `${this.config.baseUrl()}/model/${encodedModelId}`;\n  }\n}\n\nconst BedrockReasoningConfigOptionsSchema = z\n  .object({\n    type: z.union([z.literal('enabled'), z.literal('disabled')]).nullish(),\n    budget_tokens: z.number().nullish(),\n    budgetTokens: z.number().nullish(),\n  })\n  .nullish();\n\nconst BedrockStopReasonSchema = z.union([\n  z.enum(BEDROCK_STOP_REASONS),\n  z.string(),\n]);\n\nconst BedrockToolUseSchema = z.object({\n  toolUseId: z.string(),\n  name: z.string(),\n  input: z.unknown(),\n});\n\nconst BedrockReasoningTextSchema = z.object({\n  signature: z.string().nullish(),\n  text: z.string(),\n});\n\nconst BedrockRedactedReasoningSchema = z.object({\n  data: z.string(),\n});\n\n// limited version of the schema, focused on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst BedrockResponseSchema = z.object({\n  metrics: z\n    .object({\n      latencyMs: z.number(),\n    })\n    .nullish(),\n  output: z.object({\n    message: z.object({\n      content: z.array(\n        z.object({\n          text: z.string().nullish(),\n          toolUse: BedrockToolUseSchema.nullish(),\n          reasoningContent: z\n            .union([\n              z.object({\n                reasoningText: BedrockReasoningTextSchema,\n              }),\n              z.object({\n                redactedReasoning: BedrockRedactedReasoningSchema,\n              }),\n            ])\n            .nullish(),\n        }),\n      ),\n      role: z.string(),\n    }),\n  }),\n  stopReason: BedrockStopReasonSchema,\n  trace: z.unknown().nullish(),\n  usage: z.object({\n    inputTokens: z.number(),\n    outputTokens: z.number(),\n    totalTokens: z.number(),\n    cacheReadInputTokens: z.number().nullish(),\n    cacheWriteInputTokens: z.number().nullish(),\n  }),\n});\n\n// limited version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst BedrockStreamSchema = z.object({\n  contentBlockDelta: z\n    .object({\n      contentBlockIndex: z.number(),\n      delta: z\n        .union([\n          z.object({ text: z.string() }),\n          z.object({ toolUse: z.object({ input: z.string() }) }),\n          z.object({\n            reasoningContent: z.object({ text: z.string() }),\n          }),\n          z.object({\n            reasoningContent: z.object({\n              signature: z.string(),\n            }),\n          }),\n          z.object({\n            reasoningContent: z.object({ data: z.string() }),\n          }),\n        ])\n        .nullish(),\n    })\n    .nullish(),\n  contentBlockStart: z\n    .object({\n      contentBlockIndex: z.number(),\n      start: z\n        .object({\n          toolUse: BedrockToolUseSchema.nullish(),\n        })\n        .nullish(),\n    })\n    .nullish(),\n  contentBlockStop: z\n    .object({\n      contentBlockIndex: z.number(),\n    })\n    .nullish(),\n  internalServerException: z.record(z.unknown()).nullish(),\n  messageStop: z\n    .object({\n      additionalModelResponseFields: z.record(z.unknown()).nullish(),\n      stopReason: BedrockStopReasonSchema,\n    })\n    .nullish(),\n  metadata: z\n    .object({\n      trace: z.unknown().nullish(),\n      usage: z\n        .object({\n          cacheReadInputTokens: z.number().nullish(),\n          cacheWriteInputTokens: z.number().nullish(),\n          inputTokens: z.number(),\n          outputTokens: z.number(),\n        })\n        .nullish(),\n    })\n    .nullish(),\n  modelStreamErrorException: z.record(z.unknown()).nullish(),\n  throttlingException: z.record(z.unknown()).nullish(),\n  validationException: z.record(z.unknown()).nullish(),\n});\n","import { JSONObject } from '@ai-sdk/provider';\n\nexport interface BedrockConverseInput {\n  system?: BedrockSystemMessages;\n  messages: BedrockMessages;\n  toolConfig?: BedrockToolConfiguration;\n  inferenceConfig?: {\n    maxTokens?: number;\n    temperature?: number;\n    topP?: number;\n    stopSequences?: string[];\n  };\n  additionalModelRequestFields?: Record<string, unknown>;\n  guardrailConfig?:\n    | BedrockGuardrailConfiguration\n    | BedrockGuardrailStreamConfiguration\n    | undefined;\n}\n\nexport type BedrockSystemMessages = Array<BedrockSystemContentBlock>;\n\nexport type BedrockMessages = Array<\n  BedrockAssistantMessage | BedrockUserMessage\n>;\n\nexport interface BedrockAssistantMessage {\n  role: 'assistant';\n  content: Array<BedrockContentBlock>;\n}\n\nexport interface BedrockUserMessage {\n  role: 'user';\n  content: Array<BedrockContentBlock>;\n}\n\nexport const BEDROCK_CACHE_POINT = {\n  cachePoint: { type: 'default' },\n} as const;\n\nexport type BedrockCachePoint = { cachePoint: { type: 'default' } };\nexport type BedrockSystemContentBlock = { text: string } | BedrockCachePoint;\n\nexport interface BedrockGuardrailConfiguration {\n  guardrails?: Array<{\n    name: string;\n    description?: string;\n    parameters?: Record<string, unknown>;\n  }>;\n}\n\nexport type BedrockGuardrailStreamConfiguration = BedrockGuardrailConfiguration;\n\nexport interface BedrockToolInputSchema {\n  json: Record<string, unknown>;\n}\n\nexport interface BedrockTool {\n  toolSpec: {\n    name: string;\n    description?: string;\n    inputSchema: { json: JSONObject };\n  };\n}\n\nexport interface BedrockToolConfiguration {\n  tools?: Array<BedrockTool | BedrockCachePoint>;\n  toolChoice?:\n    | { tool: { name: string } }\n    | { auto: {} }\n    | { any: {} }\n    | undefined;\n}\n\nexport const BEDROCK_STOP_REASONS = [\n  'stop',\n  'stop_sequence',\n  'end_turn',\n  'length',\n  'max_tokens',\n  'content-filter',\n  'content_filtered',\n  'guardrail_intervened',\n  'tool-calls',\n  'tool_use',\n] as const;\n\nexport type BedrockStopReason = (typeof BEDROCK_STOP_REASONS)[number];\n\nexport type BedrockImageFormat = 'jpeg' | 'png' | 'gif';\nexport type BedrockDocumentFormat = 'pdf' | 'txt' | 'md';\n\nexport interface BedrockDocumentBlock {\n  document: {\n    format: BedrockDocumentFormat;\n    name: string;\n    source: {\n      bytes: string;\n    };\n  };\n}\n\nexport interface BedrockGuardrailConverseContentBlock {\n  guardContent: unknown;\n}\n\nexport interface BedrockImageBlock {\n  image: {\n    format: BedrockImageFormat;\n    source: {\n      bytes: string;\n    };\n  };\n}\n\nexport interface BedrockToolResultBlock {\n  toolResult: {\n    toolUseId: string;\n    content: Array<BedrockTextBlock | BedrockImageBlock>;\n  };\n}\n\nexport interface BedrockToolUseBlock {\n  toolUse: {\n    toolUseId: string;\n    name: string;\n    input: Record<string, unknown>;\n  };\n}\n\nexport interface BedrockTextBlock {\n  text: string;\n}\n\nexport interface BedrockReasoningContentBlock {\n  reasoningContent: {\n    reasoningText: {\n      text: string;\n      signature?: string;\n    };\n  };\n}\n\nexport interface BedrockRedactedReasoningContentBlock {\n  reasoningContent: {\n    redactedReasoning: {\n      data: string;\n    };\n  };\n}\n\nexport type BedrockContentBlock =\n  | BedrockDocumentBlock\n  | BedrockGuardrailConverseContentBlock\n  | BedrockImageBlock\n  | BedrockTextBlock\n  | BedrockToolResultBlock\n  | BedrockToolUseBlock\n  | BedrockReasoningContentBlock\n  | BedrockRedactedReasoningContentBlock\n  | BedrockCachePoint;\n","import { z } from 'zod';\n\nexport const BedrockErrorSchema = z.object({\n  message: z.string(),\n  type: z.string().nullish(),\n});\n","import { EmptyResponseBodyError } from '@ai-sdk/provider';\nimport {\n  ParseResult,\n  safeParseJSON,\n  extractResponseHeaders,\n  ResponseHandler,\n  safeValidateTypes,\n} from '@ai-sdk/provider-utils';\nimport { EventStreamCodec } from '@smithy/eventstream-codec';\nimport { toUtf8, fromUtf8 } from '@smithy/util-utf8';\nimport { ZodSchema } from 'zod';\n\n// https://docs.aws.amazon.com/lexv2/latest/dg/event-stream-encoding.html\nexport const createBedrockEventStreamResponseHandler =\n  <T>(\n    chunkSchema: ZodSchema<T>,\n  ): ResponseHandler<ReadableStream<ParseResult<T>>> =>\n  async ({ response }: { response: Response }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (response.body == null) {\n      throw new EmptyResponseBodyError({});\n    }\n\n    const codec = new EventStreamCodec(toUtf8, fromUtf8);\n    let buffer = new Uint8Array(0);\n    const textDecoder = new TextDecoder();\n\n    return {\n      responseHeaders,\n      value: response.body.pipeThrough(\n        new TransformStream<Uint8Array, ParseResult<T>>({\n          transform(chunk, controller) {\n            // Append new chunk to buffer.\n            const newBuffer = new Uint8Array(buffer.length + chunk.length);\n            newBuffer.set(buffer);\n            newBuffer.set(chunk, buffer.length);\n            buffer = newBuffer;\n\n            // Try to decode messages from buffer.\n            while (buffer.length >= 4) {\n              // The first 4 bytes are the total length (big-endian).\n              const totalLength = new DataView(\n                buffer.buffer,\n                buffer.byteOffset,\n                buffer.byteLength,\n              ).getUint32(0, false);\n\n              // If we don't have the full message yet, wait for more chunks.\n              if (buffer.length < totalLength) {\n                break;\n              }\n\n              try {\n                // Decode exactly the sub-slice for this event.\n                const subView = buffer.subarray(0, totalLength);\n                const decoded = codec.decode(subView);\n\n                // Slice the used bytes out of the buffer, removing this message.\n                buffer = buffer.slice(totalLength);\n\n                // Process the message.\n                if (decoded.headers[':message-type']?.value === 'event') {\n                  const data = textDecoder.decode(decoded.body);\n\n                  // Wrap the data in the `:event-type` field to match the expected schema.\n                  const parsedDataResult = safeParseJSON({ text: data });\n                  if (!parsedDataResult.success) {\n                    controller.enqueue(parsedDataResult);\n                    break;\n                  }\n\n                  // The `p` field appears to be padding or some other non-functional field.\n                  delete (parsedDataResult.value as any).p;\n                  let wrappedData = {\n                    [decoded.headers[':event-type']?.value as string]:\n                      parsedDataResult.value,\n                  };\n\n                  // Re-validate with the expected schema.\n                  const validatedWrappedData = safeValidateTypes({\n                    value: wrappedData,\n                    schema: chunkSchema,\n                  });\n                  if (!validatedWrappedData.success) {\n                    controller.enqueue(validatedWrappedData);\n                  } else {\n                    controller.enqueue({\n                      success: true,\n                      value: validatedWrappedData.value,\n                      rawValue: wrappedData,\n                    });\n                  }\n                }\n              } catch (e) {\n                // If we can't decode a complete message, wait for more data\n                break;\n              }\n            }\n          },\n        }),\n      ),\n    };\n  };\n","import {\n  JSONObject,\n  LanguageModelV1,\n  LanguageModelV1CallWarning,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport { BedrockTool, BedrockToolConfiguration } from './bedrock-api-types';\n\nexport function prepareTools(\n  mode: Parameters<LanguageModelV1['doGenerate']>[0]['mode'] & {\n    type: 'regular';\n  },\n): {\n  toolConfig: BedrockToolConfiguration; // note: do not rename, name required by Bedrock\n  toolWarnings: LanguageModelV1CallWarning[];\n} {\n  // when the tools array is empty, change it to undefined to prevent errors:\n  const tools = mode.tools?.length ? mode.tools : undefined;\n\n  if (tools == null) {\n    return {\n      toolConfig: { tools: undefined, toolChoice: undefined },\n      toolWarnings: [],\n    };\n  }\n\n  const toolWarnings: LanguageModelV1CallWarning[] = [];\n  const bedrockTools: BedrockTool[] = [];\n\n  for (const tool of tools) {\n    if (tool.type === 'provider-defined') {\n      toolWarnings.push({ type: 'unsupported-tool', tool });\n    } else {\n      bedrockTools.push({\n        toolSpec: {\n          name: tool.name,\n          description: tool.description,\n          inputSchema: {\n            json: tool.parameters as JSONObject,\n          },\n        },\n      });\n    }\n  }\n\n  const toolChoice = mode.toolChoice;\n\n  if (toolChoice == null) {\n    return {\n      toolConfig: { tools: bedrockTools, toolChoice: undefined },\n      toolWarnings,\n    };\n  }\n\n  const type = toolChoice.type;\n\n  switch (type) {\n    case 'auto':\n      return {\n        toolConfig: { tools: bedrockTools, toolChoice: { auto: {} } },\n        toolWarnings,\n      };\n    case 'required':\n      return {\n        toolConfig: { tools: bedrockTools, toolChoice: { any: {} } },\n        toolWarnings,\n      };\n    case 'none':\n      // Bedrock does not support 'none' tool choice, so we remove the tools:\n      return {\n        toolConfig: { tools: undefined, toolChoice: undefined },\n        toolWarnings,\n      };\n    case 'tool':\n      return {\n        toolConfig: {\n          tools: bedrockTools,\n          toolChoice: { tool: { name: toolChoice.toolName } },\n        },\n        toolWarnings,\n      };\n    default: {\n      const _exhaustiveCheck: never = type;\n      throw new UnsupportedFunctionalityError({\n        functionality: `Unsupported tool choice type: ${_exhaustiveCheck}`,\n      });\n    }\n  }\n}\n","import {\n  BEDROCK_CACHE_POINT,\n  BedrockAssistantMessage,\n  BedrockCachePoint,\n  BedrockDocumentFormat,\n  BedrockImageFormat,\n  BedrockMessages,\n  BedrockSystemMessages,\n  BedrockUserMessage,\n} from './bedrock-api-types';\nimport {\n  JSONObject,\n  LanguageModelV1Message,\n  LanguageModelV1Prompt,\n  LanguageModelV1ProviderMetadata,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport {\n  convertUint8ArrayToBase64,\n  createIdGenerator,\n} from '@ai-sdk/provider-utils';\n\nconst generateFileId = createIdGenerator({ prefix: 'file', size: 16 });\n\nfunction getCachePoint(\n  providerMetadata: LanguageModelV1ProviderMetadata | undefined,\n): BedrockCachePoint | undefined {\n  return providerMetadata?.bedrock?.cachePoint as BedrockCachePoint | undefined;\n}\n\nexport function convertToBedrockChatMessages(prompt: LanguageModelV1Prompt): {\n  system: BedrockSystemMessages;\n  messages: BedrockMessages;\n} {\n  const blocks = groupIntoBlocks(prompt);\n\n  let system: BedrockSystemMessages = [];\n  const messages: BedrockMessages = [];\n\n  for (let i = 0; i < blocks.length; i++) {\n    const block = blocks[i];\n    const isLastBlock = i === blocks.length - 1;\n    const type = block.type;\n\n    switch (type) {\n      case 'system': {\n        if (messages.length > 0) {\n          throw new UnsupportedFunctionalityError({\n            functionality:\n              'Multiple system messages that are separated by user/assistant messages',\n          });\n        }\n\n        for (const message of block.messages) {\n          system.push({ text: message.content });\n          if (getCachePoint(message.providerMetadata)) {\n            system.push(BEDROCK_CACHE_POINT);\n          }\n        }\n        break;\n      }\n\n      case 'user': {\n        // combines all user and tool messages in this block into a single message:\n        const bedrockContent: BedrockUserMessage['content'] = [];\n\n        for (const message of block.messages) {\n          const { role, content, providerMetadata } = message;\n          switch (role) {\n            case 'user': {\n              for (let j = 0; j < content.length; j++) {\n                const part = content[j];\n\n                switch (part.type) {\n                  case 'text': {\n                    bedrockContent.push({\n                      text: part.text,\n                    });\n                    break;\n                  }\n                  case 'image': {\n                    if (part.image instanceof URL) {\n                      // The AI SDK automatically downloads images for user image parts with URLs\n                      throw new UnsupportedFunctionalityError({\n                        functionality: 'Image URLs in user messages',\n                      });\n                    }\n\n                    bedrockContent.push({\n                      image: {\n                        format: part.mimeType?.split(\n                          '/',\n                        )?.[1] as BedrockImageFormat,\n                        source: {\n                          bytes: convertUint8ArrayToBase64(\n                            part.image ?? (part.image as Uint8Array),\n                          ),\n                        },\n                      },\n                    });\n\n                    break;\n                  }\n                  case 'file': {\n                    if (part.data instanceof URL) {\n                      // The AI SDK automatically downloads files for user file parts with URLs\n                      throw new UnsupportedFunctionalityError({\n                        functionality: 'File URLs in user messages',\n                      });\n                    }\n\n                    bedrockContent.push({\n                      document: {\n                        format: part.mimeType?.split(\n                          '/',\n                        )?.[1] as BedrockDocumentFormat,\n                        name: generateFileId(),\n                        source: {\n                          bytes: part.data,\n                        },\n                      },\n                    });\n\n                    break;\n                  }\n                }\n              }\n\n              break;\n            }\n            case 'tool': {\n              for (let i = 0; i < content.length; i++) {\n                const part = content[i];\n                const toolResultContent =\n                  part.content != undefined\n                    ? part.content.map(part => {\n                        switch (part.type) {\n                          case 'text':\n                            return {\n                              text: part.text,\n                            };\n                          case 'image':\n                            if (!part.mimeType) {\n                              throw new Error(\n                                'Image mime type is required in tool result part content',\n                              );\n                            }\n                            const format = part.mimeType.split('/')[1];\n                            if (!isBedrockImageFormat(format)) {\n                              throw new Error(\n                                `Unsupported image format: ${format}`,\n                              );\n                            }\n                            return {\n                              image: {\n                                format,\n                                source: {\n                                  bytes: part.data,\n                                },\n                              },\n                            };\n                        }\n                      })\n                    : [{ text: JSON.stringify(part.result) }];\n\n                bedrockContent.push({\n                  toolResult: {\n                    toolUseId: part.toolCallId,\n                    content: toolResultContent,\n                  },\n                });\n              }\n\n              break;\n            }\n            default: {\n              const _exhaustiveCheck: never = role;\n              throw new Error(`Unsupported role: ${_exhaustiveCheck}`);\n            }\n          }\n\n          if (getCachePoint(providerMetadata)) {\n            bedrockContent.push(BEDROCK_CACHE_POINT);\n          }\n        }\n\n        messages.push({ role: 'user', content: bedrockContent });\n\n        break;\n      }\n\n      case 'assistant': {\n        // combines multiple assistant messages in this block into a single message:\n        const bedrockContent: BedrockAssistantMessage['content'] = [];\n\n        for (let j = 0; j < block.messages.length; j++) {\n          const message = block.messages[j];\n          const isLastMessage = j === block.messages.length - 1;\n          const { content } = message;\n\n          for (let k = 0; k < content.length; k++) {\n            const part = content[k];\n            const isLastContentPart = k === content.length - 1;\n\n            switch (part.type) {\n              case 'text': {\n                bedrockContent.push({\n                  text:\n                    // trim the last text part if it's the last message in the block\n                    // because Bedrock does not allow trailing whitespace\n                    // in pre-filled assistant responses\n                    trimIfLast(\n                      isLastBlock,\n                      isLastMessage,\n                      isLastContentPart,\n                      part.text,\n                    ),\n                });\n                break;\n              }\n\n              case 'reasoning': {\n                bedrockContent.push({\n                  reasoningContent: {\n                    reasoningText: {\n                      // trim the last text part if it's the last message in the block\n                      // because Bedrock does not allow trailing whitespace\n                      // in pre-filled assistant responses\n                      text: trimIfLast(\n                        isLastBlock,\n                        isLastMessage,\n                        isLastContentPart,\n                        part.text,\n                      ),\n                      signature: part.signature,\n                    },\n                  },\n                });\n                break;\n              }\n\n              case 'redacted-reasoning': {\n                bedrockContent.push({\n                  reasoningContent: {\n                    redactedReasoning: {\n                      data: part.data,\n                    },\n                  },\n                });\n                break;\n              }\n\n              case 'tool-call': {\n                bedrockContent.push({\n                  toolUse: {\n                    toolUseId: part.toolCallId,\n                    name: part.toolName,\n                    input: part.args as JSONObject,\n                  },\n                });\n                break;\n              }\n            }\n          }\n          if (getCachePoint(message.providerMetadata)) {\n            bedrockContent.push(BEDROCK_CACHE_POINT);\n          }\n        }\n\n        messages.push({ role: 'assistant', content: bedrockContent });\n\n        break;\n      }\n\n      default: {\n        const _exhaustiveCheck: never = type;\n        throw new Error(`Unsupported type: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  return { system, messages };\n}\n\nfunction isBedrockImageFormat(format: string): format is BedrockImageFormat {\n  return ['jpeg', 'png', 'gif'].includes(format);\n}\n\nfunction trimIfLast(\n  isLastBlock: boolean,\n  isLastMessage: boolean,\n  isLastContentPart: boolean,\n  text: string,\n) {\n  return isLastBlock && isLastMessage && isLastContentPart ? text.trim() : text;\n}\n\ntype SystemBlock = {\n  type: 'system';\n  messages: Array<LanguageModelV1Message & { role: 'system' }>;\n};\ntype AssistantBlock = {\n  type: 'assistant';\n  messages: Array<LanguageModelV1Message & { role: 'assistant' }>;\n};\ntype UserBlock = {\n  type: 'user';\n  messages: Array<LanguageModelV1Message & { role: 'user' | 'tool' }>;\n};\n\nfunction groupIntoBlocks(\n  prompt: LanguageModelV1Prompt,\n): Array<SystemBlock | AssistantBlock | UserBlock> {\n  const blocks: Array<SystemBlock | AssistantBlock | UserBlock> = [];\n  let currentBlock: SystemBlock | AssistantBlock | UserBlock | undefined =\n    undefined;\n\n  for (const message of prompt) {\n    const { role } = message;\n    switch (role) {\n      case 'system': {\n        if (currentBlock?.type !== 'system') {\n          currentBlock = { type: 'system', messages: [] };\n          blocks.push(currentBlock);\n        }\n\n        currentBlock.messages.push(message);\n        break;\n      }\n      case 'assistant': {\n        if (currentBlock?.type !== 'assistant') {\n          currentBlock = { type: 'assistant', messages: [] };\n          blocks.push(currentBlock);\n        }\n\n        currentBlock.messages.push(message);\n        break;\n      }\n      case 'user': {\n        if (currentBlock?.type !== 'user') {\n          currentBlock = { type: 'user', messages: [] };\n          blocks.push(currentBlock);\n        }\n\n        currentBlock.messages.push(message);\n        break;\n      }\n      case 'tool': {\n        if (currentBlock?.type !== 'user') {\n          currentBlock = { type: 'user', messages: [] };\n          blocks.push(currentBlock);\n        }\n\n        currentBlock.messages.push(message);\n        break;\n      }\n      default: {\n        const _exhaustiveCheck: never = role;\n        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  return blocks;\n}\n","import { LanguageModelV1FinishReason } from '@ai-sdk/provider';\nimport { BedrockStopReason } from './bedrock-api-types';\n\nexport function mapBedrockFinishReason(\n  finishReason?: BedrockStopReason,\n): LanguageModelV1FinishReason {\n  switch (finishReason) {\n    case 'stop_sequence':\n    case 'end_turn':\n      return 'stop';\n    case 'max_tokens':\n      return 'length';\n    case 'content_filtered':\n    case 'guardrail_intervened':\n      return 'content-filter';\n    case 'tool_use':\n      return 'tool-calls';\n    default:\n      return 'unknown';\n  }\n}\n","import { EmbeddingModelV1, EmbeddingModelV1Embedding } from '@ai-sdk/provider';\nimport {\n  FetchFunction,\n  Resolvable,\n  combineHeaders,\n  createJsonErrorResponseHandler,\n  createJsonResponseHandler,\n  postJsonToApi,\n  resolve,\n} from '@ai-sdk/provider-utils';\nimport {\n  BedrockEmbeddingModelId,\n  BedrockEmbeddingSettings,\n} from './bedrock-embedding-settings';\nimport { BedrockErrorSchema } from './bedrock-error';\nimport { z } from 'zod';\n\ntype BedrockEmbeddingConfig = {\n  baseUrl: () => string;\n  headers: Resolvable<Record<string, string | undefined>>;\n  fetch?: FetchFunction;\n};\n\ntype DoEmbedResponse = Awaited<ReturnType<EmbeddingModelV1<string>['doEmbed']>>;\n\nexport class BedrockEmbeddingModel implements EmbeddingModelV1<string> {\n  readonly specificationVersion = 'v1';\n  readonly provider = 'amazon-bedrock';\n  readonly maxEmbeddingsPerCall = undefined;\n  readonly supportsParallelCalls = true;\n\n  constructor(\n    readonly modelId: BedrockEmbeddingModelId,\n    private readonly settings: BedrockEmbeddingSettings,\n    private readonly config: BedrockEmbeddingConfig,\n  ) {}\n\n  private getUrl(modelId: string): string {\n    const encodedModelId = encodeURIComponent(modelId);\n    return `${this.config.baseUrl()}/model/${encodedModelId}/invoke`;\n  }\n\n  async doEmbed({\n    values,\n    headers,\n    abortSignal,\n  }: Parameters<\n    EmbeddingModelV1<string>['doEmbed']\n  >[0]): Promise<DoEmbedResponse> {\n    const embedSingleText = async (inputText: string) => {\n      // https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_InvokeModel.html\n      const args = {\n        inputText,\n        dimensions: this.settings.dimensions,\n        normalize: this.settings.normalize,\n      };\n      const url = this.getUrl(this.modelId);\n      const { value: response } = await postJsonToApi({\n        url,\n        headers: await resolve(\n          combineHeaders(await resolve(this.config.headers), headers),\n        ),\n        body: args,\n        failedResponseHandler: createJsonErrorResponseHandler({\n          errorSchema: BedrockErrorSchema,\n          errorToMessage: error => `${error.type}: ${error.message}`,\n        }),\n        successfulResponseHandler: createJsonResponseHandler(\n          BedrockEmbeddingResponseSchema,\n        ),\n        fetch: this.config.fetch,\n        abortSignal,\n      });\n\n      return {\n        embedding: response.embedding,\n        inputTextTokenCount: response.inputTextTokenCount,\n      };\n    };\n\n    const responses = await Promise.all(values.map(embedSingleText));\n    return responses.reduce<{\n      embeddings: EmbeddingModelV1Embedding[];\n      usage: { tokens: number };\n    }>(\n      (accumulated, response) => {\n        accumulated.embeddings.push(response.embedding);\n        accumulated.usage.tokens += response.inputTextTokenCount;\n        return accumulated;\n      },\n      { embeddings: [], usage: { tokens: 0 } },\n    );\n  }\n}\n\nconst BedrockEmbeddingResponseSchema = z.object({\n  embedding: z.array(z.number()),\n  inputTextTokenCount: z.number(),\n});\n","import { ImageModelV1, ImageModelV1CallWarning } from '@ai-sdk/provider';\nimport {\n  FetchFunction,\n  Resolvable,\n  combineHeaders,\n  createJsonErrorResponseHandler,\n  createJsonResponseHandler,\n  postJsonToApi,\n  resolve,\n} from '@ai-sdk/provider-utils';\nimport {\n  BedrockImageModelId,\n  BedrockImageSettings,\n  modelMaxImagesPerCall,\n} from './bedrock-image-settings';\nimport { BedrockErrorSchema } from './bedrock-error';\nimport { z } from 'zod';\n\ntype BedrockImageModelConfig = {\n  baseUrl: () => string;\n  headers: Resolvable<Record<string, string | undefined>>;\n  fetch?: FetchFunction;\n  _internal?: {\n    currentDate?: () => Date;\n  };\n};\n\nexport class BedrockImageModel implements ImageModelV1 {\n  readonly specificationVersion = 'v1';\n  readonly provider = 'amazon-bedrock';\n\n  get maxImagesPerCall(): number {\n    return (\n      this.settings.maxImagesPerCall ?? modelMaxImagesPerCall[this.modelId] ?? 1\n    );\n  }\n\n  private getUrl(modelId: string): string {\n    const encodedModelId = encodeURIComponent(modelId);\n    return `${this.config.baseUrl()}/model/${encodedModelId}/invoke`;\n  }\n\n  constructor(\n    readonly modelId: BedrockImageModelId,\n    private readonly settings: BedrockImageSettings,\n    private readonly config: BedrockImageModelConfig,\n  ) {}\n\n  async doGenerate({\n    prompt,\n    n,\n    size,\n    aspectRatio,\n    seed,\n    providerOptions,\n    headers,\n    abortSignal,\n  }: Parameters<ImageModelV1['doGenerate']>[0]): Promise<\n    Awaited<ReturnType<ImageModelV1['doGenerate']>>\n  > {\n    const warnings: Array<ImageModelV1CallWarning> = [];\n    const [width, height] = size ? size.split('x').map(Number) : [];\n    const args = {\n      taskType: 'TEXT_IMAGE',\n      textToImageParams: {\n        text: prompt,\n        ...(providerOptions?.bedrock?.negativeText\n          ? {\n              negativeText: providerOptions.bedrock.negativeText,\n            }\n          : {}),\n      },\n      imageGenerationConfig: {\n        ...(width ? { width } : {}),\n        ...(height ? { height } : {}),\n        ...(seed ? { seed } : {}),\n        ...(n ? { numberOfImages: n } : {}),\n        ...(providerOptions?.bedrock?.quality\n          ? { quality: providerOptions.bedrock.quality }\n          : {}),\n        ...(providerOptions?.bedrock?.cfgScale\n          ? { cfgScale: providerOptions.bedrock.cfgScale }\n          : {}),\n      },\n    };\n\n    if (aspectRatio != undefined) {\n      warnings.push({\n        type: 'unsupported-setting',\n        setting: 'aspectRatio',\n        details:\n          'This model does not support aspect ratio. Use `size` instead.',\n      });\n    }\n\n    const currentDate = this.config._internal?.currentDate?.() ?? new Date();\n    const { value: response, responseHeaders } = await postJsonToApi({\n      url: this.getUrl(this.modelId),\n      headers: await resolve(\n        combineHeaders(await resolve(this.config.headers), headers),\n      ),\n      body: args,\n      failedResponseHandler: createJsonErrorResponseHandler({\n        errorSchema: BedrockErrorSchema,\n        errorToMessage: error => `${error.type}: ${error.message}`,\n      }),\n      successfulResponseHandler: createJsonResponseHandler(\n        bedrockImageResponseSchema,\n      ),\n      abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    return {\n      images: response.images,\n      warnings,\n      response: {\n        timestamp: currentDate,\n        modelId: this.modelId,\n        headers: responseHeaders,\n      },\n    };\n  }\n}\n\n// minimal version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst bedrockImageResponseSchema = z.object({\n  images: z.array(z.string()),\n});\n","export type BedrockImageModelId = 'amazon.nova-canvas-v1:0' | (string & {});\n\n// https://docs.aws.amazon.com/nova/latest/userguide/image-gen-req-resp-structure.html\nexport const modelMaxImagesPerCall: Record<BedrockImageModelId, number> = {\n  'amazon.nova-canvas-v1:0': 5,\n};\n\nexport interface BedrockImageSettings {\n  /**\n   * Override the maximum number of images per call (default is dependent on the\n   * model, or 1 for an unknown model).\n   */\n  maxImagesPerCall?: number;\n}\n","/**\n * Extract headers from a `HeadersInit` object and convert them to a record of\n * lowercase keys and (preserving original case) values.\n * @param headers - The `HeadersInit` object to extract headers from.\n * @returns A record of lowercase keys and (preserving original case) values.\n */\nexport function extractHeaders(\n  headers: HeadersInit | undefined,\n): Record<string, string | undefined> {\n  let originalHeaders: Record<string, string | undefined> = {};\n  if (headers) {\n    if (headers instanceof Headers) {\n      originalHeaders = convertHeadersToRecord(headers);\n    } else if (Array.isArray(headers)) {\n      for (const [k, v] of headers) {\n        originalHeaders[k.toLowerCase()] = v;\n      }\n    } else {\n      originalHeaders = Object.fromEntries(\n        Object.entries(headers).map(([k, v]) => [k.toLowerCase(), v]),\n      ) as Record<string, string>;\n    }\n  }\n  return originalHeaders;\n}\n\n/**\n * Convert a Headers object to a record of lowercase keys and (preserving\n * original case) values.\n * @param headers - The Headers object to convert.\n * @returns A record of lowercase keys and values.\n */\nexport function convertHeadersToRecord(\n  headers: Headers,\n): Record<string, string> {\n  const record: Record<string, string> = {};\n  headers.forEach((value, key) => {\n    record[key.toLowerCase()] = value;\n  });\n  return record;\n}\n","import { convertHeadersToRecord, extractHeaders } from './headers-utils';\nimport {\n  FetchFunction,\n  combineHeaders,\n  removeUndefinedEntries,\n} from '@ai-sdk/provider-utils';\nimport { AwsV4Signer } from 'aws4fetch';\n\nexport interface BedrockCredentials {\n  region: string;\n  accessKeyId: string;\n  secretAccessKey: string;\n  sessionToken?: string;\n}\n\n/**\nCreates a fetch function that applies AWS Signature Version 4 signing.\n\n@param getCredentials - Function that returns the AWS credentials to use when signing.\n@param fetch - Optional original fetch implementation to wrap. Defaults to global fetch.\n@returns A FetchFunction that signs requests before passing them to the underlying fetch.\n */\nexport function createSigV4FetchFunction(\n  getCredentials: () => BedrockCredentials | PromiseLike<BedrockCredentials>,\n  fetch: FetchFunction = globalThis.fetch,\n): FetchFunction {\n  return async (\n    input: RequestInfo | URL,\n    init?: RequestInit,\n  ): Promise<Response> => {\n    if (init?.method?.toUpperCase() !== 'POST' || !init?.body) {\n      return fetch(input, init);\n    }\n\n    const url =\n      typeof input === 'string'\n        ? input\n        : input instanceof URL\n          ? input.href\n          : input.url;\n\n    const originalHeaders = extractHeaders(init.headers);\n    const body = prepareBodyString(init.body);\n    const credentials = await getCredentials();\n    const signer = new AwsV4Signer({\n      url,\n      method: 'POST',\n      headers: Object.entries(removeUndefinedEntries(originalHeaders)),\n      body,\n      region: credentials.region,\n      accessKeyId: credentials.accessKeyId,\n      secretAccessKey: credentials.secretAccessKey,\n      sessionToken: credentials.sessionToken,\n      service: 'bedrock',\n    });\n\n    const signingResult = await signer.sign();\n    const signedHeaders = convertHeadersToRecord(signingResult.headers);\n    return fetch(input, {\n      ...init,\n      body,\n      headers: removeUndefinedEntries(\n        combineHeaders(originalHeaders, signedHeaders),\n      ),\n    });\n  };\n}\n\nfunction prepareBodyString(body: BodyInit | undefined): string {\n  if (typeof body === 'string') {\n    return body;\n  } else if (body instanceof Uint8Array) {\n    return new TextDecoder().decode(body);\n  } else if (body instanceof ArrayBuffer) {\n    return new TextDecoder().decode(new Uint8Array(body));\n  } else {\n    return JSON.stringify(body);\n  }\n}\n","/**\n * Symbol used for identifying AI SDK Error instances.\n * Enables checking if an error is an instance of AISDKError across package versions.\n */\nconst marker = 'vercel.ai.error';\nconst symbol = Symbol.for(marker);\n\n/**\n * Custom error class for AI SDK related errors.\n * @extends Error\n */\nexport class AISDKError extends Error {\n  private readonly [symbol] = true; // used in isInstance\n\n  /**\n   * The underlying cause of the error, if any.\n   */\n  readonly cause?: unknown;\n\n  /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */\n  constructor({\n    name,\n    message,\n    cause,\n  }: {\n    name: string;\n    message: string;\n    cause?: unknown;\n  }) {\n    super(message);\n\n    this.name = name;\n    this.cause = cause;\n  }\n\n  /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */\n  static isInstance(error: unknown): error is AISDKError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  protected static hasMarker(error: unknown, marker: string): boolean {\n    const markerSymbol = Symbol.for(marker);\n    return (\n      error != null &&\n      typeof error === 'object' &&\n      markerSymbol in error &&\n      typeof error[markerSymbol] === 'boolean' &&\n      error[markerSymbol] === true\n    );\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_APICallError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class APICallError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly url: string;\n  readonly requestBodyValues: unknown;\n  readonly statusCode?: number;\n\n  readonly responseHeaders?: Record<string, string>;\n  readonly responseBody?: string;\n\n  readonly isRetryable: boolean;\n  readonly data?: unknown;\n\n  constructor({\n    message,\n    url,\n    requestBodyValues,\n    statusCode,\n    responseHeaders,\n    responseBody,\n    cause,\n    isRetryable = statusCode != null &&\n      (statusCode === 408 || // request timeout\n        statusCode === 409 || // conflict\n        statusCode === 429 || // too many requests\n        statusCode >= 500), // server error\n    data,\n  }: {\n    message: string;\n    url: string;\n    requestBodyValues: unknown;\n    statusCode?: number;\n    responseHeaders?: Record<string, string>;\n    responseBody?: string;\n    cause?: unknown;\n    isRetryable?: boolean;\n    data?: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.url = url;\n    this.requestBodyValues = requestBodyValues;\n    this.statusCode = statusCode;\n    this.responseHeaders = responseHeaders;\n    this.responseBody = responseBody;\n    this.isRetryable = isRetryable;\n    this.data = data;\n  }\n\n  static isInstance(error: unknown): error is APICallError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_EmptyResponseBodyError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class EmptyResponseBodyError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message = 'Empty response body' }: { message?: string } = {}) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is EmptyResponseBodyError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","export function getErrorMessage(error: unknown | undefined) {\n  if (error == null) {\n    return 'unknown error';\n  }\n\n  if (typeof error === 'string') {\n    return error;\n  }\n\n  if (error instanceof Error) {\n    return error.message;\n  }\n\n  return JSON.stringify(error);\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidArgumentError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * A function argument is invalid.\n */\nexport class InvalidArgumentError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly argument: string;\n\n  constructor({\n    message,\n    cause,\n    argument,\n  }: {\n    argument: string;\n    message: string;\n    cause?: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.argument = argument;\n  }\n\n  static isInstance(error: unknown): error is InvalidArgumentError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidPromptError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * A prompt is invalid. This error should be thrown by providers when they cannot\n * process a prompt.\n */\nexport class InvalidPromptError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly prompt: unknown;\n\n  constructor({\n    prompt,\n    message,\n    cause,\n  }: {\n    prompt: unknown;\n    message: string;\n    cause?: unknown;\n  }) {\n    super({ name, message: `Invalid prompt: ${message}`, cause });\n\n    this.prompt = prompt;\n  }\n\n  static isInstance(error: unknown): error is InvalidPromptError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidResponseDataError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * Server returned a response with invalid data content.\n * This should be thrown by providers when they cannot parse the response from the API.\n */\nexport class InvalidResponseDataError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly data: unknown;\n\n  constructor({\n    data,\n    message = `Invalid response data: ${JSON.stringify(data)}.`,\n  }: {\n    data: unknown;\n    message?: string;\n  }) {\n    super({ name, message });\n\n    this.data = data;\n  }\n\n  static isInstance(error: unknown): error is InvalidResponseDataError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\nimport { getErrorMessage } from './get-error-message';\n\nconst name = 'AI_JSONParseError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n// TODO v5: rename to ParseError\nexport class JSONParseError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly text: string;\n\n  constructor({ text, cause }: { text: string; cause: unknown }) {\n    super({\n      name,\n      message:\n        `JSON parsing failed: ` +\n        `Text: ${text}.\\n` +\n        `Error message: ${getErrorMessage(cause)}`,\n      cause,\n    });\n\n    this.text = text;\n  }\n\n  static isInstance(error: unknown): error is JSONParseError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_LoadAPIKeyError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class LoadAPIKeyError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message }: { message: string }) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is LoadAPIKeyError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_LoadSettingError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class LoadSettingError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message }: { message: string }) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is LoadSettingError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_NoContentGeneratedError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\nThrown when the AI provider fails to generate any content.\n */\nexport class NoContentGeneratedError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({\n    message = 'No content generated.',\n  }: { message?: string } = {}) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is NoContentGeneratedError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_NoSuchModelError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class NoSuchModelError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly modelId: string;\n  readonly modelType: 'languageModel' | 'textEmbeddingModel' | 'imageModel';\n\n  constructor({\n    errorName = name,\n    modelId,\n    modelType,\n    message = `No such ${modelType}: ${modelId}`,\n  }: {\n    errorName?: string;\n    modelId: string;\n    modelType: 'languageModel' | 'textEmbeddingModel' | 'imageModel';\n    message?: string;\n  }) {\n    super({ name: errorName, message });\n\n    this.modelId = modelId;\n    this.modelType = modelType;\n  }\n\n  static isInstance(error: unknown): error is NoSuchModelError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_TooManyEmbeddingValuesForCallError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class TooManyEmbeddingValuesForCallError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly provider: string;\n  readonly modelId: string;\n  readonly maxEmbeddingsPerCall: number;\n  readonly values: Array<unknown>;\n\n  constructor(options: {\n    provider: string;\n    modelId: string;\n    maxEmbeddingsPerCall: number;\n    values: Array<unknown>;\n  }) {\n    super({\n      name,\n      message:\n        `Too many values for a single embedding call. ` +\n        `The ${options.provider} model \"${options.modelId}\" can only embed up to ` +\n        `${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`,\n    });\n\n    this.provider = options.provider;\n    this.modelId = options.modelId;\n    this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;\n    this.values = options.values;\n  }\n\n  static isInstance(\n    error: unknown,\n  ): error is TooManyEmbeddingValuesForCallError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\nimport { getErrorMessage } from './get-error-message';\n\nconst name = 'AI_TypeValidationError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class TypeValidationError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly value: unknown;\n\n  constructor({ value, cause }: { value: unknown; cause: unknown }) {\n    super({\n      name,\n      message:\n        `Type validation failed: ` +\n        `Value: ${JSON.stringify(value)}.\\n` +\n        `Error message: ${getErrorMessage(cause)}`,\n      cause,\n    });\n\n    this.value = value;\n  }\n\n  static isInstance(error: unknown): error is TypeValidationError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * Wraps an error into a TypeValidationError.\n   * If the cause is already a TypeValidationError with the same value, it returns the cause.\n   * Otherwise, it creates a new TypeValidationError.\n   *\n   * @param {Object} params - The parameters for wrapping the error.\n   * @param {unknown} params.value - The value that failed validation.\n   * @param {unknown} params.cause - The original error or cause of the validation failure.\n   * @returns {TypeValidationError} A TypeValidationError instance.\n   */\n  static wrap({\n    value,\n    cause,\n  }: {\n    value: unknown;\n    cause: unknown;\n  }): TypeValidationError {\n    return TypeValidationError.isInstance(cause) && cause.value === value\n      ? cause\n      : new TypeValidationError({ value, cause });\n  }\n}\n","import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_UnsupportedFunctionalityError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class UnsupportedFunctionalityError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly functionality: string;\n\n  constructor({\n    functionality,\n    message = `'${functionality}' functionality not supported.`,\n  }: {\n    functionality: string;\n    message?: string;\n  }) {\n    super({ name, message });\n    this.functionality = functionality;\n  }\n\n  static isInstance(error: unknown): error is UnsupportedFunctionalityError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { JSONArray, JSONObject, JSONValue } from './json-value';\n\nexport function isJSONValue(value: unknown): value is JSONValue {\n  if (\n    value === null ||\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    typeof value === 'boolean'\n  ) {\n    return true;\n  }\n\n  if (Array.isArray(value)) {\n    return value.every(isJSONValue);\n  }\n\n  if (typeof value === 'object') {\n    return Object.entries(value).every(\n      ([key, val]) => typeof key === 'string' && isJSONValue(val),\n    );\n  }\n\n  return false;\n}\n\nexport function isJSONArray(value: unknown): value is JSONArray {\n  return Array.isArray(value) && value.every(isJSONValue);\n}\n\nexport function isJSONObject(value: unknown): value is JSONObject {\n  return (\n    value != null &&\n    typeof value === 'object' &&\n    Object.entries(value).every(\n      ([key, val]) => typeof key === 'string' && isJSONValue(val),\n    )\n  );\n}\n","export function combineHeaders(\n  ...headers: Array<Record<string, string | undefined> | undefined>\n): Record<string, string | undefined> {\n  return headers.reduce(\n    (combinedHeaders, currentHeaders) => ({\n      ...combinedHeaders,\n      ...(currentHeaders ?? {}),\n    }),\n    {},\n  ) as Record<string, string | undefined>;\n}\n","/**\n * Converts an AsyncIterator to a ReadableStream.\n *\n * @template T - The type of elements produced by the AsyncIterator.\n * @param { <T>} iterator - The AsyncIterator to convert.\n * @returns {ReadableStream<T>} - A ReadableStream that provides the same data as the AsyncIterator.\n */\nexport function convertAsyncIteratorToReadableStream<T>(\n  iterator: AsyncIterator<T>,\n): ReadableStream<T> {\n  return new ReadableStream<T>({\n    /**\n     * Called when the consumer wants to pull more data from the stream.\n     *\n     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.\n     * @returns {Promise<void>}\n     */\n    async pull(controller) {\n      try {\n        const { value, done } = await iterator.next();\n        if (done) {\n          controller.close();\n        } else {\n          controller.enqueue(value);\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    /**\n     * Called when the consumer cancels the stream.\n     */\n    cancel() {},\n  });\n}\n","/**\n * Creates a Promise that resolves after a specified delay\n * @param delayInMs - The delay duration in milliseconds. If null or undefined, resolves immediately.\n * @returns A Promise that resolves after the specified delay\n */\nexport async function delay(delayInMs?: number | null): Promise<void> {\n  return delayInMs == null\n    ? Promise.resolve()\n    : new Promise(resolve => setTimeout(resolve, delayInMs));\n}\n","export type EventSourceChunk = {\n  event: string | undefined;\n  data: string;\n  id?: string;\n  retry?: number;\n};\n\nexport function createEventSourceParserStream() {\n  let buffer = '';\n  let event: string | undefined = undefined;\n  let data: string[] = [];\n  let lastEventId: string | undefined = undefined;\n  let retry: number | undefined = undefined;\n\n  function parseLine(\n    line: string,\n    controller: TransformStreamDefaultController<EventSourceChunk>,\n  ) {\n    // Empty line means dispatch the event\n    if (line === '') {\n      dispatchEvent(controller);\n      return;\n    }\n\n    // Comments start with colon\n    if (line.startsWith(':')) {\n      return;\n    }\n\n    // Field parsing\n    const colonIndex = line.indexOf(':');\n    if (colonIndex === -1) {\n      // field with no value\n      handleField(line, '');\n      return;\n    }\n\n    const field = line.slice(0, colonIndex);\n    // If there's a space after the colon, it should be ignored\n    const valueStart = colonIndex + 1;\n    const value =\n      valueStart < line.length && line[valueStart] === ' '\n        ? line.slice(valueStart + 1)\n        : line.slice(valueStart);\n\n    handleField(field, value);\n  }\n\n  function dispatchEvent(\n    controller: TransformStreamDefaultController<EventSourceChunk>,\n  ) {\n    if (data.length > 0) {\n      controller.enqueue({\n        event,\n        data: data.join('\\n'),\n        id: lastEventId,\n        retry,\n      });\n\n      // Reset data but keep lastEventId as per spec\n      data = [];\n      event = undefined;\n      retry = undefined;\n    }\n  }\n\n  function handleField(field: string, value: string) {\n    switch (field) {\n      case 'event':\n        event = value;\n        break;\n      case 'data':\n        data.push(value);\n        break;\n      case 'id':\n        lastEventId = value;\n        break;\n      case 'retry':\n        const parsedRetry = parseInt(value, 10);\n        if (!isNaN(parsedRetry)) {\n          retry = parsedRetry;\n        }\n        break;\n    }\n  }\n\n  return new TransformStream<string, EventSourceChunk>({\n    transform(chunk, controller) {\n      const { lines, incompleteLine } = splitLines(buffer, chunk);\n\n      buffer = incompleteLine;\n\n      // using for loop for performance\n      for (let i = 0; i < lines.length; i++) {\n        parseLine(lines[i], controller);\n      }\n    },\n\n    flush(controller) {\n      parseLine(buffer, controller);\n      dispatchEvent(controller);\n    },\n  });\n}\n\n// performance: send in already scanned buffer separately, do not scan again\nfunction splitLines(buffer: string, chunk: string) {\n  const lines: Array<string> = [];\n  let currentLine = buffer;\n\n  // using for loop for performance\n  for (let i = 0; i < chunk.length; ) {\n    const char = chunk[i++];\n\n    // order is performance-optimized\n    if (char === '\\n') {\n      // Standalone LF\n      lines.push(currentLine);\n      currentLine = '';\n    } else if (char === '\\r') {\n      lines.push(currentLine);\n      currentLine = '';\n      if (chunk[i] === '\\n') {\n        i++; // CRLF case: Skip the LF character\n      }\n    } else {\n      currentLine += char;\n    }\n  }\n\n  return { lines, incompleteLine: currentLine };\n}\n","/**\nExtracts the headers from a response object and returns them as a key-value object.\n\n@param response - The response object to extract headers from.\n@returns The headers as a key-value object.\n*/\nexport function extractResponseHeaders(\n  response: Response,\n): Record<string, string> {\n  const headers: Record<string, string> = {};\n  response.headers.forEach((value, key) => {\n    headers[key] = value;\n  });\n  return headers;\n}\n","import { InvalidArgumentError } from '@ai-sdk/provider';\nimport { customAlphabet } from 'nanoid/non-secure';\n\n/**\nCreates an ID generator.\nThe total length of the ID is the sum of the prefix, separator, and random part length.\nNon-secure.\n\n@param alphabet - The alphabet to use for the ID. Default: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.\n@param prefix - The prefix of the ID to generate. Default: ''.\n@param separator - The separator between the prefix and the random part of the ID. Default: '-'.\n@param size - The size of the random part of the ID to generate. Default: 16.\n */\n// TODO 5.0 breaking change: change the return type to IDGenerator\nexport const createIdGenerator = ({\n  prefix,\n  size: defaultSize = 16,\n  alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n  separator = '-',\n}: {\n  prefix?: string;\n  separator?: string;\n  size?: number;\n  alphabet?: string;\n} = {}): ((size?: number) => string) => {\n  const generator = customAlphabet(alphabet, defaultSize);\n\n  if (prefix == null) {\n    return generator;\n  }\n\n  // check that the prefix is not part of the alphabet (otherwise prefix checking can fail randomly)\n  if (alphabet.includes(separator)) {\n    throw new InvalidArgumentError({\n      argument: 'separator',\n      message: `The separator \"${separator}\" must not be part of the alphabet \"${alphabet}\".`,\n    });\n  }\n\n  return size => `${prefix}${separator}${generator(size)}`;\n};\n\n/**\nA function that generates an ID.\n */\nexport type IDGenerator = () => string;\n\n/**\nGenerates a 16-character random string to use for IDs. Not secure.\n\n@param size - The size of the ID to generate. Default: 16.\n */\nexport const generateId = createIdGenerator();\n","export function getErrorMessage(error: unknown | undefined) {\n  if (error == null) {\n    return 'unknown error';\n  }\n\n  if (typeof error === 'string') {\n    return error;\n  }\n\n  if (error instanceof Error) {\n    return error.message;\n  }\n\n  return JSON.stringify(error);\n}\n","import { APICallError } from '@ai-sdk/provider';\nimport { FetchFunction } from './fetch-function';\nimport { removeUndefinedEntries } from './remove-undefined-entries';\nimport { ResponseHandler } from './response-handler';\nimport { isAbortError } from './is-abort-error';\nimport { extractResponseHeaders } from './extract-response-headers';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => globalThis.fetch;\n\nexport const getFromApi = async <T>({\n  url,\n  headers = {},\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch(),\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  failedResponseHandler: ResponseHandler<Error>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: 'GET',\n      headers: removeUndefinedEntries(headers),\n      signal: abortSignal,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.ok) {\n      let errorInformation: {\n        value: Error;\n        responseHeaders?: Record<string, string> | undefined;\n      };\n\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: {},\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n\n        throw new APICallError({\n          message: 'Failed to process error response',\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: {},\n        });\n      }\n\n      throw errorInformation.value;\n    }\n\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: {},\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n\n      throw new APICallError({\n        message: 'Failed to process successful response',\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: {},\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n\n    if (error instanceof TypeError && error.message === 'fetch failed') {\n      const cause = (error as any).cause;\n      if (cause != null) {\n        throw new APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          isRetryable: true,\n          requestBodyValues: {},\n        });\n      }\n    }\n\n    throw error;\n  }\n};\n","/**\n * Removes entries from a record where the value is null or undefined.\n * @param record - The input object whose entries may be null or undefined.\n * @returns A new object containing only entries with non-null and non-undefined values.\n */\nexport function removeUndefinedEntries<T>(\n  record: Record<string, T | undefined>,\n): Record<string, T> {\n  return Object.fromEntries(\n    Object.entries(record).filter(([_key, value]) => value != null),\n  ) as Record<string, T>;\n}\n","export function isAbortError(error: unknown): error is Error {\n  return (\n    error instanceof Error &&\n    (error.name === 'AbortError' || error.name === 'TimeoutError')\n  );\n}\n","import { LoadAPIKeyError } from '@ai-sdk/provider';\n\nexport function loadApiKey({\n  apiKey,\n  environmentVariableName,\n  apiKeyParameterName = 'apiKey',\n  description,\n}: {\n  apiKey: string | undefined;\n  environmentVariableName: string;\n  apiKeyParameterName?: string;\n  description: string;\n}): string {\n  if (typeof apiKey === 'string') {\n    return apiKey;\n  }\n\n  if (apiKey != null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string.`,\n    });\n  }\n\n  if (typeof process === 'undefined') {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`,\n    });\n  }\n\n  apiKey = process.env[environmentVariableName];\n\n  if (apiKey == null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`,\n    });\n  }\n\n  if (typeof apiKey !== 'string') {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`,\n    });\n  }\n\n  return apiKey;\n}\n","/**\n * Loads an optional `string` setting from the environment or a parameter.\n *\n * @param settingValue - The setting value.\n * @param environmentVariableName - The environment variable name.\n * @returns The setting value.\n */\nexport function loadOptionalSetting({\n  settingValue,\n  environmentVariableName,\n}: {\n  settingValue: string | undefined;\n  environmentVariableName: string;\n}): string | undefined {\n  if (typeof settingValue === 'string') {\n    return settingValue;\n  }\n\n  if (settingValue != null || typeof process === 'undefined') {\n    return undefined;\n  }\n\n  settingValue = process.env[environmentVariableName];\n\n  if (settingValue == null || typeof settingValue !== 'string') {\n    return undefined;\n  }\n\n  return settingValue;\n}\n","import { LoadSettingError } from '@ai-sdk/provider';\n\n/**\n * Loads a `string` setting from the environment or a parameter.\n *\n * @param settingValue - The setting value.\n * @param environmentVariableName - The environment variable name.\n * @param settingName - The setting name.\n * @param description - The description of the setting.\n * @returns The setting value.\n */\nexport function loadSetting({\n  settingValue,\n  environmentVariableName,\n  settingName,\n  description,\n}: {\n  settingValue: string | undefined;\n  environmentVariableName: string;\n  settingName: string;\n  description: string;\n}): string {\n  if (typeof settingValue === 'string') {\n    return settingValue;\n  }\n\n  if (settingValue != null) {\n    throw new LoadSettingError({\n      message: `${description} setting must be a string.`,\n    });\n  }\n\n  if (typeof process === 'undefined') {\n    throw new LoadSettingError({\n      message:\n        `${description} setting is missing. ` +\n        `Pass it using the '${settingName}' parameter. ` +\n        `Environment variables is not supported in this environment.`,\n    });\n  }\n\n  settingValue = process.env[environmentVariableName];\n\n  if (settingValue == null) {\n    throw new LoadSettingError({\n      message:\n        `${description} setting is missing. ` +\n        `Pass it using the '${settingName}' parameter ` +\n        `or the ${environmentVariableName} environment variable.`,\n    });\n  }\n\n  if (typeof settingValue !== 'string') {\n    throw new LoadSettingError({\n      message:\n        `${description} setting must be a string. ` +\n        `The value of the ${environmentVariableName} environment variable is not a string.`,\n    });\n  }\n\n  return settingValue;\n}\n","import {\n  JSONParseError,\n  JSONValue,\n  TypeValidationError,\n} from '@ai-sdk/provider';\nimport SecureJSON from 'secure-json-parse';\nimport { ZodSchema } from 'zod';\nimport { safeValidateTypes, validateTypes } from './validate-types';\nimport { Validator } from './validator';\n\n/**\n * Parses a JSON string into an unknown object.\n *\n * @param text - The JSON string to parse.\n * @returns {JSONValue} - The parsed JSON object.\n */\nexport function parseJSON(options: {\n  text: string;\n  schema?: undefined;\n}): JSONValue;\n/**\n * Parses a JSON string into a strongly-typed object using the provided schema.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Validator<T>} schema - The schema to use for parsing the JSON.\n * @returns {T} - The parsed object.\n */\nexport function parseJSON<T>(options: {\n  text: string;\n  schema: ZodSchema<T> | Validator<T>;\n}): T;\nexport function parseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: ZodSchema<T> | Validator<T>;\n}): T {\n  try {\n    const value = SecureJSON.parse(text);\n\n    if (schema == null) {\n      return value;\n    }\n\n    return validateTypes({ value, schema });\n  } catch (error) {\n    if (\n      JSONParseError.isInstance(error) ||\n      TypeValidationError.isInstance(error)\n    ) {\n      throw error;\n    }\n\n    throw new JSONParseError({ text, cause: error });\n  }\n}\n\nexport type ParseResult<T> =\n  | { success: true; value: T; rawValue: unknown }\n  | { success: false; error: JSONParseError | TypeValidationError };\n\n/**\n * Safely parses a JSON string and returns the result as an object of type `unknown`.\n *\n * @param text - The JSON string to parse.\n * @returns {object} Either an object with `success: true` and the parsed data, or an object with `success: false` and the error that occurred.\n */\nexport function safeParseJSON(options: {\n  text: string;\n  schema?: undefined;\n}): ParseResult<JSONValue>;\n/**\n * Safely parses a JSON string into a strongly-typed object, using a provided schema to validate the object.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Validator<T>} schema - The schema to use for parsing the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport function safeParseJSON<T>(options: {\n  text: string;\n  schema: ZodSchema<T> | Validator<T>;\n}): ParseResult<T>;\nexport function safeParseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: ZodSchema<T> | Validator<T>;\n}): ParseResult<T> {\n  try {\n    const value = SecureJSON.parse(text);\n\n    if (schema == null) {\n      return { success: true, value: value as T, rawValue: value };\n    }\n\n    const validationResult = safeValidateTypes({ value, schema });\n\n    return validationResult.success\n      ? { ...validationResult, rawValue: value }\n      : validationResult;\n  } catch (error) {\n    return {\n      success: false,\n      error: JSONParseError.isInstance(error)\n        ? error\n        : new JSONParseError({ text, cause: error }),\n    };\n  }\n}\n\nexport function isParsableJson(input: string): boolean {\n  try {\n    SecureJSON.parse(input);\n    return true;\n  } catch {\n    return false;\n  }\n}\n","import { TypeValidationError } from '@ai-sdk/provider';\nimport { z } from 'zod';\nimport { Validator, asValidator } from './validator';\n\n/**\n * Validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The object to validate.\n * @param {Validator<T>} options.schema - The schema to use for validating the JSON.\n * @returns {T} - The typed object.\n */\nexport function validateTypes<T>({\n  value,\n  schema: inputSchema,\n}: {\n  value: unknown;\n  schema: z.Schema<T, z.ZodTypeDef, any> | Validator<T>;\n}): T {\n  const result = safeValidateTypes({ value, schema: inputSchema });\n\n  if (!result.success) {\n    throw TypeValidationError.wrap({ value, cause: result.error });\n  }\n\n  return result.value;\n}\n\n/**\n * Safely validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The JSON object to validate.\n * @param {Validator<T>} options.schema - The schema to use for validating the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport function safeValidateTypes<T>({\n  value,\n  schema,\n}: {\n  value: unknown;\n  schema: z.Schema<T, z.ZodTypeDef, any> | Validator<T>;\n}):\n  | { success: true; value: T }\n  | { success: false; error: TypeValidationError } {\n  const validator = asValidator(schema);\n\n  try {\n    if (validator.validate == null) {\n      return { success: true, value: value as T };\n    }\n\n    const result = validator.validate(value);\n\n    if (result.success) {\n      return result;\n    }\n\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: result.error }),\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: error }),\n    };\n  }\n}\n","import { z } from 'zod';\n\n/**\n * Used to mark validator functions so we can support both Zod and custom schemas.\n */\nexport const validatorSymbol = Symbol.for('vercel.ai.validator');\n\nexport type ValidationResult<OBJECT> =\n  | { success: true; value: OBJECT }\n  | { success: false; error: Error };\n\nexport type Validator<OBJECT = unknown> = {\n  /**\n   * Used to mark validator functions so we can support both Zod and custom schemas.\n   */\n  [validatorSymbol]: true;\n\n  /**\n   * Optional. Validates that the structure of a value matches this schema,\n   * and returns a typed version of the value if it does.\n   */\n  readonly validate?: (value: unknown) => ValidationResult<OBJECT>;\n};\n\n/**\n * Create a validator.\n *\n * @param validate A validation function for the schema.\n */\nexport function validator<OBJECT>(\n  validate?: undefined | ((value: unknown) => ValidationResult<OBJECT>),\n): Validator<OBJECT> {\n  return { [validatorSymbol]: true, validate };\n}\n\nexport function isValidator(value: unknown): value is Validator {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    validatorSymbol in value &&\n    value[validatorSymbol] === true &&\n    'validate' in value\n  );\n}\n\nexport function asValidator<OBJECT>(\n  value: Validator<OBJECT> | z.Schema<OBJECT, z.ZodTypeDef, any>,\n): Validator<OBJECT> {\n  return isValidator(value) ? value : zodValidator(value);\n}\n\nexport function zodValidator<OBJECT>(\n  zodSchema: z.Schema<OBJECT, z.ZodTypeDef, any>,\n): Validator<OBJECT> {\n  return validator(value => {\n    const result = zodSchema.safeParse(value);\n    return result.success\n      ? { success: true, value: result.data }\n      : { success: false, error: result.error };\n  });\n}\n","import { InvalidArgumentError } from '@ai-sdk/provider';\nimport { safeValidateTypes } from './validate-types';\nimport { z } from 'zod';\n\nexport function parseProviderOptions<T>({\n  provider,\n  providerOptions,\n  schema,\n}: {\n  provider: string;\n  providerOptions: Record<string, unknown> | undefined;\n  schema: z.ZodSchema<T>;\n}): T | undefined {\n  if (providerOptions?.[provider] == null) {\n    return undefined;\n  }\n\n  const parsedProviderOptions = safeValidateTypes({\n    value: providerOptions[provider],\n    schema,\n  });\n\n  if (!parsedProviderOptions.success) {\n    throw new InvalidArgumentError({\n      argument: 'providerOptions',\n      message: `invalid ${provider} provider options`,\n      cause: parsedProviderOptions.error,\n    });\n  }\n\n  return parsedProviderOptions.value;\n}\n","import { APICallError } from '@ai-sdk/provider';\nimport { extractResponseHeaders } from './extract-response-headers';\nimport { FetchFunction } from './fetch-function';\nimport { isAbortError } from './is-abort-error';\nimport { removeUndefinedEntries } from './remove-undefined-entries';\nimport { ResponseHandler } from './response-handler';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => globalThis.fetch;\n\nexport const postJsonToApi = async <T>({\n  url,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch,\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  body: unknown;\n  failedResponseHandler: ResponseHandler<APICallError>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) =>\n  postToApi({\n    url,\n    headers: {\n      'Content-Type': 'application/json',\n      ...headers,\n    },\n    body: {\n      content: JSON.stringify(body),\n      values: body,\n    },\n    failedResponseHandler,\n    successfulResponseHandler,\n    abortSignal,\n    fetch,\n  });\n\nexport const postFormDataToApi = async <T>({\n  url,\n  headers,\n  formData,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch,\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  formData: FormData;\n  failedResponseHandler: ResponseHandler<APICallError>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) =>\n  postToApi({\n    url,\n    headers,\n    body: {\n      content: formData,\n      values: Object.fromEntries((formData as any).entries()),\n    },\n    failedResponseHandler,\n    successfulResponseHandler,\n    abortSignal,\n    fetch,\n  });\n\nexport const postToApi = async <T>({\n  url,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch(),\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  body: {\n    content: string | FormData | Uint8Array;\n    values: unknown;\n  };\n  failedResponseHandler: ResponseHandler<Error>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: removeUndefinedEntries(headers),\n      body: body.content,\n      signal: abortSignal,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.ok) {\n      let errorInformation: {\n        value: Error;\n        responseHeaders?: Record<string, string> | undefined;\n      };\n\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: body.values,\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n\n        throw new APICallError({\n          message: 'Failed to process error response',\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: body.values,\n        });\n      }\n\n      throw errorInformation.value;\n    }\n\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: body.values,\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n\n      throw new APICallError({\n        message: 'Failed to process successful response',\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: body.values,\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n\n    // unwrap original error when fetch failed (for easier debugging):\n    if (error instanceof TypeError && error.message === 'fetch failed') {\n      const cause = (error as any).cause;\n\n      if (cause != null) {\n        // Failed to connect to server:\n        throw new APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          requestBodyValues: body.values,\n          isRetryable: true, // retry when network error\n        });\n      }\n    }\n\n    throw error;\n  }\n};\n","export type Resolvable<T> =\n  | T // Raw value\n  | Promise<T> // Promise of value\n  | (() => T) // Function returning value\n  | (() => Promise<T>); // Function returning promise of value\n\n/**\n * Resolves a value that could be a raw value, a Promise, a function returning a value,\n * or a function returning a Promise.\n */\nexport async function resolve<T>(value: Resolvable<T>): Promise<T> {\n  // If it's a function, call it to get the value/promise\n  if (typeof value === 'function') {\n    value = (value as Function)();\n  }\n\n  // Otherwise just resolve whatever we got (value or promise)\n  return Promise.resolve(value as T);\n}\n","import { APICallError, EmptyResponseBodyError } from '@ai-sdk/provider';\nimport { ZodSchema } from 'zod';\nimport {\n  createEventSourceParserStream,\n  EventSourceChunk,\n} from './event-source-parser-stream';\nimport { extractResponseHeaders } from './extract-response-headers';\nimport { parseJSON, ParseResult, safeParseJSON } from './parse-json';\n\nexport type ResponseHandler<RETURN_TYPE> = (options: {\n  url: string;\n  requestBodyValues: unknown;\n  response: Response;\n}) => PromiseLike<{\n  value: RETURN_TYPE;\n  rawValue?: unknown;\n  responseHeaders?: Record<string, string>;\n}>;\n\nexport const createJsonErrorResponseHandler =\n  <T>({\n    errorSchema,\n    errorToMessage,\n    isRetryable,\n  }: {\n    errorSchema: ZodSchema<T>;\n    errorToMessage: (error: T) => string;\n    isRetryable?: (response: Response, error?: T) => boolean;\n  }): ResponseHandler<APICallError> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseBody = await response.text();\n    const responseHeaders = extractResponseHeaders(response);\n\n    // Some providers return an empty response body for some errors:\n    if (responseBody.trim() === '') {\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: response.statusText,\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          isRetryable: isRetryable?.(response),\n        }),\n      };\n    }\n\n    // resilient parsing in case the response is not JSON or does not match the schema:\n    try {\n      const parsedError = parseJSON({\n        text: responseBody,\n        schema: errorSchema,\n      });\n\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: errorToMessage(parsedError),\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          data: parsedError,\n          isRetryable: isRetryable?.(response, parsedError),\n        }),\n      };\n    } catch (parseError) {\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: response.statusText,\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          isRetryable: isRetryable?.(response),\n        }),\n      };\n    }\n  };\n\nexport const createEventSourceResponseHandler =\n  <T>(\n    chunkSchema: ZodSchema<T>,\n  ): ResponseHandler<ReadableStream<ParseResult<T>>> =>\n  async ({ response }: { response: Response }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (response.body == null) {\n      throw new EmptyResponseBodyError({});\n    }\n\n    return {\n      responseHeaders,\n      value: response.body\n        .pipeThrough(new TextDecoderStream())\n        .pipeThrough(createEventSourceParserStream())\n        .pipeThrough(\n          new TransformStream<EventSourceChunk, ParseResult<T>>({\n            transform({ data }, controller) {\n              // ignore the 'DONE' event that e.g. OpenAI sends:\n              if (data === '[DONE]') {\n                return;\n              }\n\n              controller.enqueue(\n                safeParseJSON({\n                  text: data,\n                  schema: chunkSchema,\n                }),\n              );\n            },\n          }),\n        ),\n    };\n  };\n\nexport const createJsonStreamResponseHandler =\n  <T>(\n    chunkSchema: ZodSchema<T>,\n  ): ResponseHandler<ReadableStream<ParseResult<T>>> =>\n  async ({ response }: { response: Response }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (response.body == null) {\n      throw new EmptyResponseBodyError({});\n    }\n\n    let buffer = '';\n\n    return {\n      responseHeaders,\n      value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(\n        new TransformStream<string, ParseResult<T>>({\n          transform(chunkText, controller) {\n            if (chunkText.endsWith('\\n')) {\n              controller.enqueue(\n                safeParseJSON({\n                  text: buffer + chunkText,\n                  schema: chunkSchema,\n                }),\n              );\n              buffer = '';\n            } else {\n              buffer += chunkText;\n            }\n          },\n        }),\n      ),\n    };\n  };\n\nexport const createJsonResponseHandler =\n  <T>(responseSchema: ZodSchema<T>): ResponseHandler<T> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseBody = await response.text();\n\n    const parsedResult = safeParseJSON({\n      text: responseBody,\n      schema: responseSchema,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!parsedResult.success) {\n      throw new APICallError({\n        message: 'Invalid JSON response',\n        cause: parsedResult.error,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        url,\n        requestBodyValues,\n      });\n    }\n\n    return {\n      responseHeaders,\n      value: parsedResult.value,\n      rawValue: parsedResult.rawValue,\n    };\n  };\n\nexport const createBinaryResponseHandler =\n  (): ResponseHandler<Uint8Array> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.body) {\n      throw new APICallError({\n        message: 'Response body is empty',\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody: undefined,\n      });\n    }\n\n    try {\n      const buffer = await response.arrayBuffer();\n      return {\n        responseHeaders,\n        value: new Uint8Array(buffer),\n      };\n    } catch (error) {\n      throw new APICallError({\n        message: 'Failed to read response as array buffer',\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody: undefined,\n        cause: error,\n      });\n    }\n  };\n\nexport const createStatusCodeErrorResponseHandler =\n  (): ResponseHandler<APICallError> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseHeaders = extractResponseHeaders(response);\n    const responseBody = await response.text();\n\n    return {\n      responseHeaders,\n      value: new APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues: requestBodyValues as Record<string, unknown>,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n      }),\n    };\n  };\n","// btoa and atob need to be invoked as a function call, not as a method call.\n// Otherwise CloudFlare will throw a\n// \"TypeError: Illegal invocation: function called with incorrect this reference\"\nconst { btoa, atob } = globalThis;\n\nexport function convertBase64ToUint8Array(base64String: string) {\n  const base64Url = base64String.replace(/-/g, '+').replace(/_/g, '/');\n  const latin1string = atob(base64Url);\n  return Uint8Array.from(latin1string, byte => byte.codePointAt(0)!);\n}\n\nexport function convertUint8ArrayToBase64(array: Uint8Array): string {\n  let latin1string = '';\n\n  // Note: regular for loop to support older JavaScript versions that\n  // do not support for..of on Uint8Array\n  for (let i = 0; i < array.length; i++) {\n    latin1string += String.fromCodePoint(array[i]);\n  }\n\n  return btoa(latin1string);\n}\n","export function withoutTrailingSlash(url: string | undefined) {\n  return url?.replace(/\\/$/, '');\n}\n","import {\n  FetchFunction,\n  generateId,\n  loadApiKey,\n  withoutTrailingSlash,\n} from '@ai-sdk/provider-utils';\nimport { GoogleGenerativeAILanguageModel } from './google-generative-ai-language-model';\nimport {\n  GoogleGenerativeAIModelId,\n  GoogleGenerativeAISettings,\n} from './google-generative-ai-settings';\nimport { GoogleGenerativeAIEmbeddingModel } from './google-generative-ai-embedding-model';\nimport {\n  GoogleGenerativeAIEmbeddingModelId,\n  GoogleGenerativeAIEmbeddingSettings,\n} from './google-generative-ai-embedding-settings';\nimport {\n  EmbeddingModelV1,\n  LanguageModelV1,\n  ProviderV1,\n} from '@ai-sdk/provider';\nimport { isSupportedFileUrl } from './google-supported-file-url';\n\nexport interface GoogleGenerativeAIProvider extends ProviderV1 {\n  (\n    modelId: GoogleGenerativeAIModelId,\n    settings?: GoogleGenerativeAISettings,\n  ): LanguageModelV1;\n\n  languageModel(\n    modelId: GoogleGenerativeAIModelId,\n    settings?: GoogleGenerativeAISettings,\n  ): LanguageModelV1;\n\n  chat(\n    modelId: GoogleGenerativeAIModelId,\n    settings?: GoogleGenerativeAISettings,\n  ): LanguageModelV1;\n\n  /**\n   * @deprecated Use `chat()` instead.\n   */\n  generativeAI(\n    modelId: GoogleGenerativeAIModelId,\n    settings?: GoogleGenerativeAISettings,\n  ): LanguageModelV1;\n\n  /**\n@deprecated Use `textEmbeddingModel()` instead.\n   */\n  embedding(\n    modelId: GoogleGenerativeAIEmbeddingModelId,\n    settings?: GoogleGenerativeAIEmbeddingSettings,\n  ): EmbeddingModelV1<string>;\n\n  /**\n@deprecated Use `textEmbeddingModel()` instead.\n */\n  textEmbedding(\n    modelId: GoogleGenerativeAIEmbeddingModelId,\n    settings?: GoogleGenerativeAIEmbeddingSettings,\n  ): EmbeddingModelV1<string>;\n\n  textEmbeddingModel(\n    modelId: GoogleGenerativeAIEmbeddingModelId,\n    settings?: GoogleGenerativeAIEmbeddingSettings,\n  ): EmbeddingModelV1<string>;\n}\n\nexport interface GoogleGenerativeAIProviderSettings {\n  /**\nUse a different URL prefix for API calls, e.g. to use proxy servers.\nThe default prefix is `https://generativelanguage.googleapis.com/v1beta`.\n   */\n  baseURL?: string;\n\n  /**\nAPI key that is being send using the `x-goog-api-key` header.\nIt defaults to the `GOOGLE_GENERATIVE_AI_API_KEY` environment variable.\n   */\n  apiKey?: string;\n\n  /**\nCustom headers to include in the requests.\n     */\n  headers?: Record<string, string | undefined>;\n\n  /**\nCustom fetch implementation. You can use it as a middleware to intercept requests,\nor to provide a custom fetch implementation for e.g. testing.\n    */\n  fetch?: FetchFunction;\n\n  /**\nOptional function to generate a unique ID for each request.\n     */\n  generateId?: () => string;\n}\n\n/**\nCreate a Google Generative AI provider instance.\n */\nexport function createGoogleGenerativeAI(\n  options: GoogleGenerativeAIProviderSettings = {},\n): GoogleGenerativeAIProvider {\n  const baseURL =\n    withoutTrailingSlash(options.baseURL) ??\n    'https://generativelanguage.googleapis.com/v1beta';\n\n  const getHeaders = () => ({\n    'x-goog-api-key': loadApiKey({\n      apiKey: options.apiKey,\n      environmentVariableName: 'GOOGLE_GENERATIVE_AI_API_KEY',\n      description: 'Google Generative AI',\n    }),\n    ...options.headers,\n  });\n\n  const createChatModel = (\n    modelId: GoogleGenerativeAIModelId,\n    settings: GoogleGenerativeAISettings = {},\n  ) =>\n    new GoogleGenerativeAILanguageModel(modelId, settings, {\n      provider: 'google.generative-ai',\n      baseURL,\n      headers: getHeaders,\n      generateId: options.generateId ?? generateId,\n      isSupportedUrl: isSupportedFileUrl,\n      fetch: options.fetch,\n    });\n\n  const createEmbeddingModel = (\n    modelId: GoogleGenerativeAIEmbeddingModelId,\n    settings: GoogleGenerativeAIEmbeddingSettings = {},\n  ) =>\n    new GoogleGenerativeAIEmbeddingModel(modelId, settings, {\n      provider: 'google.generative-ai',\n      baseURL,\n      headers: getHeaders,\n      fetch: options.fetch,\n    });\n\n  const provider = function (\n    modelId: GoogleGenerativeAIModelId,\n    settings?: GoogleGenerativeAISettings,\n  ) {\n    if (new.target) {\n      throw new Error(\n        'The Google Generative AI model function cannot be called with the new keyword.',\n      );\n    }\n\n    return createChatModel(modelId, settings);\n  };\n\n  provider.languageModel = createChatModel;\n  provider.chat = createChatModel;\n  provider.generativeAI = createChatModel;\n  provider.embedding = createEmbeddingModel;\n  provider.textEmbedding = createEmbeddingModel;\n  provider.textEmbeddingModel = createEmbeddingModel;\n\n  return provider;\n}\n\n/**\nDefault Google Generative AI provider instance.\n */\nexport const google = createGoogleGenerativeAI();\n","import {\n  LanguageModelV1,\n  LanguageModelV1CallWarning,\n  LanguageModelV1FinishReason,\n  LanguageModelV1ProviderMetadata,\n  LanguageModelV1Source,\n  LanguageModelV1StreamPart,\n} from '@ai-sdk/provider';\nimport {\n  FetchFunction,\n  ParseResult,\n  Resolvable,\n  combineHeaders,\n  createEventSourceResponseHandler,\n  createJsonResponseHandler,\n  parseProviderOptions,\n  postJsonToApi,\n  resolve,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\nimport { convertJSONSchemaToOpenAPISchema } from './convert-json-schema-to-openapi-schema';\nimport { convertToGoogleGenerativeAIMessages } from './convert-to-google-generative-ai-messages';\nimport { getModelPath } from './get-model-path';\nimport { googleFailedResponseHandler } from './google-error';\nimport { GoogleGenerativeAIContentPart } from './google-generative-ai-prompt';\nimport {\n  GoogleGenerativeAIModelId,\n  InternalGoogleGenerativeAISettings,\n} from './google-generative-ai-settings';\nimport { prepareTools } from './google-prepare-tools';\nimport { mapGoogleGenerativeAIFinishReason } from './map-google-generative-ai-finish-reason';\n\ntype GoogleGenerativeAIConfig = {\n  provider: string;\n  baseURL: string;\n  headers: Resolvable<Record<string, string | undefined>>;\n  fetch?: FetchFunction;\n  generateId: () => string;\n  isSupportedUrl: (url: URL) => boolean;\n};\n\nexport class GoogleGenerativeAILanguageModel implements LanguageModelV1 {\n  readonly specificationVersion = 'v1';\n  readonly defaultObjectGenerationMode = 'json';\n  readonly supportsImageUrls = false;\n\n  get supportsStructuredOutputs() {\n    return this.settings.structuredOutputs ?? true;\n  }\n\n  readonly modelId: GoogleGenerativeAIModelId;\n  readonly settings: InternalGoogleGenerativeAISettings;\n\n  private readonly config: GoogleGenerativeAIConfig;\n\n  constructor(\n    modelId: GoogleGenerativeAIModelId,\n    settings: InternalGoogleGenerativeAISettings,\n    config: GoogleGenerativeAIConfig,\n  ) {\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n  }\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  private async getArgs({\n    mode,\n    prompt,\n    maxTokens,\n    temperature,\n    topP,\n    topK,\n    frequencyPenalty,\n    presencePenalty,\n    stopSequences,\n    responseFormat,\n    seed,\n    providerMetadata,\n  }: Parameters<LanguageModelV1['doGenerate']>[0]) {\n    const type = mode.type;\n\n    const warnings: LanguageModelV1CallWarning[] = [];\n\n    const googleOptions = parseProviderOptions({\n      provider: 'google',\n      providerOptions: providerMetadata,\n      schema: googleGenerativeAIProviderOptionsSchema,\n    });\n\n    // Add warning if includeThoughts is used with a non-Vertex Google provider\n    if (\n      googleOptions?.thinkingConfig?.includeThoughts === true &&\n      !this.config.provider.startsWith('google.vertex.')\n    ) {\n      warnings.push({\n        type: 'other',\n        message:\n          \"The 'includeThoughts' option is only supported with the Google Vertex provider \" +\n          'and might not be supported or could behave unexpectedly with the current Google provider ' +\n          `(${this.config.provider}).`,\n      });\n    }\n\n    const generationConfig = {\n      // standardized settings:\n      maxOutputTokens: maxTokens,\n      temperature,\n      topK,\n      topP,\n      frequencyPenalty,\n      presencePenalty,\n      stopSequences,\n      seed,\n\n      // response format:\n      responseMimeType:\n        responseFormat?.type === 'json' ? 'application/json' : undefined,\n      responseSchema:\n        responseFormat?.type === 'json' &&\n        responseFormat.schema != null &&\n        // Google GenAI does not support all OpenAPI Schema features,\n        // so this is needed as an escape hatch:\n        this.supportsStructuredOutputs\n          ? convertJSONSchemaToOpenAPISchema(responseFormat.schema)\n          : undefined,\n      ...(this.settings.audioTimestamp && {\n        audioTimestamp: this.settings.audioTimestamp,\n      }),\n\n      // provider options:\n      responseModalities: googleOptions?.responseModalities,\n      thinkingConfig: googleOptions?.thinkingConfig,\n    };\n\n    const { contents, systemInstruction } =\n      convertToGoogleGenerativeAIMessages(prompt);\n\n    switch (type) {\n      case 'regular': {\n        const { tools, toolConfig, toolWarnings } = prepareTools(\n          mode,\n          this.settings.useSearchGrounding ?? false,\n          this.settings.dynamicRetrievalConfig,\n          this.modelId,\n        );\n\n        return {\n          args: {\n            generationConfig,\n            contents,\n            systemInstruction,\n            safetySettings: this.settings.safetySettings,\n            tools,\n            toolConfig,\n            cachedContent: this.settings.cachedContent,\n          },\n          warnings: [...warnings, ...toolWarnings],\n        };\n      }\n\n      case 'object-json': {\n        return {\n          args: {\n            generationConfig: {\n              ...generationConfig,\n              responseMimeType: 'application/json',\n              responseSchema:\n                mode.schema != null &&\n                // Google GenAI does not support all OpenAPI Schema features,\n                // so this is needed as an escape hatch:\n                this.supportsStructuredOutputs\n                  ? convertJSONSchemaToOpenAPISchema(mode.schema)\n                  : undefined,\n            },\n            contents,\n            systemInstruction,\n            safetySettings: this.settings.safetySettings,\n            cachedContent: this.settings.cachedContent,\n          },\n          warnings,\n        };\n      }\n\n      case 'object-tool': {\n        return {\n          args: {\n            generationConfig,\n            contents,\n            systemInstruction,\n            tools: {\n              functionDeclarations: [\n                {\n                  name: mode.tool.name,\n                  description: mode.tool.description ?? '',\n                  parameters: convertJSONSchemaToOpenAPISchema(\n                    mode.tool.parameters,\n                  ),\n                },\n              ],\n            },\n            toolConfig: { functionCallingConfig: { mode: 'ANY' } },\n            safetySettings: this.settings.safetySettings,\n            cachedContent: this.settings.cachedContent,\n          },\n          warnings,\n        };\n      }\n\n      default: {\n        const _exhaustiveCheck: never = type;\n        throw new Error(`Unsupported type: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  supportsUrl(url: URL): boolean {\n    return this.config.isSupportedUrl(url);\n  }\n\n  async doGenerate(\n    options: Parameters<LanguageModelV1['doGenerate']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV1['doGenerate']>>> {\n    const { args, warnings } = await this.getArgs(options);\n    const body = JSON.stringify(args);\n\n    const mergedHeaders = combineHeaders(\n      await resolve(this.config.headers),\n      options.headers,\n    );\n\n    const {\n      responseHeaders,\n      value: response,\n      rawValue: rawResponse,\n    } = await postJsonToApi({\n      url: `${this.config.baseURL}/${getModelPath(\n        this.modelId,\n      )}:generateContent`,\n      headers: mergedHeaders,\n      body: args,\n      failedResponseHandler: googleFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(responseSchema),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const { contents: rawPrompt, ...rawSettings } = args;\n    const candidate = response.candidates[0];\n\n    const parts =\n      candidate.content == null ||\n      typeof candidate.content !== 'object' ||\n      !('parts' in candidate.content)\n        ? []\n        : candidate.content.parts;\n\n    const toolCalls = getToolCallsFromParts({\n      parts: parts, // Use candidateParts\n      generateId: this.config.generateId,\n    });\n\n    const usageMetadata = response.usageMetadata;\n\n    return {\n      text: getTextFromParts(parts),\n      reasoning: getReasoningDetailsFromParts(parts),\n      files: getInlineDataParts(parts)?.map(part => ({\n        data: part.inlineData.data,\n        mimeType: part.inlineData.mimeType,\n      })),\n      toolCalls,\n      finishReason: mapGoogleGenerativeAIFinishReason({\n        finishReason: candidate.finishReason,\n        hasToolCalls: toolCalls != null && toolCalls.length > 0,\n      }),\n      usage: {\n        promptTokens: usageMetadata?.promptTokenCount ?? NaN,\n        completionTokens: usageMetadata?.candidatesTokenCount ?? NaN,\n      },\n      rawCall: { rawPrompt, rawSettings },\n      rawResponse: { headers: responseHeaders, body: rawResponse },\n      warnings,\n      providerMetadata: {\n        google: {\n          groundingMetadata: candidate.groundingMetadata ?? null,\n          safetyRatings: candidate.safetyRatings ?? null,\n        },\n      },\n      sources: extractSources({\n        groundingMetadata: candidate.groundingMetadata,\n        generateId: this.config.generateId,\n      }),\n      request: { body },\n    };\n  }\n\n  async doStream(\n    options: Parameters<LanguageModelV1['doStream']>[0],\n  ): Promise<Awaited<ReturnType<LanguageModelV1['doStream']>>> {\n    const { args, warnings } = await this.getArgs(options);\n\n    const body = JSON.stringify(args);\n    const headers = combineHeaders(\n      await resolve(this.config.headers),\n      options.headers,\n    );\n\n    const { responseHeaders, value: response } = await postJsonToApi({\n      url: `${this.config.baseURL}/${getModelPath(\n        this.modelId,\n      )}:streamGenerateContent?alt=sse`,\n      headers,\n      body: args,\n      failedResponseHandler: googleFailedResponseHandler,\n      successfulResponseHandler: createEventSourceResponseHandler(chunkSchema),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const { contents: rawPrompt, ...rawSettings } = args;\n\n    let finishReason: LanguageModelV1FinishReason = 'unknown';\n    let usage: { promptTokens: number; completionTokens: number } = {\n      promptTokens: Number.NaN,\n      completionTokens: Number.NaN,\n    };\n    let providerMetadata: LanguageModelV1ProviderMetadata | undefined =\n      undefined;\n\n    const generateId = this.config.generateId;\n    let hasToolCalls = false;\n\n    return {\n      stream: response.pipeThrough(\n        new TransformStream<\n          ParseResult<z.infer<typeof chunkSchema>>,\n          LanguageModelV1StreamPart\n        >({\n          transform(chunk, controller) {\n            if (!chunk.success) {\n              controller.enqueue({ type: 'error', error: chunk.error });\n              return;\n            }\n\n            const value = chunk.value;\n\n            const usageMetadata = value.usageMetadata;\n\n            if (usageMetadata != null) {\n              usage = {\n                promptTokens: usageMetadata.promptTokenCount ?? NaN,\n                completionTokens: usageMetadata.candidatesTokenCount ?? NaN,\n              };\n            }\n\n            const candidate = value.candidates?.[0];\n\n            // sometimes the API returns an empty candidates array\n            if (candidate == null) {\n              return;\n            }\n\n            const content = candidate.content;\n\n            // Process tool call's parts before determining finishReason to ensure hasToolCalls is properly set\n            if (content != null) {\n              const deltaText = getTextFromParts(content.parts);\n              if (deltaText != null) {\n                controller.enqueue({\n                  type: 'text-delta',\n                  textDelta: deltaText,\n                });\n              }\n\n              const reasoningDeltaText = getReasoningDetailsFromParts(\n                content.parts,\n              );\n              if (reasoningDeltaText != null) {\n                for (const part of reasoningDeltaText) {\n                  controller.enqueue({\n                    type: 'reasoning',\n                    textDelta: part.text,\n                  });\n                }\n              }\n\n              const inlineDataParts = getInlineDataParts(content.parts);\n              if (inlineDataParts != null) {\n                for (const part of inlineDataParts) {\n                  controller.enqueue({\n                    type: 'file',\n                    mimeType: part.inlineData.mimeType,\n                    data: part.inlineData.data,\n                  });\n                }\n              }\n\n              const toolCallDeltas = getToolCallsFromParts({\n                parts: content.parts,\n                generateId,\n              });\n\n              if (toolCallDeltas != null) {\n                for (const toolCall of toolCallDeltas) {\n                  controller.enqueue({\n                    type: 'tool-call-delta',\n                    toolCallType: 'function',\n                    toolCallId: toolCall.toolCallId,\n                    toolName: toolCall.toolName,\n                    argsTextDelta: toolCall.args,\n                  });\n\n                  controller.enqueue({\n                    type: 'tool-call',\n                    toolCallType: 'function',\n                    toolCallId: toolCall.toolCallId,\n                    toolName: toolCall.toolName,\n                    args: toolCall.args,\n                  });\n\n                  hasToolCalls = true;\n                }\n              }\n            }\n\n            if (candidate.finishReason != null) {\n              finishReason = mapGoogleGenerativeAIFinishReason({\n                finishReason: candidate.finishReason,\n                hasToolCalls,\n              });\n\n              const sources =\n                extractSources({\n                  groundingMetadata: candidate.groundingMetadata,\n                  generateId,\n                }) ?? [];\n\n              for (const source of sources) {\n                controller.enqueue({ type: 'source', source });\n              }\n\n              providerMetadata = {\n                google: {\n                  groundingMetadata: candidate.groundingMetadata ?? null,\n                  safetyRatings: candidate.safetyRatings ?? null,\n                },\n              };\n            }\n          },\n\n          flush(controller) {\n            controller.enqueue({\n              type: 'finish',\n              finishReason,\n              usage,\n              providerMetadata,\n            });\n          },\n        }),\n      ),\n      rawCall: { rawPrompt, rawSettings },\n      rawResponse: { headers: responseHeaders },\n      warnings,\n      request: { body },\n    };\n  }\n}\n\nfunction getToolCallsFromParts({\n  parts,\n  generateId,\n}: {\n  parts: z.infer<typeof contentSchema>['parts'];\n  generateId: () => string;\n}) {\n  const functionCallParts = parts?.filter(\n    part => 'functionCall' in part,\n  ) as Array<\n    GoogleGenerativeAIContentPart & {\n      functionCall: { name: string; args: unknown };\n    }\n  >;\n\n  return functionCallParts == null || functionCallParts.length === 0\n    ? undefined\n    : functionCallParts.map(part => ({\n        toolCallType: 'function' as const,\n        toolCallId: generateId(),\n        toolName: part.functionCall.name,\n        args: JSON.stringify(part.functionCall.args),\n      }));\n}\n\nfunction getTextFromParts(parts: z.infer<typeof contentSchema>['parts']) {\n  const textParts = parts?.filter(\n    part => 'text' in part && (part as any).thought !== true, // Exclude thought parts\n  ) as Array<GoogleGenerativeAIContentPart & { text: string }>;\n\n  return textParts == null || textParts.length === 0\n    ? undefined\n    : textParts.map(part => part.text).join('');\n}\n\nfunction getReasoningDetailsFromParts(\n  parts: z.infer<typeof contentSchema>['parts'],\n): Array<{ type: 'text'; text: string }> | undefined {\n  const reasoningParts = parts?.filter(\n    part =>\n      'text' in part && (part as any).thought === true && part.text != null,\n  ) as Array<\n    GoogleGenerativeAIContentPart & { text: string; thought?: boolean }\n  >;\n\n  return reasoningParts == null || reasoningParts.length === 0\n    ? undefined\n    : reasoningParts.map(part => ({ type: 'text', text: part.text }));\n}\n\nfunction getInlineDataParts(parts: z.infer<typeof contentSchema>['parts']) {\n  return parts?.filter(\n    (\n      part,\n    ): part is {\n      inlineData: { mimeType: string; data: string };\n    } => 'inlineData' in part,\n  );\n}\n\nfunction extractSources({\n  groundingMetadata,\n  generateId,\n}: {\n  groundingMetadata: z.infer<typeof groundingMetadataSchema> | undefined | null;\n  generateId: () => string;\n}): undefined | LanguageModelV1Source[] {\n  return groundingMetadata?.groundingChunks\n    ?.filter(\n      (\n        chunk,\n      ): chunk is z.infer<typeof groundingChunkSchema> & {\n        web: { uri: string; title?: string };\n      } => chunk.web != null,\n    )\n    .map(chunk => ({\n      sourceType: 'url',\n      id: generateId(),\n      url: chunk.web.uri,\n      title: chunk.web.title,\n    }));\n}\n\nconst contentSchema = z.object({\n  parts: z\n    .array(\n      z.union([\n        // note: order matters since text can be fully empty\n        z.object({\n          functionCall: z.object({\n            name: z.string(),\n            args: z.unknown(),\n          }),\n        }),\n        z.object({\n          inlineData: z.object({\n            mimeType: z.string(),\n            data: z.string(),\n          }),\n        }),\n        z.object({\n          text: z.string().nullish(),\n          thought: z.boolean().nullish(),\n        }),\n      ]),\n    )\n    .nullish(),\n});\n\n// https://ai.google.dev/gemini-api/docs/grounding\n// https://cloud.google.com/vertex-ai/generative-ai/docs/multimodal/ground-gemini#ground-to-search\nconst groundingChunkSchema = z.object({\n  web: z.object({ uri: z.string(), title: z.string() }).nullish(),\n  retrievedContext: z.object({ uri: z.string(), title: z.string() }).nullish(),\n});\n\nexport const groundingMetadataSchema = z.object({\n  webSearchQueries: z.array(z.string()).nullish(),\n  retrievalQueries: z.array(z.string()).nullish(),\n  searchEntryPoint: z.object({ renderedContent: z.string() }).nullish(),\n  groundingChunks: z.array(groundingChunkSchema).nullish(),\n  groundingSupports: z\n    .array(\n      z.object({\n        segment: z.object({\n          startIndex: z.number().nullish(),\n          endIndex: z.number().nullish(),\n          text: z.string().nullish(),\n        }),\n        segment_text: z.string().nullish(),\n        groundingChunkIndices: z.array(z.number()).nullish(),\n        supportChunkIndices: z.array(z.number()).nullish(),\n        confidenceScores: z.array(z.number()).nullish(),\n        confidenceScore: z.array(z.number()).nullish(),\n      }),\n    )\n    .nullish(),\n  retrievalMetadata: z\n    .union([\n      z.object({\n        webDynamicRetrievalScore: z.number(),\n      }),\n      z.object({}),\n    ])\n    .nullish(),\n});\n\n// https://cloud.google.com/vertex-ai/generative-ai/docs/multimodal/configure-safety-filters\nexport const safetyRatingSchema = z.object({\n  category: z.string().nullish(),\n  probability: z.string().nullish(),\n  probabilityScore: z.number().nullish(),\n  severity: z.string().nullish(),\n  severityScore: z.number().nullish(),\n  blocked: z.boolean().nullish(),\n});\n\nconst responseSchema = z.object({\n  candidates: z.array(\n    z.object({\n      content: contentSchema.nullish().or(z.object({}).strict()),\n      finishReason: z.string().nullish(),\n      safetyRatings: z.array(safetyRatingSchema).nullish(),\n      groundingMetadata: groundingMetadataSchema.nullish(),\n    }),\n  ),\n  usageMetadata: z\n    .object({\n      promptTokenCount: z.number().nullish(),\n      candidatesTokenCount: z.number().nullish(),\n      totalTokenCount: z.number().nullish(),\n    })\n    .nullish(),\n});\n\n// limited version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst chunkSchema = z.object({\n  candidates: z\n    .array(\n      z.object({\n        content: contentSchema.nullish(),\n        finishReason: z.string().nullish(),\n        safetyRatings: z.array(safetyRatingSchema).nullish(),\n        groundingMetadata: groundingMetadataSchema.nullish(),\n      }),\n    )\n    .nullish(),\n  usageMetadata: z\n    .object({\n      promptTokenCount: z.number().nullish(),\n      candidatesTokenCount: z.number().nullish(),\n      totalTokenCount: z.number().nullish(),\n    })\n    .nullish(),\n});\n\nconst googleGenerativeAIProviderOptionsSchema = z.object({\n  responseModalities: z.array(z.enum(['TEXT', 'IMAGE'])).nullish(),\n  thinkingConfig: z\n    .object({\n      thinkingBudget: z.number().nullish(),\n      includeThoughts: z.boolean().nullish(),\n    })\n    .nullish(),\n});\nexport type GoogleGenerativeAIProviderOptions = z.infer<\n  typeof googleGenerativeAIProviderOptionsSchema\n>;\n","import { JSONSchema7Definition } from '@ai-sdk/provider';\n\n/**\n * Converts JSON Schema 7 to OpenAPI Schema 3.0\n */\nexport function convertJSONSchemaToOpenAPISchema(\n  jsonSchema: JSONSchema7Definition,\n): unknown {\n  // parameters need to be undefined if they are empty objects:\n  if (isEmptyObjectSchema(jsonSchema)) {\n    return undefined;\n  }\n\n  if (typeof jsonSchema === 'boolean') {\n    return { type: 'boolean', properties: {} };\n  }\n\n  const {\n    type,\n    description,\n    required,\n    properties,\n    items,\n    allOf,\n    anyOf,\n    oneOf,\n    format,\n    const: constValue,\n    minLength,\n    enum: enumValues,\n  } = jsonSchema;\n\n  const result: Record<string, unknown> = {};\n\n  if (description) result.description = description;\n  if (required) result.required = required;\n  if (format) result.format = format;\n\n  if (constValue !== undefined) {\n    result.enum = [constValue];\n  }\n\n  // Handle type\n  if (type) {\n    if (Array.isArray(type)) {\n      if (type.includes('null')) {\n        result.type = type.filter(t => t !== 'null')[0];\n        result.nullable = true;\n      } else {\n        result.type = type;\n      }\n    } else if (type === 'null') {\n      result.type = 'null';\n    } else {\n      result.type = type;\n    }\n  }\n\n  // Handle enum\n  if (enumValues !== undefined) {\n    result.enum = enumValues;\n  }\n\n  if (properties != null) {\n    result.properties = Object.entries(properties).reduce(\n      (acc, [key, value]) => {\n        acc[key] = convertJSONSchemaToOpenAPISchema(value);\n        return acc;\n      },\n      {} as Record<string, unknown>,\n    );\n  }\n\n  if (items) {\n    result.items = Array.isArray(items)\n      ? items.map(convertJSONSchemaToOpenAPISchema)\n      : convertJSONSchemaToOpenAPISchema(items);\n  }\n\n  if (allOf) {\n    result.allOf = allOf.map(convertJSONSchemaToOpenAPISchema);\n  }\n  if (anyOf) {\n    // Handle cases where anyOf includes a null type\n    if (\n      anyOf.some(\n        schema => typeof schema === 'object' && schema?.type === 'null',\n      )\n    ) {\n      const nonNullSchemas = anyOf.filter(\n        schema => !(typeof schema === 'object' && schema?.type === 'null'),\n      );\n\n      if (nonNullSchemas.length === 1) {\n        // If there's only one non-null schema, convert it and make it nullable\n        const converted = convertJSONSchemaToOpenAPISchema(nonNullSchemas[0]);\n        if (typeof converted === 'object') {\n          result.nullable = true;\n          Object.assign(result, converted);\n        }\n      } else {\n        // If there are multiple non-null schemas, keep them in anyOf\n        result.anyOf = nonNullSchemas.map(convertJSONSchemaToOpenAPISchema);\n        result.nullable = true;\n      }\n    } else {\n      result.anyOf = anyOf.map(convertJSONSchemaToOpenAPISchema);\n    }\n  }\n  if (oneOf) {\n    result.oneOf = oneOf.map(convertJSONSchemaToOpenAPISchema);\n  }\n\n  if (minLength !== undefined) {\n    result.minLength = minLength;\n  }\n\n  return result;\n}\n\nfunction isEmptyObjectSchema(jsonSchema: JSONSchema7Definition): boolean {\n  return (\n    jsonSchema != null &&\n    typeof jsonSchema === 'object' &&\n    jsonSchema.type === 'object' &&\n    (jsonSchema.properties == null ||\n      Object.keys(jsonSchema.properties).length === 0) &&\n    !jsonSchema.additionalProperties\n  );\n}\n","import {\n  LanguageModelV1Prompt,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport { convertUint8ArrayToBase64 } from '@ai-sdk/provider-utils';\nimport {\n  GoogleGenerativeAIContent,\n  GoogleGenerativeAIContentPart,\n  GoogleGenerativeAIPrompt,\n} from './google-generative-ai-prompt';\n\nexport function convertToGoogleGenerativeAIMessages(\n  prompt: LanguageModelV1Prompt,\n): GoogleGenerativeAIPrompt {\n  const systemInstructionParts: Array<{ text: string }> = [];\n  const contents: Array<GoogleGenerativeAIContent> = [];\n  let systemMessagesAllowed = true;\n\n  for (const { role, content } of prompt) {\n    switch (role) {\n      case 'system': {\n        if (!systemMessagesAllowed) {\n          throw new UnsupportedFunctionalityError({\n            functionality:\n              'system messages are only supported at the beginning of the conversation',\n          });\n        }\n\n        systemInstructionParts.push({ text: content });\n        break;\n      }\n\n      case 'user': {\n        systemMessagesAllowed = false;\n\n        const parts: GoogleGenerativeAIContentPart[] = [];\n\n        for (const part of content) {\n          switch (part.type) {\n            case 'text': {\n              parts.push({ text: part.text });\n              break;\n            }\n\n            case 'image': {\n              parts.push(\n                part.image instanceof URL\n                  ? {\n                      fileData: {\n                        mimeType: part.mimeType ?? 'image/jpeg',\n                        fileUri: part.image.toString(),\n                      },\n                    }\n                  : {\n                      inlineData: {\n                        mimeType: part.mimeType ?? 'image/jpeg',\n                        data: convertUint8ArrayToBase64(part.image),\n                      },\n                    },\n              );\n\n              break;\n            }\n\n            case 'file': {\n              parts.push(\n                part.data instanceof URL\n                  ? {\n                      fileData: {\n                        mimeType: part.mimeType,\n                        fileUri: part.data.toString(),\n                      },\n                    }\n                  : {\n                      inlineData: {\n                        mimeType: part.mimeType,\n                        data: part.data,\n                      },\n                    },\n              );\n\n              break;\n            }\n          }\n        }\n\n        contents.push({ role: 'user', parts });\n        break;\n      }\n\n      case 'assistant': {\n        systemMessagesAllowed = false;\n\n        contents.push({\n          role: 'model',\n          parts: content\n            .map(part => {\n              switch (part.type) {\n                case 'text': {\n                  return part.text.length === 0\n                    ? undefined\n                    : { text: part.text };\n                }\n\n                case 'file': {\n                  if (part.mimeType !== 'image/png') {\n                    throw new UnsupportedFunctionalityError({\n                      functionality:\n                        'Only PNG images are supported in assistant messages',\n                    });\n                  }\n\n                  if (part.data instanceof URL) {\n                    throw new UnsupportedFunctionalityError({\n                      functionality:\n                        'File data URLs in assistant messages are not supported',\n                    });\n                  }\n\n                  return {\n                    inlineData: {\n                      mimeType: part.mimeType,\n                      data: part.data,\n                    },\n                  };\n                }\n\n                case 'tool-call': {\n                  return {\n                    functionCall: {\n                      name: part.toolName,\n                      args: part.args,\n                    },\n                  };\n                }\n              }\n            })\n            .filter(part => part !== undefined),\n        });\n        break;\n      }\n\n      case 'tool': {\n        systemMessagesAllowed = false;\n\n        contents.push({\n          role: 'user',\n          parts: content.map(part => ({\n            functionResponse: {\n              name: part.toolName,\n              response: {\n                name: part.toolName,\n                content: part.result,\n              },\n            },\n          })),\n        });\n        break;\n      }\n    }\n  }\n\n  return {\n    systemInstruction:\n      systemInstructionParts.length > 0\n        ? { parts: systemInstructionParts }\n        : undefined,\n    contents,\n  };\n}\n","export function getModelPath(modelId: string): string {\n  return modelId.includes('/') ? modelId : `models/${modelId}`;\n}\n","import { createJsonErrorResponseHandler } from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\n\nconst googleErrorDataSchema = z.object({\n  error: z.object({\n    code: z.number().nullable(),\n    message: z.string(),\n    status: z.string(),\n  }),\n});\n\nexport type GoogleErrorData = z.infer<typeof googleErrorDataSchema>;\n\nexport const googleFailedResponseHandler = createJsonErrorResponseHandler({\n  errorSchema: googleErrorDataSchema,\n  errorToMessage: data => data.error.message,\n});\n","import {\n  LanguageModelV1,\n  LanguageModelV1CallWarning,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport { convertJSONSchemaToOpenAPISchema } from './convert-json-schema-to-openapi-schema';\nimport {\n  DynamicRetrievalConfig,\n  GoogleGenerativeAIModelId,\n} from './google-generative-ai-settings';\n\nexport function prepareTools(\n  mode: Parameters<LanguageModelV1['doGenerate']>[0]['mode'] & {\n    type: 'regular';\n  },\n  useSearchGrounding: boolean,\n  dynamicRetrievalConfig: DynamicRetrievalConfig | undefined,\n  modelId: GoogleGenerativeAIModelId,\n): {\n  tools:\n    | undefined\n    | {\n        functionDeclarations: Array<{\n          name: string;\n          description: string | undefined;\n          parameters: unknown;\n        }>;\n      }\n    | {\n        googleSearchRetrieval:\n          | Record<string, never>\n          | { dynamicRetrievalConfig: DynamicRetrievalConfig };\n      }\n    | { googleSearch: Record<string, never> };\n  toolConfig:\n    | undefined\n    | {\n        functionCallingConfig: {\n          mode: 'AUTO' | 'NONE' | 'ANY';\n          allowedFunctionNames?: string[];\n        };\n      };\n  toolWarnings: LanguageModelV1CallWarning[];\n} {\n  const tools = mode.tools?.length ? mode.tools : undefined;\n  const toolWarnings: LanguageModelV1CallWarning[] = [];\n\n  const isGemini2 = modelId.includes('gemini-2');\n  const supportsDynamicRetrieval =\n    modelId.includes('gemini-1.5-flash') && !modelId.includes('-8b');\n\n  if (useSearchGrounding) {\n    return {\n      tools: isGemini2\n        ? { googleSearch: {} }\n        : {\n            googleSearchRetrieval:\n              !supportsDynamicRetrieval || !dynamicRetrievalConfig\n                ? {}\n                : { dynamicRetrievalConfig },\n          },\n      toolConfig: undefined,\n      toolWarnings,\n    };\n  }\n\n  if (tools == null) {\n    return { tools: undefined, toolConfig: undefined, toolWarnings };\n  }\n\n  const functionDeclarations = [];\n  for (const tool of tools) {\n    if (tool.type === 'provider-defined') {\n      toolWarnings.push({ type: 'unsupported-tool', tool });\n    } else {\n      functionDeclarations.push({\n        name: tool.name,\n        description: tool.description ?? '',\n        parameters: convertJSONSchemaToOpenAPISchema(tool.parameters),\n      });\n    }\n  }\n\n  const toolChoice = mode.toolChoice;\n\n  if (toolChoice == null) {\n    return {\n      tools: { functionDeclarations },\n      toolConfig: undefined,\n      toolWarnings,\n    };\n  }\n\n  const type = toolChoice.type;\n\n  switch (type) {\n    case 'auto':\n      return {\n        tools: { functionDeclarations },\n        toolConfig: { functionCallingConfig: { mode: 'AUTO' } },\n        toolWarnings,\n      };\n    case 'none':\n      return {\n        tools: { functionDeclarations },\n        toolConfig: { functionCallingConfig: { mode: 'NONE' } },\n        toolWarnings,\n      };\n    case 'required':\n      return {\n        tools: { functionDeclarations },\n        toolConfig: { functionCallingConfig: { mode: 'ANY' } },\n        toolWarnings,\n      };\n    case 'tool':\n      return {\n        tools: { functionDeclarations },\n        toolConfig: {\n          functionCallingConfig: {\n            mode: 'ANY',\n            allowedFunctionNames: [toolChoice.toolName],\n          },\n        },\n        toolWarnings,\n      };\n    default: {\n      const _exhaustiveCheck: never = type;\n      throw new UnsupportedFunctionalityError({\n        functionality: `Unsupported tool choice type: ${_exhaustiveCheck}`,\n      });\n    }\n  }\n}\n","import { LanguageModelV1FinishReason } from '@ai-sdk/provider';\n\nexport function mapGoogleGenerativeAIFinishReason({\n  finishReason,\n  hasToolCalls,\n}: {\n  finishReason: string | null | undefined;\n  hasToolCalls: boolean;\n}): LanguageModelV1FinishReason {\n  switch (finishReason) {\n    case 'STOP':\n      return hasToolCalls ? 'tool-calls' : 'stop';\n    case 'MAX_TOKENS':\n      return 'length';\n    case 'IMAGE_SAFETY':\n    case 'RECITATION':\n    case 'SAFETY':\n    case 'BLOCKLIST':\n    case 'PROHIBITED_CONTENT':\n    case 'SPII':\n      return 'content-filter';\n    case 'FINISH_REASON_UNSPECIFIED':\n    case 'OTHER':\n      return 'other';\n    case 'MALFORMED_FUNCTION_CALL':\n      return 'error';\n    default:\n      return 'unknown';\n  }\n}\n","import {\n  EmbeddingModelV1,\n  TooManyEmbeddingValuesForCallError,\n} from '@ai-sdk/provider';\nimport {\n  combineHeaders,\n  createJsonResponseHandler,\n  FetchFunction,\n  postJsonToApi,\n  resolve,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod';\nimport { googleFailedResponseHandler } from './google-error';\nimport {\n  GoogleGenerativeAIEmbeddingModelId,\n  GoogleGenerativeAIEmbeddingSettings,\n} from './google-generative-ai-embedding-settings';\n\ntype GoogleGenerativeAIEmbeddingConfig = {\n  provider: string;\n  baseURL: string;\n  headers: () => Record<string, string | undefined>;\n  fetch?: FetchFunction;\n};\n\nexport class GoogleGenerativeAIEmbeddingModel\n  implements EmbeddingModelV1<string>\n{\n  readonly specificationVersion = 'v1';\n  readonly modelId: GoogleGenerativeAIEmbeddingModelId;\n\n  private readonly config: GoogleGenerativeAIEmbeddingConfig;\n  private readonly settings: GoogleGenerativeAIEmbeddingSettings;\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  get maxEmbeddingsPerCall(): number {\n    return 2048;\n  }\n\n  get supportsParallelCalls(): boolean {\n    return true;\n  }\n\n  constructor(\n    modelId: GoogleGenerativeAIEmbeddingModelId,\n    settings: GoogleGenerativeAIEmbeddingSettings,\n    config: GoogleGenerativeAIEmbeddingConfig,\n  ) {\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n  }\n\n  async doEmbed({\n    values,\n    headers,\n    abortSignal,\n  }: Parameters<EmbeddingModelV1<string>['doEmbed']>[0]): Promise<\n    Awaited<ReturnType<EmbeddingModelV1<string>['doEmbed']>>\n  > {\n    if (values.length > this.maxEmbeddingsPerCall) {\n      throw new TooManyEmbeddingValuesForCallError({\n        provider: this.provider,\n        modelId: this.modelId,\n        maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,\n        values,\n      });\n    }\n\n    const mergedHeaders = combineHeaders(\n      await resolve(this.config.headers),\n      headers,\n    );\n\n    const { responseHeaders, value: response } = await postJsonToApi({\n      url: `${this.config.baseURL}/models/${this.modelId}:batchEmbedContents`,\n      headers: mergedHeaders,\n      body: {\n        requests: values.map(value => ({\n          model: `models/${this.modelId}`,\n          content: { role: 'user', parts: [{ text: value }] },\n          outputDimensionality: this.settings.outputDimensionality,\n          taskType: this.settings.taskType,\n        })),\n      },\n      failedResponseHandler: googleFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        googleGenerativeAITextEmbeddingResponseSchema,\n      ),\n      abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    return {\n      embeddings: response.embeddings.map(item => item.values),\n      usage: undefined,\n      rawResponse: { headers: responseHeaders },\n    };\n  }\n}\n\n// minimal version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst googleGenerativeAITextEmbeddingResponseSchema = z.object({\n  embeddings: z.array(z.object({ values: z.array(z.number()) })),\n});\n","export function isSupportedFileUrl(url: URL): boolean {\n  return url\n    .toString()\n    .startsWith('https://generativelanguage.googleapis.com/v1beta/files/');\n}\n","/**\n * Model provider for agent system\n * Matches the app's vercel-ai.ts configuration\n */\n\nimport { createAzure } from \"@ai-sdk/azure\";\nimport { createAmazonBedrock } from \"@ai-sdk/amazon-bedrock\";\nimport { createGoogleGenerativeAI } from \"@ai-sdk/google\";\nimport type { LanguageModel } from \"ai\";\n\n// Azure instances\nexport const azure = createAzure({\n  resourceName: process.env.AZURE_OPENAI_INSTANCE_NAME!,\n  apiKey: process.env.AZURE_OPENAI_API_KEY!,\n  apiVersion: \"2024-12-01-preview\",\n});\n\nexport const azureAiHub = createAzure({\n  resourceName: process.env.AZURE_AI_HUB_RESOURCE_NAME!,\n  apiKey: process.env.AZURE_AI_HUB_API_KEY!,\n  baseURL:\n    \"https://idylliclabsaih1806409153.openai.azure.com/openai/deployments/\",\n  apiVersion: \"2024-12-01-preview\",\n});\n\n// Google instance\nexport const google = createGoogleGenerativeAI({\n  apiKey: process.env.GOOGLE_API_KEY,\n});\n\n// Bedrock instance\nexport const bedrock = createAmazonBedrock({\n  region: process.env.BEDROCK_AWS_REGION,\n  accessKeyId: process.env.BEDROCK_AWS_ACCESS_KEY_ID!,\n  secretAccessKey: process.env.BEDROCK_AWS_SECRET_ACCESS_KEY!,\n});\n\n// Model instances\nconst o3_mini = azure(\"o3-mini\");\nconst o4_mini = azure(\"o4-mini\");\nconst gpt_4o_mini = azure(\"gpt-4o-mini\");\nconst gpt_4o = azure(\"4o\");\nconst gpt_4_1 = azure(\"gpt-4.1\");\nconst gpt_4_1_mini = azure(\"gpt-4.1-mini\");\nconst gpt_4_1_nano = azure(\"gpt-4.1-nano\");\nconst gemini_2_5_pro_preview_03_25 = google(\n  \"gemini-2.5-pro-preview-03-25\"\n);\nconst gemini_2_5_flash_preview_04_17 = google(\n  \"gemini-2.5-flash-preview-04-17\"\n);\nconst gemini_2_5_flash = google(\"gemini-2.5-flash\");\n\n// Bedrock Models\nconst claude_3_5_sonnet = bedrock(\n  \"anthropic.claude-3-5-sonnet-20241022-v2:0\"\n);\nconst claude_3_7_sonnet = bedrock(\n  \"us.anthropic.claude-3-7-sonnet-20250219-v1:0\"\n);\n\n/**\n * Get model by ID - matches app's logic\n */\nexport const getModel = (modelId: string): LanguageModel => {\n  switch (modelId) {\n    case \"o4-mini\":\n      return o4_mini;\n    case \"gpt-4\":\n    case \"gpt-4.1\":\n      return gpt_4_1;\n    case \"gpt-4o-mini\":\n    case \"gpt-4.1-mini\":\n      return gpt_4_1_mini;\n    case \"gpt-4.1-nano\":\n      return gpt_4_1_nano;\n    case \"claude-3.5-sonnet-v2\":\n      return claude_3_5_sonnet;\n    case \"gemini-2.5-pro\":\n      return gemini_2_5_pro_preview_03_25;\n    case \"gemini-2.5-flash\":\n      return gemini_2_5_flash_preview_04_17;\n    default:\n      return gpt_4_1;\n  }\n};\n\n/**\n * Check if required environment variables are set\n */\nexport function checkModelConfig(): { valid: boolean; message?: string } {\n  if (!process.env.AZURE_OPENAI_INSTANCE_NAME || !process.env.AZURE_OPENAI_API_KEY) {\n    return {\n      valid: false,\n      message: 'Azure OpenAI configuration missing. Set AZURE_OPENAI_INSTANCE_NAME and AZURE_OPENAI_API_KEY.',\n    };\n  }\n  \n  return { valid: true };\n}","/**\n * AI-based variable resolution for agent custom tools\n * \n * Uses an AI model to intelligently resolve variables based on context\n */\n\nimport { generateText } from 'ai';\nimport { getModel } from './model-provider';\nimport { VariableDefinition, VariableResolutionContext, VariableResolutionResult } from '../document/variable-resolution';\n\n/**\n * Resolve variables using AI\n */\nexport async function resolveVariablesWithAI(\n  definitions: VariableDefinition[],\n  context: VariableResolutionContext\n): Promise<VariableResolutionResult> {\n  console.log(' AI Variable Resolution Starting');\n  console.log(' Definitions:', definitions);\n  console.log(' Context:', context);\n  \n  if (definitions.length === 0) {\n    return { variables: new Map() };\n  }\n  \n  const variables = new Map<string, string>();\n  const errors: Array<{ variable: string; error: string }> = [];\n  \n  // Build a prompt for the AI to resolve all variables at once\n  const prompt = buildVariableResolutionPrompt(definitions, context);\n  console.log(' Built prompt:', prompt);\n  \n  try {\n    const result = await generateText({\n      model: getModel('gpt-4.1'),\n      temperature: 0.3, // Lower temperature for more consistent resolution\n      system: `You are a helpful assistant that resolves variable values based on context.\nGiven the context and variable descriptions, provide appropriate values for each variable.\nReturn ONLY a JSON object with variable names as keys and their resolved values as values.\nDo not include any markdown formatting or explanation.`,\n      prompt: `${prompt}\n\nReturn a JSON object like: {\"variableName\": \"resolvedValue\", ...}`,\n    });\n    \n    console.log(' AI Response:', result.text);\n    \n    // Parse the AI response\n    try {\n      const resolved = JSON.parse(result.text);\n      console.log(' Parsed JSON:', resolved);\n      \n      // Validate and store resolved values\n      for (const def of definitions) {\n        if (def.name in resolved) {\n          const value = String(resolved[def.name]);\n          variables.set(def.name, value);\n          console.log(` Resolved ${def.name} = \"${value}\"`);\n        } else {\n          // AI didn't resolve this variable\n          variables.set(def.name, def.name); // Fallback to variable name\n          console.log(` AI didn't resolve ${def.name}, using fallback`);\n        }\n      }\n    } catch (parseError) {\n      // If AI response isn't valid JSON, fall back to simple extraction\n      console.warn('Failed to parse AI response as JSON, using fallback resolution');\n      \n      // Try to extract values from the text response\n      for (const def of definitions) {\n        const pattern = new RegExp(`${def.name}[: ]+\"?([^\"]+)\"?`, 'i');\n        const match = result.text.match(pattern);\n        if (match) {\n          variables.set(def.name, match[1].trim());\n        } else {\n          variables.set(def.name, def.name); // Fallback\n        }\n      }\n    }\n  } catch (error) {\n    // If AI call fails, add all variables as errors\n    for (const def of definitions) {\n      errors.push({\n        variable: def.name,\n        error: error instanceof Error ? error.message : 'AI resolution failed',\n      });\n      // Provide fallback value\n      variables.set(def.name, `[${def.name}]`);\n    }\n  }\n  \n  return { variables, errors: errors.length > 0 ? errors : undefined };\n}\n\n/**\n * Build prompt for variable resolution\n */\nfunction buildVariableResolutionPrompt(\n  definitions: VariableDefinition[],\n  context: VariableResolutionContext\n): string {\n  const parts: string[] = [];\n  \n  // Add agent context (the primary context for custom tools)\n  if (context.agentContext) {\n    parts.push(`Context: ${context.agentContext}`);\n  }\n  \n  // Add document context if available\n  if (context.documentContext) {\n    parts.push(`Document context: ${context.documentContext}`);\n  }\n  \n  // Add inherited context if available\n  if (context.inheritedContext && Object.keys(context.inheritedContext).length > 0) {\n    parts.push(`Additional context: ${JSON.stringify(context.inheritedContext)}`);\n  }\n  \n  // Add variables to resolve\n  parts.push('\\nVariables to resolve:');\n  for (const def of definitions) {\n    if (def.prompt) {\n      parts.push(`- ${def.name}: ${def.prompt}`);\n    } else {\n      parts.push(`- ${def.name} (no prompt provided)`);\n    }\n  }\n  \n  parts.push('\\nProvide a JSON object with resolved values for each variable based on the context.');\n  \n  return parts.join('\\n');\n}","/**\n * Core AST types for Idyllic documents\n * \n * This defines the semantic model for documents, independent of:\n * - BlockNote editor representation\n * - XML serialization format\n * - Specific tool implementations\n */\n\n// ============================================\n// Core Document Types\n// ============================================\n\n/**\n * The root document structure\n */\nexport interface IdyllDocument {\n  id: string;\n  blocks: Block[];\n  metadata?: DocumentMetadata;\n}\n\n/**\n * Agent system prompt document\n */\nexport interface AgentDocument {\n  type: 'agent';\n  id: string;\n  name?: string;\n  description?: string;\n  model?: string;\n  blocks: Block[];\n}\n\n/**\n * Diff document for edit operations\n */\nexport interface DiffDocument {\n  type: 'diff';\n  targetDocument?: string;\n  timestamp: Date;\n  operations: EditOperation[];\n}\n\n/**\n * Edit operation types\n */\nexport type EditOperation = \n  | EditAttrOperation\n  | EditContentOperation\n  | EditParamsOperation\n  | EditIdOperation\n  | InsertOperation\n  | DeleteOperation\n  | ReplaceOperation\n  | MoveOperation;\n\nexport interface EditAttrOperation {\n  type: 'edit:attr';\n  blockId: string;\n  name: string;\n  value: string;\n}\n\nexport interface EditContentOperation {\n  type: 'edit:content';\n  blockId: string;\n  content: RichContent[];\n}\n\nexport interface EditParamsOperation {\n  type: 'edit:params';\n  blockId: string;\n  params: Record<string, unknown>;\n}\n\nexport interface EditIdOperation {\n  type: 'edit:id';\n  blockId: string;\n  newId: string;\n}\n\nexport interface InsertOperation {\n  type: 'insert';\n  afterBlockId?: string;\n  beforeBlockId?: string;\n  atStart?: boolean;\n  atEnd?: boolean;\n  blocks: Block[];\n}\n\nexport interface DeleteOperation {\n  type: 'delete';\n  blockId: string;\n}\n\nexport interface ReplaceOperation {\n  type: 'replace';\n  blockId: string;\n  blocks: Block[];\n}\n\nexport interface MoveOperation {\n  type: 'move';\n  blockId?: string;\n  blockIds?: string[];\n  fromBlockId?: string;\n  toBlockId?: string;\n  afterBlockId?: string;\n  beforeBlockId?: string;\n  atStart?: boolean;\n  atEnd?: boolean;\n}\n\nexport interface DocumentMetadata {\n  version?: string;\n  created?: Date;\n  modified?: Date;\n  [key: string]: unknown;\n}\n\n/**\n * A block can be either content (text, headings, etc) or executable\n */\nexport type Block = ContentBlock | ExecutableBlock;\n\n// ============================================\n// Content Blocks\n// ============================================\n\nexport interface ContentBlock {\n  id: string;\n  type: ContentBlockType;\n  content: RichContent[];\n  children?: Block[];\n  props?: Record<string, unknown>;\n}\n\n// Define block types directly\nexport type BlockType = \n  | 'p' | 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6'\n  | 'ul' | 'ol' | 'li'\n  | 'blockquote' | 'code' | 'pre'\n  | 'hr' | 'br'\n  | 'function_call' | 'trigger' | '_params' | '_content' | '_result'\n  | 'heading' | 'paragraph';  // Added for compatibility\n\n// ContentBlockType includes all content-related types\nexport type ContentBlockType = \n  | 'paragraph' | 'heading'\n  | 'bulletListItem' | 'numberedListItem' | 'checklistItem'\n  | 'code' | 'quote' | 'separator' | 'data' | 'tool';\n\n// ============================================\n// Executable Blocks\n// ============================================\n\nexport interface ExecutableBlock {\n  id: string;\n  type: ExecutableBlockType;\n  tool: string; // e.g., \"documents:create\", \"ai:generate-text\"\n  parameters: Record<string, unknown>;\n  instructions?: RichContent[]; // Natural language instructions\n  result?: ExecutionResult;\n  metadata?: ExecutableMetadata;\n}\n\nexport type ExecutableBlockType = 'function_call' | 'trigger';\n\nexport interface ExecutableMetadata {\n  enabled?: boolean; // For triggers\n  modelId?: string; // For AI operations\n  [key: string]: unknown;\n}\n\nexport interface ExecutionResult {\n  success: boolean;\n  data?: unknown;\n  error?: ExecutionError;\n  timestamp?: Date;\n}\n\nexport interface ExecutionError {\n  code: string;\n  message: string;\n  details?: unknown;\n}\n\n// ============================================\n// Rich Content Types\n// ============================================\n\n/**\n * Rich content represents inline formatted text and elements\n */\nexport type RichContent = TextContent | InlineElement;\n\nexport interface TextContent {\n  type: 'text';\n  text: string;\n  styles?: TextStyle[];\n}\n\nexport type TextStyle = \n  | 'bold'\n  | 'italic'\n  | 'underline'\n  | 'strikethrough'\n  | 'code';\n\nexport type InlineElement = \n  | MentionElement\n  | VariableElement\n  | LinkElement\n  | AnnotationElement;\n\nexport interface MentionElement {\n  type: 'mention';\n  mentionType: 'user' | 'document' | 'agent' | 'custom';\n  id: string;\n  label?: string;\n}\n\nexport interface VariableElement {\n  type: 'variable';\n  name: string; // e.g., \"previousResult\", \"currentDate\"\n  prompt?: string; // Optional prompt for user input\n  value?: string; // Optional resolved value\n}\n\nexport interface LinkElement {\n  type: 'link';\n  href: string;\n  content: RichContent[];\n}\n\nexport interface AnnotationElement {\n  type: 'annotation';\n  content: RichContent[];\n  annotation: {\n    title?: string;\n    comment?: string;\n    confidence?: number;\n    [key: string]: unknown;\n  };\n}\n\n// ============================================\n// Utility Types\n// ============================================\n\n/**\n * Type guards for runtime type checking\n */\nexport function isContentBlock(block: Block): block is ContentBlock {\n  return !isExecutableBlock(block);\n}\n\nexport function isExecutableBlock(block: Block): block is ExecutableBlock {\n  return block.type === 'function_call' || block.type === 'trigger';\n}\n\nexport function isTextContent(content: RichContent): content is TextContent {\n  return content.type === 'text';\n}\n\nexport function isMention(content: RichContent): content is MentionElement {\n  return content.type === 'mention';\n}\n\nexport function isVariable(content: RichContent): content is VariableElement {\n  return content.type === 'variable';\n}\n\n// ============================================\n// Document Traversal Utilities\n// ============================================\n\n/**\n * Traverse all blocks in a document (including nested children)\n */\nexport function* traverseBlocks(blocks: Block[]): Generator<Block> {\n  for (const block of blocks) {\n    yield block;\n    if ('children' in block && block.children) {\n      yield* traverseBlocks(block.children);\n    }\n  }\n}\n\n/**\n * Find a block by ID\n */\nexport function findBlock(blocks: Block[], id: string): Block | undefined {\n  for (const block of traverseBlocks(blocks)) {\n    if (block.id === id) {\n      return block;\n    }\n  }\n  return undefined;\n}\n\n/**\n * Get all executable blocks\n */\nexport function getExecutableBlocks(blocks: Block[]): ExecutableBlock[] {\n  const executable: ExecutableBlock[] = [];\n  for (const block of traverseBlocks(blocks)) {\n    if (isExecutableBlock(block)) {\n      executable.push(block);\n    }\n  }\n  return executable;\n}\n\n/**\n * Extract all mentions from a document\n */\nexport function extractMentions(blocks: Block[]): MentionElement[] {\n  const mentions: MentionElement[] = [];\n  \n  function extractFromContent(content: RichContent[]) {\n    for (const item of content) {\n      if (isMention(item)) {\n        mentions.push(item);\n      } else if ('content' in item && Array.isArray(item.content)) {\n        extractFromContent(item.content);\n      }\n    }\n  }\n  \n  for (const block of traverseBlocks(blocks)) {\n    if ('content' in block && Array.isArray(block.content)) {\n      extractFromContent(block.content);\n    }\n    if (isExecutableBlock(block) && block.instructions) {\n      extractFromContent(block.instructions);\n    }\n  }\n  \n  return mentions;\n}\n\n/**\n * Extract all variables from a document\n */\nexport function extractVariables(blocks: Block[]): VariableElement[] {\n  const variables: VariableElement[] = [];\n  \n  function extractFromContent(content: RichContent[]) {\n    for (const item of content) {\n      if (isVariable(item)) {\n        variables.push(item);\n      } else if ('content' in item && Array.isArray(item.content)) {\n        extractFromContent(item.content);\n      }\n    }\n  }\n  \n  for (const block of traverseBlocks(blocks)) {\n    if ('content' in block && Array.isArray(block.content)) {\n      extractFromContent(block.content);\n    }\n    if (isExecutableBlock(block) && block.instructions) {\n      extractFromContent(block.instructions);\n    }\n  }\n  \n  return variables;\n}","/**\n * Grammar-based XML parser for Idyllic documents\n *\n * This parser uses the grammar as the single source of truth\n * for parsing, validation, and AST construction\n */\n\nimport * as xml2js from \"xml-js\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport {\n  IdyllDocument,\n  AgentDocument,\n  DiffDocument,\n  EditOperation,\n  Block,\n  ContentBlock,\n  ExecutableBlock,\n  RichContent,\n  TextContent,\n  TextStyle,\n  MentionElement,\n  VariableElement,\n  LinkElement,\n  AnnotationElement,\n  ContentBlockType,\n  isExecutableBlock,\n  isTextContent,\n} from \"./ast\";\nimport { ParseError } from \"../types\";\nimport { GRAMMAR } from \"./grammar\";\nimport { GrammarCompiler } from \"./grammar-compiler\";\n\n// Initialize grammar compiler\nconst compiler = new GrammarCompiler(GRAMMAR);\nconst compiled = compiler.compile();\n\n// ============================================\n// XML to AST Parsing\n// ============================================\n\n/**\n * Parse XML string and determine root type\n */\nexport function parseXML(\n  xmlString: string\n): IdyllDocument | AgentDocument | DiffDocument {\n  if (!xmlString || !xmlString.trim()) {\n    throw new ParseError(\"Empty XML content provided\");\n  }\n\n  // Parse XML\n  const options: xml2js.Options.XML2JS = {\n    compact: false,\n    textKey: \"text\",\n    ignoreDeclaration: true,\n    ignoreInstruction: true,\n    ignoreComment: true,\n    ignoreDoctype: true,\n    ignoreText: false,\n    trim: false,\n    sanitize: false,\n    nativeType: false,\n  };\n\n  let result: xml2js.Element;\n  try {\n    result = xml2js.xml2js(xmlString, options) as xml2js.Element;\n  } catch (error) {\n    throw new ParseError(\n      `Invalid XML format: ${\n        error instanceof Error ? error.message : \"Failed to parse XML\"\n      }`\n    );\n  }\n\n  // Determine root type and parse accordingly\n  const rootElement = result.elements?.[0];\n  if (!rootElement || rootElement.type !== \"element\") {\n    throw new ParseError(\"No root element found\");\n  }\n\n  switch (rootElement.name) {\n    case \"document\":\n      return parseDocument(rootElement);\n    case \"agent\":\n      return parseAgent(rootElement);\n    case \"diff\":\n      return parseDiff(rootElement);\n    default:\n      throw new ParseError(\n        `Unknown root element: ${rootElement.name}. Expected: document, agent, or diff`\n      );\n  }\n}\n\n/**\n * Parse document root\n */\nfunction parseDocument(documentElement: xml2js.Element): IdyllDocument {\n  // Validate document element\n  const attrs = documentElement.attributes || {};\n  const validationErrors = compiled.validateAttributes(\"document\", attrs);\n  if (validationErrors.length > 0) {\n    throw new ParseError(\n      `Document validation failed: ${validationErrors[0].message}`\n    );\n  }\n\n  const documentId = (attrs.id as string) || uuidv4();\n\n  // Parse blocks\n  const blocks: Block[] = [];\n  const childElements = documentElement.elements || [];\n\n  for (const element of childElements) {\n    if (element.type === \"element\" && element.name) {\n      const block = parseBlock(element);\n      if (block) {\n        blocks.push(block);\n      }\n    }\n  }\n\n  return {\n    id: documentId,\n    blocks: blocks.length > 0 ? blocks : [createEmptyParagraph()],\n    metadata: extractMetadata(attrs),\n  };\n}\n\n/**\n * Parse agent root\n */\nfunction parseAgent(agentElement: xml2js.Element): AgentDocument {\n  const attrs = agentElement.attributes || {};\n  const validationErrors = compiled.validateAttributes(\"agent\", attrs);\n  if (validationErrors.length > 0) {\n    throw new ParseError(\n      `Agent validation failed: ${validationErrors[0].message}`\n    );\n  }\n\n  const agentId = (attrs.id as string) || uuidv4();\n\n  // Parse blocks (same as document)\n  const blocks: Block[] = [];\n  const childElements = agentElement.elements || [];\n\n  for (const element of childElements) {\n    if (element.type === \"element\" && element.name) {\n      const block = parseBlock(element);\n      if (block) {\n        blocks.push(block);\n      }\n    }\n  }\n\n  return {\n    type: \"agent\",\n    id: agentId,\n    name: attrs.name as string,\n    description: attrs.description as string,\n    model: attrs.model as string,\n    blocks,\n  };\n}\n\n/**\n * Parse diff root\n */\nfunction parseDiff(diffElement: xml2js.Element): DiffDocument {\n  const attrs = diffElement.attributes || {};\n  const validationErrors = compiled.validateAttributes(\"diff\", attrs);\n  if (validationErrors.length > 0) {\n    throw new ParseError(\n      `Diff validation failed: ${validationErrors[0].message}`\n    );\n  }\n\n  // Parse edit operations\n  const operations: EditOperation[] = [];\n  const childElements = diffElement.elements || [];\n\n  for (const element of childElements) {\n    if (element.type === \"element\" && element.name) {\n      const operation = parseEditOperation(element);\n      if (operation) {\n        operations.push(operation);\n      }\n    }\n  }\n\n  return {\n    type: \"diff\",\n    targetDocument: attrs.targetDocument as string,\n    timestamp: attrs.timestamp\n      ? new Date(attrs.timestamp as string)\n      : new Date(),\n    operations,\n  };\n}\n\n/**\n * Parse edit operation\n */\nfunction parseEditOperation(element: xml2js.Element): EditOperation | null {\n  if (!element.name) return null;\n\n  const attrs = element.attributes || {};\n\n  switch (element.name) {\n    case \"edit:prop\":\n      return {\n        type: \"edit:attr\",\n        blockId: attrs[\"block-id\"] as string,\n        name: attrs.name as string,\n        value: attrs.value as string,\n      };\n\n    case \"edit:content\":\n      return {\n        type: \"edit:content\",\n        blockId: attrs[\"block-id\"] as string,\n        content: parseRichContent(element),\n      };\n\n    case \"insert\":\n      const insertBlocks: Block[] = [];\n      for (const child of element.elements || []) {\n        if (child.type === \"element\" && child.name) {\n          const block = parseBlock(child);\n          if (block) {\n            insertBlocks.push(block);\n          }\n        }\n      }\n      return {\n        type: \"insert\",\n        afterBlockId: attrs[\"after-block-id\"] as string,\n        beforeBlockId: attrs[\"before-block-id\"] as string,\n        atStart: attrs[\"at-start\"] === \"true\",\n        atEnd: attrs[\"at-end\"] === \"true\",\n        blocks: insertBlocks,\n      };\n\n    case \"delete\":\n      return {\n        type: \"delete\",\n        blockId: attrs[\"block-id\"] as string,\n      };\n\n    case \"replace\":\n      const replaceBlocks: Block[] = [];\n      for (const child of element.elements || []) {\n        if (child.type === \"element\" && child.name) {\n          const block = parseBlock(child);\n          if (block) {\n            replaceBlocks.push(block);\n          }\n        }\n      }\n      return {\n        type: \"replace\",\n        blockId: attrs[\"block-id\"] as string,\n        blocks: replaceBlocks,\n      };\n\n    default:\n      console.warn(`Unknown edit operation: ${element.name}`);\n      return null;\n  }\n}\n\n/**\n * Parse a block element using grammar rules\n */\nfunction parseBlock(element: xml2js.Element): Block | null {\n  if (!element.name) return null;\n\n  const elementType = compiled.elementToType[element.name];\n  if (!elementType) {\n    return null;\n  }\n\n  const id = (element.attributes?.id as string) || uuidv4();\n  const attrs = element.attributes || {};\n\n  // Validate attributes\n  const errors = compiled.validateAttributes(element.name, attrs);\n  if (errors.length > 0) {\n    throw new ParseError(\n      `Invalid attributes for ${element.name}: ${errors[0].message}`\n    );\n  }\n\n  // Route based on element type\n  switch (elementType) {\n    case \"function_call\":\n      return parseFunctionCall(element, id, attrs);\n    case \"trigger\":\n      return parseTrigger(element, id, attrs);\n    case \"tool\":\n      return parseTool(element, id, attrs);\n    default:\n      return parseContentBlock(element, id, attrs, elementType);\n  }\n}\n\n/**\n * Parse function call block\n */\nfunction parseFunctionCall(\n  element: xml2js.Element,\n  id: string,\n  attrs: Record<string, unknown>\n): ExecutableBlock {\n  const tool = attrs[\"idyll-tool\"] as string;\n\n  let parameters: Record<string, unknown> = {};\n  let instructions: RichContent[] = [];\n  let result: unknown;\n\n  // Parse child elements according to grammar\n  for (const child of element.elements || []) {\n    if (child.type === \"element\" && child.name) {\n      switch (child.name) {\n        case \"params\":\n          const paramsText = extractTextContent(child);\n          if (paramsText) {\n            try {\n              parameters = JSON.parse(paramsText);\n            } catch {\n              throw new ParseError(`Invalid JSON in params: ${paramsText}`);\n            }\n          }\n          break;\n\n        case \"content\":\n          instructions = parseRichContent(child);\n          break;\n\n        case \"result\":\n          const resultText = extractTextContent(child);\n          if (resultText) {\n            try {\n              result = JSON.parse(resultText);\n            } catch {\n              result = resultText;\n            }\n          }\n          break;\n      }\n    }\n  }\n\n  return {\n    id,\n    type: \"function_call\",\n    tool,\n    parameters,\n    instructions: instructions.length > 0 ? instructions : undefined,\n    result: result ? { success: true, data: result } : undefined,\n    metadata: {\n      modelId: attrs.modelId as string,\n    },\n  };\n}\n\n/**\n * Parse trigger block\n */\nfunction parseTrigger(\n  element: xml2js.Element,\n  id: string,\n  attrs: Record<string, unknown>\n): ExecutableBlock {\n  const tool = attrs[\"idyll-trigger\"] as string;\n  const enabled = attrs.enabled !== false;\n\n  let parameters: Record<string, unknown> = {};\n  let instructions: RichContent[] = [];\n\n  for (const child of element.elements || []) {\n    if (child.type === \"element\" && child.name) {\n      switch (child.name) {\n        case \"params\":\n          const paramsText = extractTextContent(child);\n          if (paramsText) {\n            try {\n              parameters = JSON.parse(paramsText);\n            } catch {\n              throw new ParseError(`Invalid JSON in params: ${paramsText}`);\n            }\n          }\n          break;\n\n        case \"content\":\n          instructions = parseRichContent(child);\n          break;\n      }\n    }\n  }\n\n  return {\n    id,\n    type: \"trigger\",\n    tool,\n    parameters,\n    instructions: instructions.length > 0 ? instructions : undefined,\n    metadata: { enabled },\n  };\n}\n\n/**\n * Parse tool block\n */\nfunction parseTool(\n  element: xml2js.Element,\n  id: string,\n  attrs: Record<string, unknown>\n): ContentBlock {\n  // Tools are stored as content blocks with special props\n  const title = attrs.title as string;\n  const icon = attrs.icon as string;\n\n  let description = \"\";\n  let definition: Block[] = [];\n\n  for (const child of element.elements || []) {\n    if (child.type === \"element\" && child.name) {\n      switch (child.name) {\n        case \"tool:description\":\n          description = extractTextContent(child);\n          break;\n\n        case \"tool:definition\":\n          // Parse blocks within tool definition\n          for (const defChild of child.elements || []) {\n            if (defChild.type === \"element\" && defChild.name) {\n              // Check that it's not another tool (grammar constraint)\n              if (compiled.elementToType[defChild.name] === \"tool\") {\n                throw new ParseError(\"Tools cannot contain other tools\");\n              }\n\n              const block = parseBlock(defChild);\n              if (block) {\n                definition.push(block);\n              }\n            }\n          }\n          break;\n      }\n    }\n  }\n\n  return {\n    id,\n    type: \"tool\" as ContentBlockType,\n    content: [{ type: \"text\", text: description }],\n    children: definition.length > 0 ? definition : undefined,\n    props: { title, icon },\n  };\n}\n\n/**\n * Parse content block\n */\nfunction parseContentBlock(\n  element: xml2js.Element,\n  id: string,\n  attrs: Record<string, unknown>,\n  blockType: string\n): ContentBlock {\n  const content = parseRichContent(element);\n\n  // Parse children for nested blocks\n  const children: Block[] = [];\n  for (const child of element.elements || []) {\n    if (child.type === \"element\" && child.name) {\n      const childType = compiled.elementToType[child.name];\n      if (childType && compiled.blockTypes.has(childType)) {\n        const childBlock = parseBlock(child);\n        if (childBlock) {\n          children.push(childBlock);\n        }\n      }\n    }\n  }\n\n  // Handle heading level\n  if (blockType === \"heading\") {\n    if (element.name === \"heading\") {\n      // Already has level attribute\n    } else if (element.name) {\n      const match = element.name.match(/^h(\\d)$/);\n      if (match) {\n        attrs.level = parseInt(match[1], 10);\n      }\n    }\n  }\n\n  return {\n    id,\n    type: blockType as ContentBlockType,\n    content,\n    children: children.length > 0 ? children : undefined,\n    props: attrs,\n  };\n}\n\n/**\n * Parse rich content using grammar rules\n */\nfunction parseRichContent(element: xml2js.Element): RichContent[] {\n  const content: RichContent[] = [];\n\n  if (!element.elements) return content;\n\n  for (const child of element.elements) {\n    if (child.type === \"text\" && child.text) {\n      content.push({\n        type: \"text\",\n        text: child.text as string,\n      });\n    } else if (child.type === \"element\" && child.name) {\n      const inlineElement = parseInlineElement(child);\n      if (inlineElement) {\n        if (Array.isArray(inlineElement)) {\n          content.push(...inlineElement);\n        } else {\n          content.push(inlineElement);\n        }\n      }\n    }\n  }\n\n  return content;\n}\n\n/**\n * Parse inline element\n */\nfunction parseInlineElement(\n  element: xml2js.Element\n): RichContent | RichContent[] | null {\n  if (!element.name) return null;\n\n  // Check if it's a mention\n  if (element.name.startsWith(\"mention:\")) {\n    const mentionType = element.name.substring(8) as any;\n    const id = element.attributes?.id as string;\n    const label =\n      (element.attributes?.label as string) || extractTextContent(element);\n\n    return {\n      type: \"mention\",\n      mentionType,\n      id,\n      label,\n    } as MentionElement;\n  }\n\n  // Check if it's a variable\n  if (element.name === \"variable\") {\n    const name = element.attributes?.name as string;\n    const prompt = element.attributes?.prompt as string;\n    const value = element.attributes?.value as string;\n    return {\n      type: \"variable\",\n      name,\n      ...(prompt && { prompt }),\n      ...(value && { value }),\n    } as VariableElement;\n  }\n\n  // Check if it's a link\n  if (element.name === \"a\") {\n    const href = element.attributes?.href as string;\n    return {\n      type: \"link\",\n      href,\n      content: parseRichContent(element),\n    } as LinkElement;\n  }\n\n  // Check if it's an annotation\n  if (element.name === \"annotation\") {\n    return {\n      type: \"annotation\",\n      content: parseRichContent(element),\n      annotation: (element.attributes as any) || {},\n    } as AnnotationElement;\n  }\n\n  // Check if it's annotated text\n  if (element.name === \"annotatedtext\") {\n    const annotation = element.attributes?.annotation as string;\n    return {\n      type: \"annotation\",\n      content: parseRichContent(element),\n      annotation: { title: annotation },\n    } as AnnotationElement;\n  }\n\n  // Check if it's AI edit response\n  if (element.name === \"aieditresponse\") {\n    const status = element.attributes?.status as string;\n    return {\n      type: \"annotation\",\n      content: parseRichContent(element),\n      annotation: { type: \"ai-edit\", status },\n    } as AnnotationElement;\n  }\n\n  // Check if it's a style element\n  const styleMap: Record<string, TextStyle> = {\n    strong: \"bold\",\n    b: \"bold\",\n    em: \"italic\",\n    i: \"italic\",\n    u: \"underline\",\n    underline: \"underline\",\n    s: \"strikethrough\",\n    strike: \"strikethrough\",\n    del: \"strikethrough\",\n    code: \"code\",\n    tt: \"code\",\n  };\n\n  const style = styleMap[element.name];\n  if (style) {\n    const innerContent = parseRichContent(element);\n    return innerContent.map((item) => {\n      if (isTextContent(item)) {\n        return {\n          ...item,\n          styles: [...(item.styles || []), style],\n        } as TextContent;\n      }\n      return item;\n    });\n  }\n\n  return null;\n}\n\n// ============================================\n// AST to XML Serialization\n// ============================================\n\n/**\n * Serialize any document type to XML string\n */\nexport function serializeToXML(\n  document: IdyllDocument | AgentDocument | DiffDocument\n): string {\n  let root: xml2js.Element;\n\n  if (\"type\" in document) {\n    if (document.type === \"agent\") {\n      root = serializeAgentDocument(document);\n    } else if (document.type === \"diff\") {\n      root = serializeDiffDocument(document);\n    } else {\n      throw new Error(`Unknown document type`);\n    }\n  } else {\n    root = serializeIdyllDocument(document);\n  }\n\n  const options: xml2js.Options.JS2XML = {\n    compact: false,\n    spaces: 2,\n    textKey: \"text\",\n  };\n\n  // xml2js expects the root element to be wrapped in an object with elements array\n  const wrapped = {\n    elements: [root]\n  };\n\n  return `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n${xml2js.js2xml(\n    wrapped,\n    options\n  )}`;\n}\n\n/**\n * Serialize IdyllDocument\n */\nfunction serializeIdyllDocument(document: IdyllDocument): xml2js.Element {\n  return {\n    type: \"element\",\n    name: \"document\",\n    attributes: {\n      id: document.id,\n      ...serializeMetadata(document.metadata),\n    },\n    elements: document.blocks.map(serializeBlock),\n  };\n}\n\n/**\n * Serialize AgentDocument\n */\nfunction serializeAgentDocument(document: AgentDocument): xml2js.Element {\n  return {\n    type: \"element\",\n    name: \"agent\",\n    attributes: {\n      id: document.id,\n      ...(document.name && { name: document.name }),\n      ...(document.description && { description: document.description }),\n      ...(document.model && { model: document.model }),\n    },\n    elements: document.blocks.map(serializeBlock),\n  };\n}\n\n/**\n * Serialize DiffDocument\n */\nfunction serializeDiffDocument(document: DiffDocument): xml2js.Element {\n  return {\n    type: \"element\",\n    name: \"diff\",\n    attributes: {\n      ...(document.targetDocument && {\n        targetDocument: document.targetDocument,\n      }),\n      timestamp: document.timestamp.toISOString(),\n    },\n    elements: document.operations.map(serializeEditOperation),\n  };\n}\n\n/**\n * Serialize a block to XML element\n */\nfunction serializeBlock(block: Block): xml2js.Element {\n  if (isExecutableBlock(block)) {\n    return serializeExecutableBlock(block);\n  }\n\n  // Special handling for tool blocks\n  if (block.type === \"tool\") {\n    return serializeToolBlock(block);\n  }\n\n  return serializeContentBlock(block);\n}\n\n/**\n * Serialize executable block\n */\nfunction serializeExecutableBlock(block: ExecutableBlock): xml2js.Element {\n  const elements: xml2js.Element[] = [];\n\n  // Add params\n  if (Object.keys(block.parameters).length > 0) {\n    elements.push({\n      type: \"element\",\n      name: \"params\",\n      elements: [\n        {\n          type: \"cdata\",\n          cdata: JSON.stringify(block.parameters),\n        },\n      ],\n    });\n  }\n\n  // Add content\n  if (block.instructions && block.instructions.length > 0) {\n    elements.push({\n      type: \"element\",\n      name: \"content\",\n      elements: serializeRichContent(block.instructions),\n    });\n  }\n\n  if (block.type === \"function_call\") {\n    // Add result\n    if (block.result) {\n      elements.push({\n        type: \"element\",\n        name: \"result\",\n        elements: [\n          {\n            type: \"cdata\",\n            cdata: JSON.stringify(block.result.data || block.result),\n          },\n        ],\n      });\n    }\n\n    return {\n      type: \"element\",\n      name: \"fncall\",\n      attributes: {\n        id: block.id,\n        \"idyll-tool\": block.tool,\n        ...(block.metadata?.modelId && { modelId: block.metadata.modelId }),\n      },\n      elements,\n    };\n  } else {\n    return {\n      type: \"element\",\n      name: \"trigger\",\n      attributes: {\n        id: block.id,\n        \"idyll-trigger\": block.tool,\n        enabled: String(block.metadata?.enabled !== false),\n      },\n      elements,\n    };\n  }\n}\n\n/**\n * Serialize tool block\n */\nfunction serializeToolBlock(block: ContentBlock): xml2js.Element {\n  const elements: xml2js.Element[] = [];\n\n  // Add description\n  const description = block.content\n    .map((c) => (isTextContent(c) ? c.text : \"\"))\n    .join(\"\");\n\n  elements.push({\n    type: \"element\",\n    name: \"tool:description\",\n    elements: [{ type: \"text\", text: description }],\n  });\n\n  // Add definition\n  if (block.children && block.children.length > 0) {\n    elements.push({\n      type: \"element\",\n      name: \"tool:definition\",\n      elements: block.children.map(serializeBlock),\n    });\n  }\n\n  const attributes: Record<string, string> = {\n    id: block.id,\n    title: block.props?.title as string,\n  };\n\n  if (block.props?.icon) {\n    attributes.icon = block.props.icon as string;\n  }\n\n  return {\n    type: \"element\",\n    name: \"tool\",\n    attributes,\n    elements,\n  };\n}\n\n/**\n * Serialize content block\n */\nfunction serializeContentBlock(block: ContentBlock): xml2js.Element {\n  const elements = [\n    ...serializeRichContent(block.content),\n    ...(block.children || []).map(serializeBlock),\n  ];\n\n  // Get element name from type\n  const typeToElement = Object.entries(compiled.elementToType).reduce(\n    (acc, [elem, type]) => {\n      if (!acc[type]) acc[type] = [];\n      acc[type].push(elem);\n      return acc;\n    },\n    {} as Record<string, string[]>\n  );\n\n  let elementName = typeToElement[block.type]?.[0] || \"p\";\n\n  // Special handling for headings\n  if (block.type === \"heading\" && block.props?.level) {\n    elementName = `h${block.props.level}`;\n  }\n\n  return {\n    type: \"element\",\n    name: elementName,\n    attributes: {\n      id: block.id,\n      ...block.props,\n    },\n    elements: elements.length > 0 ? elements : undefined,\n  };\n}\n\n/**\n * Serialize rich content\n */\nfunction serializeRichContent(\n  content: RichContent[]\n): (xml2js.Element | { type: \"text\"; text: string })[] {\n  return content.map((item) => {\n    if (isTextContent(item)) {\n      if (item.styles && item.styles.length > 0) {\n        // Map styles to elements\n        const styleToElement: Record<TextStyle, string> = {\n          bold: \"strong\",\n          italic: \"em\",\n          underline: \"u\",\n          strikethrough: \"s\",\n          code: \"code\",\n        };\n\n        // Wrap in style elements\n        let element: xml2js.Element = {\n          type: \"element\",\n          name: styleToElement[item.styles[0]],\n          elements: [{ type: \"text\", text: item.text }],\n        };\n\n        // Nest additional styles\n        for (let i = 1; i < item.styles.length; i++) {\n          element = {\n            type: \"element\",\n            name: styleToElement[item.styles[i]],\n            elements: [element],\n          };\n        }\n\n        return element;\n      }\n      return { type: \"text\", text: item.text };\n    }\n\n    // Handle other inline elements\n    switch (item.type) {\n      case \"mention\":\n        return {\n          type: \"element\",\n          name: `mention:${item.mentionType}`,\n          attributes: {\n            id: item.id,\n            ...(item.label && { label: item.label }),\n          },\n          elements: item.label\n            ? undefined\n            : [{ type: \"text\", text: item.label || \"\" }],\n        };\n\n      case \"variable\":\n        return {\n          type: \"element\",\n          name: \"variable\",\n          attributes: {\n            name: item.name,\n            ...(item.prompt && { prompt: item.prompt }),\n            ...(item.value && { value: item.value }),\n          },\n        };\n\n      case \"link\":\n        return {\n          type: \"element\",\n          name: \"a\",\n          attributes: { href: item.href },\n          elements: serializeRichContent(item.content),\n        };\n\n      case \"annotation\":\n        return {\n          type: \"element\",\n          name: \"annotation\",\n          attributes: {\n            ...(item.annotation.title && { title: String(item.annotation.title) }),\n            ...(item.annotation.comment && { comment: String(item.annotation.comment) }),\n            ...(item.annotation.confidence !== undefined && { confidence: String(item.annotation.confidence) }),\n          },\n          elements: serializeRichContent(item.content),\n        };\n\n      default:\n        return { type: \"text\", text: \"\" };\n    }\n  });\n}\n\n// ============================================\n// Utility Functions\n// ============================================\n\nfunction extractTextContent(element: xml2js.Element): string {\n  let text = \"\";\n\n  if (element.elements) {\n    for (const child of element.elements) {\n      if (child.type === \"text\" && child.text) {\n        text += child.text;\n      } else if (child.type === \"cdata\" && child.cdata) {\n        text += child.cdata;\n      } else if (child.type === \"element\") {\n        text += extractTextContent(child);\n      }\n    }\n  }\n\n  return text;\n}\n\nfunction createEmptyParagraph(): ContentBlock {\n  return {\n    id: uuidv4(),\n    type: \"paragraph\",\n    content: [],\n  };\n}\n\nfunction extractMetadata(\n  attrs: Record<string, unknown>\n): Record<string, unknown> | undefined {\n  const metadata: Record<string, unknown> = {};\n\n  if (attrs.version) metadata.version = attrs.version;\n  if (attrs.created) metadata.created = new Date(attrs.created as string);\n  if (attrs.modified) metadata.modified = new Date(attrs.modified as string);\n\n  return Object.keys(metadata).length > 0 ? metadata : undefined;\n}\n\nfunction serializeMetadata(\n  metadata?: Record<string, unknown>\n): Record<string, string> {\n  if (!metadata) return {};\n\n  const result: Record<string, string> = {};\n\n  if (metadata.version) result.version = String(metadata.version);\n  if (metadata.created instanceof Date)\n    result.created = metadata.created.toISOString();\n  if (metadata.modified instanceof Date)\n    result.modified = metadata.modified.toISOString();\n\n  return result;\n}\n\n/**\n * Serialize edit operation\n */\nfunction serializeEditOperation(operation: EditOperation): xml2js.Element {\n  switch (operation.type) {\n    case \"edit:attr\":\n      return {\n        type: \"element\",\n        name: \"edit:prop\",\n        attributes: {\n          \"block-id\": operation.blockId,\n          name: operation.name,\n          value: operation.value,\n        },\n      };\n\n    case \"edit:content\":\n      return {\n        type: \"element\",\n        name: \"edit:content\",\n        attributes: {\n          \"block-id\": operation.blockId,\n        },\n        elements: serializeRichContent(operation.content),\n      };\n\n    case \"insert\":\n      return {\n        type: \"element\",\n        name: \"insert\",\n        attributes: {\n          ...(operation.afterBlockId && {\n            \"after-block-id\": operation.afterBlockId,\n          }),\n          ...(operation.beforeBlockId && {\n            \"before-block-id\": operation.beforeBlockId,\n          }),\n          ...(operation.atStart && { \"at-start\": \"true\" }),\n          ...(operation.atEnd && { \"at-end\": \"true\" }),\n        },\n        elements: operation.blocks.map(serializeBlock),\n      };\n\n    case \"delete\":\n      return {\n        type: \"element\",\n        name: \"delete\",\n        attributes: {\n          \"block-id\": operation.blockId,\n        },\n      };\n\n    case \"replace\":\n      return {\n        type: \"element\",\n        name: \"replace\",\n        attributes: {\n          \"block-id\": operation.blockId,\n        },\n        elements: operation.blocks.map(serializeBlock),\n      };\n\n    default:\n      throw new Error(`Unknown operation type`);\n  }\n}\n","/**\n * Consolidated type definitions for Idyll Engine\n */\n\nimport type { MentionElement, VariableElement } from './document/ast';\n\n// ============================================\n// Validation Context\n// ============================================\n\n/**\n * Context for validating document references\n */\nexport interface ValidationContext {\n  /**\n   * Validate that a mention reference exists\n   * @param mention The mention to validate\n   * @returns True if valid, false otherwise\n   */\n  validateMention?(mention: MentionElement): boolean;\n  \n  /**\n   * Validate that a variable exists and optionally get its value\n   * @param variable The variable to validate\n   * @returns Validation result with optional value\n   */\n  validateVariable?(variable: VariableElement): {\n    valid: boolean;\n    value?: unknown;\n  };\n  \n  /**\n   * Validate that a tool exists\n   * @param toolName The tool name to validate\n   * @returns True if tool exists, false otherwise\n   */\n  validateTool?(toolName: string): boolean;\n}\n\n// ============================================\n// Execution Context\n// ============================================\n\n/**\n * Runtime context for document/agent execution\n */\nexport interface ExecutionContext {\n  /**\n   * User performing the execution\n   */\n  user: {\n    id: string;\n    name?: string;\n    email?: string;\n  };\n  \n  /**\n   * Available variables during execution\n   */\n  variables: Record<string, unknown>;\n  \n  /**\n   * Resolve a mention to its value\n   * @param mention The mention to resolve\n   * @returns The resolved value or undefined\n   */\n  resolveMention?(mention: MentionElement): unknown;\n  \n  /**\n   * Resolve a variable to its value\n   * @param variable The variable to resolve\n   * @returns The resolved value or undefined\n   */\n  resolveVariable?(variable: VariableElement): unknown;\n  \n  /**\n   * Additional metadata\n   */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Context specific to document execution\n */\nexport interface DocumentExecutionContext extends ExecutionContext {\n  /**\n   * Document being executed\n   */\n  documentId: string;\n  \n  /**\n   * Whether the user can edit the document\n   */\n  canEdit: boolean;\n}\n\n/**\n * Context specific to agent execution\n */\nexport interface AgentExecutionContext extends ExecutionContext {\n  /**\n   * Agent performing the execution\n   */\n  agentId: string;\n  \n  /**\n   * Thread ID if in a conversation\n   */\n  threadId?: string;\n  \n  /**\n   * Conversation history if available\n   */\n  messages?: Array<{\n    role: 'user' | 'assistant' | 'system';\n    content: string;\n  }>;\n}\n\n// ============================================\n// Tool Definition\n// ============================================\n\n/**\n * Definition of a tool that can be executed\n */\nexport interface ToolDefinition {\n  /**\n   * Unique tool identifier (e.g., \"documents:create\")\n   */\n  name: string;\n  \n  /**\n   * Human-readable title\n   */\n  title?: string;\n  \n  /**\n   * Tool description\n   */\n  description?: string;\n  \n  /**\n   * Whether the tool requires content/instructions\n   */\n  contentRequirement?: 'required' | 'optional' | 'disabled';\n  \n  /**\n   * Validate parameters before execution\n   * @param params The parameters to validate\n   * @returns Validation result\n   */\n  validate(params: unknown): ToolValidationResult;\n}\n\nexport type ToolValidationResult = \n  | { success: true }\n  | { success: false; errors: string[] };\n\n// ============================================\n// Tool Resolution & Execution\n// ============================================\n\n/**\n * Interface for resolving tool definitions\n */\nexport interface ToolResolver {\n  /**\n   * Resolve a tool by name\n   * @param name Tool identifier\n   * @returns Tool definition or null if not found\n   */\n  resolve(name: string): ToolDefinition | null;\n  \n  /**\n   * List all available tools\n   * @returns Array of tool names\n   */\n  list?(): string[];\n}\n\n/**\n * Interface for executing tools\n */\nexport interface ToolExecutor {\n  /**\n   * Execute a tool with given parameters\n   * @param tool Tool name\n   * @param params Tool parameters (already validated)\n   * @param context Execution context\n   * @returns Tool execution result\n   */\n  execute(\n    tool: string, \n    params: Record<string, unknown>, \n    context: ToolExecutionContext\n  ): Promise<ToolResult>;\n}\n\n/**\n * Context provided during tool execution\n */\nexport interface ToolExecutionContext {\n  /**\n   * Execution mode - where the tool is being executed from\n   */\n  mode: 'document' | 'agent';\n  \n  /**\n   * User executing the tool\n   */\n  user: {\n    id: string;\n    name?: string;\n    email?: string;\n  };\n  \n  /**\n   * Instructions/content provided with the tool call\n   */\n  instructions?: string;\n  \n  /**\n   * Document-specific context\n   */\n  document?: {\n    id: string;\n    blockId: string;\n  };\n  \n  /**\n   * Agent-specific context\n   */\n  agent?: {\n    id: string;\n    threadId?: string;\n  };\n  \n  /**\n   * Additional metadata\n   */\n  metadata?: Record<string, unknown>;\n}\n\n// ============================================\n// Tool Results\n// ============================================\n\n/**\n * Result from tool execution\n */\nexport interface ToolResult {\n  success: boolean;\n  data?: unknown;\n  error?: ToolError;\n  /**\n   * Human-readable message about the result\n   */\n  message?: string;\n}\n\nexport interface ToolError {\n  code: string;\n  message: string;\n  details?: unknown;\n}\n\n/**\n * Helper class for creating tool results\n */\nexport class ToolResponse {\n  static success(data: unknown, message?: string): ToolResult {\n    return {\n      success: true,\n      data,\n      message,\n    };\n  }\n  \n  static error(error: string | ToolError, details?: unknown): ToolResult {\n    if (typeof error === 'string') {\n      return {\n        success: false,\n        error: {\n          code: 'TOOL_ERROR',\n          message: error,\n          details,\n        },\n      };\n    }\n    return {\n      success: false,\n      error,\n    };\n  }\n  \n  static empty(): ToolResult {\n    return {\n      success: true,\n    };\n  }\n}\n\n// ============================================\n// Error Types\n// ============================================\n\n/**\n * Base error class for all engine errors\n */\nexport class IdyllEngineError extends Error {\n  constructor(\n    message: string,\n    public code: string,\n    public details?: unknown\n  ) {\n    super(message);\n    this.name = 'IdyllEngineError';\n  }\n}\n\n/**\n * Error during document parsing\n */\nexport class ParseError extends IdyllEngineError {\n  constructor(message: string, details?: unknown) {\n    super(message, 'PARSE_ERROR', details);\n    this.name = 'ParseError';\n  }\n}\n\n/**\n * Error during document validation\n */\nexport class ValidationError extends IdyllEngineError {\n  constructor(\n    message: string,\n    public errors: string[],\n    details?: unknown\n  ) {\n    super(message, 'VALIDATION_ERROR', details);\n    this.name = 'ValidationError';\n  }\n}\n\n/**\n * Error during tool execution\n */\nexport class ToolExecutionError extends IdyllEngineError {\n  constructor(\n    message: string,\n    public toolName: string,\n    public blockId?: string,\n    details?: unknown\n  ) {\n    super(message, 'TOOL_EXECUTION_ERROR', details);\n    this.name = 'ToolExecutionError';\n  }\n}\n\n/**\n * Error when a tool is not found\n */\nexport class ToolNotFoundError extends IdyllEngineError {\n  constructor(toolName: string) {\n    super(`Tool not found: ${toolName}`, 'TOOL_NOT_FOUND', { toolName });\n    this.name = 'ToolNotFoundError';\n  }\n}\n\n/**\n * Error during agent execution\n */\nexport class AgentExecutionError extends IdyllEngineError {\n  constructor(\n    message: string,\n    public agentId: string,\n    details?: unknown\n  ) {\n    super(message, 'AGENT_EXECUTION_ERROR', details);\n    this.name = 'AgentExecutionError';\n  }\n}\n\n// ============================================\n// Error Utilities\n// ============================================\n\n/**\n * Check if an error is an engine error\n */\nexport function isIdyllEngineError(error: unknown): error is IdyllEngineError {\n  return error instanceof IdyllEngineError;\n}\n\n/**\n * Format error for display\n */\nexport function formatError(error: unknown): string {\n  if (isIdyllEngineError(error)) {\n    return `${error.code}: ${error.message}`;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return String(error);\n}","/**\n * Grammar DSL Types and Builder Functions\n * \n * Provides the core types and helper functions for building grammars.\n */\n\n// ============================================\n// DSL Types\n// ============================================\n\nexport type Rule = \n  | TerminalRule\n  | SequenceRule\n  | ChoiceRule\n  | RepeatRule\n  | OptionalRule\n  | RefRule;\n\ninterface TerminalRule {\n  type: 'terminal';\n  element: string;\n  attributes?: Record<string, AttributeDef>;\n  content?: 'text' | 'rich' | 'json' | 'none';\n}\n\ninterface SequenceRule {\n  type: 'sequence';\n  rules: Rule[];\n}\n\ninterface ChoiceRule {\n  type: 'choice';\n  rules: Rule[];\n}\n\ninterface RepeatRule {\n  type: 'repeat';\n  rule: Rule;\n  min: number;\n  max: number | null; // null = unbounded\n}\n\ninterface OptionalRule {\n  type: 'optional';\n  rule: Rule;\n}\n\ninterface RefRule {\n  type: 'ref';\n  name: string;\n}\n\nexport interface AttributeDef {\n  type: 'string' | 'number' | 'boolean' | 'enum';\n  required?: boolean;\n  values?: readonly string[];\n  pattern?: RegExp;\n  validate?: (value: unknown) => string | null;\n  default?: any;\n}\n\n// ============================================\n// DSL Builder Functions\n// ============================================\n\nexport function terminal(element: string, attrs?: Record<string, AttributeDef>, content?: 'text' | 'rich' | 'json' | 'none'): TerminalRule {\n  return { type: 'terminal', element, attributes: attrs, content };\n}\n\nexport function seq(...rules: (Rule | string)[]): SequenceRule {\n  return { \n    type: 'sequence', \n    rules: rules.map(r => typeof r === 'string' ? ref(r) : r)\n  };\n}\n\nexport function choice(...rules: (Rule | string)[]): ChoiceRule {\n  return { \n    type: 'choice', \n    rules: rules.map(r => typeof r === 'string' ? ref(r) : r)\n  };\n}\n\nexport function repeat(rule: Rule | string, min = 0, max: number | null = null): RepeatRule {\n  return { \n    type: 'repeat', \n    rule: typeof rule === 'string' ? ref(rule) : rule,\n    min, \n    max \n  };\n}\n\nexport function optional(rule: Rule | string): OptionalRule {\n  return { \n    type: 'optional', \n    rule: typeof rule === 'string' ? ref(rule) : rule\n  };\n}\n\nexport function ref(name: string): RefRule {\n  return { type: 'ref', name };\n}\n\n// Shorthand helpers\nexport const zeroOrMore = (rule: Rule | string) => repeat(rule, 0, null);\nexport const oneOrMore = (rule: Rule | string) => repeat(rule, 1, null);\nexport const zeroOrOne = optional;","/**\n * Document Grammar for Idyll Documents\n * \n * Defines the structure for content documents with blocks and rich text.\n */\n\nimport { Rule, terminal, seq, choice, repeat, optional, ref, oneOrMore, zeroOrMore } from './grammar-dsl';\n\nexport const DOCUMENT_GRAMMAR: Record<string, Rule> = {\n  // Document root\n  document: seq(\n    terminal('document', { \n      id: { type: 'string', required: false },\n      version: { type: 'string', required: false },\n      created: { type: 'string', required: false },\n      modified: { type: 'string', required: false }\n    }),\n    zeroOrMore('block')\n  ),\n\n  // Blocks\n  block: choice(\n    'content-block',\n    'executable-block', \n    'tool-block'\n  ),\n\n  'content-block': choice(\n    'paragraph',\n    'heading',\n    'bullet-list-item',\n    'numbered-list-item',\n    'checklist-item',\n    'code',\n    'quote',\n    'separator',\n    'data'\n  ),\n\n  'executable-block': choice(\n    'function-call',\n    'trigger'\n  ),\n\n  // Content blocks\n  paragraph: choice(\n    terminal('p', {}, 'rich'),\n    terminal('paragraph', {}, 'rich') // legacy support\n  ),\n  \n  heading: choice(\n    terminal('h1', {}, 'rich'),\n    terminal('h2', {}, 'rich'),\n    terminal('h3', {}, 'rich'),\n    terminal('h4', {}, 'rich'),\n    terminal('h5', {}, 'rich'),\n    terminal('h6', {}, 'rich'),\n    terminal('heading', { // legacy support\n      level: { type: 'number', required: true, validate: (v: unknown) => {\n        const num = Number(v);\n        return num >= 1 && num <= 6 ? null : 'Level must be 1-6';\n      }}\n    }, 'rich')\n  ),\n\n  // List items (individual blocks, no containers)\n  'bullet-list-item': terminal('bulletlistitem', {}, 'rich'),\n  \n  'numbered-list-item': terminal('numberedlistitem', {}, 'rich'),\n  \n  'checklist-item': terminal('checklistitem', {\n    checked: { type: 'boolean', required: true }\n  }, 'rich'),\n\n  code: terminal('code', { \n    language: { type: 'string', required: false } \n  }, 'text'),\n\n  quote: terminal('quote', {\n    author: { type: 'string', required: false },\n    source: { type: 'string', required: false }\n  }, 'rich'),\n\n  separator: terminal('separator', {}, 'none'),\n  \n  data: terminal('data', {\n    title: { type: 'string', required: false }\n  }, 'text'),\n\n  // Executable blocks\n  'function-call': seq(\n    terminal('fncall', {\n      'idyll-tool': {\n        type: 'string',\n        required: true,\n        // Format: \\\"module:function\\\" or just \\\"function\\\" (e.g., \\\"demo:echo\\\", \\\"ai:analyzeText\\\", \\\"echo\\\")\n        // Module and function names MUST be valid JS identifiers\n        // For Azure Functions compatibility, transform at adapter layer:\n        // \\\"module:function\\\"  \\\"module--function\\\" (double hyphen separator)\n        pattern: /^([a-zA-Z_$][a-zA-Z0-9_$]*:)?[a-zA-Z_$][a-zA-Z0-9_$]*$/\n      },\n      modelId: { type: 'string', required: false }\n    }),\n    optional('params'),\n    optional('content'),\n    optional('result')\n  ),\n\n  trigger: seq(\n    terminal('trigger', {\n      'idyll-trigger': {\n        type: 'string',\n        required: true,\n        // Format: \\\"module:trigger\\\" or just \\\"trigger\\\" (e.g., \\\"time:schedule\\\", \\\"webhook:receive\\\", \\\"daily\\\")\n        // Module and trigger names MUST be valid JS identifiers\n        // For Azure Functions compatibility, transform at adapter layer:\n        // \\\"module:trigger\\\"  \\\"module--trigger\\\" (double hyphen separator)\n        pattern: /^([a-zA-Z_$][a-zA-Z0-9_$]*:)?[a-zA-Z_$][a-zA-Z0-9_$]*$/\n      },\n      enabled: { type: 'boolean', default: true }\n    }),\n    optional('params'),\n    optional('content')\n  ),\n\n  // Tool blocks\n  'tool-block': seq(\n    terminal('tool', {\n      title: { type: 'string', required: true },\n      icon: { type: 'string', required: false }\n    }),\n    ref('tool-description'),\n    ref('tool-definition')\n  ),\n\n  'tool-description': terminal('tool:description', {}, 'text'),\n\n  'tool-definition': seq(\n    terminal('tool:definition'),\n    zeroOrMore(choice('content-block', 'executable-block')) // no nested tools!\n  ),\n\n  // Function call children\n  params: seq(\n    terminal('params'),\n    ref('json-content')\n  ),\n\n  content: seq(\n    terminal('content'),\n    ref('rich-content')\n  ),\n\n  result: seq(\n    terminal('result'),\n    ref('json-content')\n  ),\n\n  // Content types\n  'rich-content': zeroOrMore(choice(\n    'text',\n    'styled-text',\n    'mention',\n    'variable',\n    'link',\n    'annotation',\n    'annotated-text',\n    'ai-edit-response'\n  )),\n\n  'text-content': terminal('_text', {}, 'text'), // pseudo-element for plain text\n  'json-content': terminal('_json', {}, 'json'), // pseudo-element for JSON\n\n  // Inline elements\n  'styled-text': choice(\n    seq(choice(terminal('strong'), terminal('b')), ref('rich-content')),\n    seq(choice(terminal('em'), terminal('i')), ref('rich-content')),\n    seq(choice(terminal('u'), terminal('underline')), ref('rich-content')),\n    seq(choice(terminal('s'), terminal('strike'), terminal('del')), ref('rich-content')),\n    seq(choice(terminal('code'), terminal('tt')), ref('rich-content'))\n  ),\n  \n  annotation: seq(\n    terminal('annotation', {\n      title: { type: 'string', required: false },\n      comment: { type: 'string', required: false },\n      confidence: { type: 'number', required: false }\n    }),\n    ref('rich-content')\n  ),\n\n  mention: choice(\n    terminal('mention:user', { \n      id: { type: 'string', required: true },\n      label: { type: 'string', required: false }\n    }, 'text'),\n    terminal('mention:document', { \n      id: { type: 'string', required: true },\n      label: { type: 'string', required: false }\n    }, 'text'),\n    terminal('mention:agent', { \n      id: { type: 'string', required: true },\n      label: { type: 'string', required: false }\n    }, 'text'),\n    terminal('mention:custom', {\n      id: { type: 'string', required: true },\n      type: { type: 'string', required: true },\n      label: { type: 'string', required: false }\n    }, 'text')\n  ),\n\n  variable: terminal('variable', { \n    name: { type: 'string', required: true },\n    prompt: { type: 'string', required: false },\n    value: { type: 'string', required: false }\n  }, 'none'),\n\n  link: seq(\n    terminal('a', { \n      href: { type: 'string', required: true, pattern: /^https?:\\/\\/.+/ } \n    }),\n    ref('rich-content')\n  ),\n  \n  'annotated-text': seq(\n    terminal('annotatedtext', {\n      annotation: { type: 'string', required: true }\n    }),\n    ref('rich-content')\n  ),\n  \n  'ai-edit-response': seq(\n    terminal('aieditresponse', {\n      status: { type: 'enum', values: ['pending', 'accepted', 'rejected'] as const, required: true }\n    }),\n    ref('rich-content')\n  ),\n\n  text: terminal('_text', {}, 'text'), // Raw text node\n};","/**\n * Agent Grammar for Idyll System Prompts\n * \n * Defines the structure for agent documents containing system prompts.\n */\n\nimport { Rule, terminal, seq, zeroOrMore } from './grammar-dsl';\n\nexport const AGENT_GRAMMAR: Record<string, Rule> = {\n  // Agent system prompt root\n  agent: seq(\n    terminal('agent', {\n      id: { type: 'string', required: false },\n      name: { type: 'string', required: false },\n      description: { type: 'string', required: false },\n      model: { type: 'string', required: false }\n    }),\n    zeroOrMore('block')\n  )\n};\n\n// Note: Agent grammar references 'block' from document grammar\n// This will be resolved when grammars are combined","/**\n * Diff Grammar for Idyll Document Transformations\n * \n * Defines the structure for diff operations that modify documents.\n */\n\nimport { Rule, terminal, seq, oneOrMore, choice, ref } from './grammar-dsl';\n\nexport const DIFF_GRAMMAR: Record<string, Rule> = {\n  // Diff operations root\n  diff: seq(\n    terminal('diff', {\n      targetDocument: { type: 'string', required: false },\n      timestamp: { type: 'string', required: false }\n    }),\n    oneOrMore('edit-operation')\n  ),\n\n  // Edit operations\n  'edit-operation': choice(\n    'edit-attr',\n    'edit-content',\n    'edit-params',\n    'edit-id',\n    'insert',\n    'delete',\n    'replace',\n    'move'\n  ),\n\n  'edit-attr': terminal('edit:attr', {\n    'block-id': { type: 'string', required: true },\n    name: { type: 'string', required: true },\n    value: { type: 'string', required: true }\n  }, 'none'),\n\n  'edit-content': seq(\n    terminal('edit:content', {\n      'block-id': { type: 'string', required: true }\n    }),\n    ref('rich-content')\n  ),\n\n  'edit-params': seq(\n    terminal('edit:params', {\n      'block-id': { type: 'string', required: true }\n    }),\n    ref('json-content')\n  ),\n\n  'edit-id': terminal('edit:id', {\n    'block-id': { type: 'string', required: true },\n    value: { type: 'string', required: true }\n  }, 'none'),\n\n  insert: seq(\n    terminal('insert', {\n      'after-block-id': { type: 'string', required: false },\n      'before-block-id': { type: 'string', required: false },\n      'at-start': { type: 'boolean', required: false },\n      'at-end': { type: 'boolean', required: false }\n    }),\n    oneOrMore('block')\n  ),\n\n  delete: terminal('delete', {\n    'block-id': { type: 'string', required: true }\n  }, 'none'),\n\n  replace: seq(\n    terminal('replace', {\n      'block-id': { type: 'string', required: true }\n    }),\n    oneOrMore('block')\n  ),\n\n  move: terminal('move', {\n    'block-id': { type: 'string', required: false },\n    'block-ids': { type: 'string', required: false },\n    'from-block-id': { type: 'string', required: false },\n    'to-block-id': { type: 'string', required: false },\n    'after-block-id': { type: 'string', required: false },\n    'before-block-id': { type: 'string', required: false },\n    'at-start': { type: 'boolean', required: false },\n    'at-end': { type: 'boolean', required: false }\n  }, 'none')\n};\n\n// Note: Diff grammar references 'rich-content', 'json-content', and 'block' \n// from document grammar. These will be resolved when grammars are combined","/**\n * Combined Grammar Index\n * \n * Exports all grammars and provides a unified grammar for parsing.\n */\n\nimport { Rule, choice } from './grammar-dsl';\nimport { DOCUMENT_GRAMMAR } from './document-grammar';\nimport { AGENT_GRAMMAR } from './agent-grammar';\nimport { DIFF_GRAMMAR } from './diff-grammar';\n\n// Combined grammar with all rules\nexport const GRAMMAR: Record<string, Rule> = {\n  // Root types\n  root: choice(\n    'document',\n    'agent', \n    'diff'\n  ),\n\n  // Merge all grammar rules\n  ...DOCUMENT_GRAMMAR,\n  ...AGENT_GRAMMAR,\n  ...DIFF_GRAMMAR\n};\n\n// Export individual grammars\nexport { DOCUMENT_GRAMMAR } from './document-grammar';\nexport { AGENT_GRAMMAR } from './agent-grammar';\nexport { DIFF_GRAMMAR } from './diff-grammar';\n\n// Export DSL\nexport * from './grammar-dsl';","/**\n * Grammar Compiler - Transforms grammar into usable structures\n * \n * This compiler takes our EBNF-style grammar and generates:\n * 1. Element-to-type mappings\n * 2. Validation functions\n * 3. AST type definitions\n * 4. Schema for backward compatibility\n */\n\nimport type { Rule, AttributeDef } from './grammar';\n\n// Define types locally since we removed schema.ts\nexport interface ElementSchema {\n  element: string;\n  type?: string;\n  block: boolean;\n  content?: 'text' | 'rich' | 'json' | 'none';\n  attributes?: Record<string, AttributeDef>;\n}\n\nexport interface ValidationError {\n  type: 'attribute' | 'content' | 'structure';\n  message: string;\n  path?: string;\n}\n\nexport interface CompiledGrammar {\n  // Element name -> AST type mapping\n  elementToType: Record<string, string>;\n  \n  // AST type -> element name(s) mapping\n  typeToElements: Record<string, string[]>;\n  \n  // Element name -> schema mapping (for compatibility)\n  elementSchemas: Record<string, ElementSchema>;\n  \n  // Validation functions\n  isValidElement: (element: string) => boolean;\n  isValidChild: (parentType: string, childElement: string) => boolean;\n  validateAttributes: (element: string, attrs: Record<string, unknown>) => ValidationError[];\n  \n  // Type information\n  blockTypes: Set<string>;\n  inlineElements: Set<string>;\n}\n\nexport class GrammarCompiler {\n  private grammar: Record<string, Rule>;\n  private compiled: CompiledGrammar | null = null;\n\n  constructor(grammar: Record<string, Rule>) {\n    this.grammar = grammar;\n  }\n\n  /**\n   * Compile the grammar into usable structures\n   */\n  compile(): CompiledGrammar {\n    if (this.compiled) return this.compiled;\n\n    const elementToType: Record<string, string> = {};\n    const typeToElements: Record<string, string[]> = {};\n    const elementSchemas: Record<string, ElementSchema> = {};\n    const blockTypes = new Set<string>();\n    const inlineElements = new Set<string>();\n\n    // First pass: collect all terminals and their types\n    const terminals = this.collectTerminals();\n    \n    // Build element mappings\n    for (const [ruleName, terminal] of terminals) {\n      const element = terminal.element;\n      if (element.startsWith('_')) continue; // Skip pseudo-elements\n\n      // Determine AST type\n      const astType = this.inferAstType(element, ruleName);\n      \n      // Element -> Type mapping\n      elementToType[element] = astType;\n      \n      // Type -> Elements mapping\n      if (!typeToElements[astType]) {\n        typeToElements[astType] = [];\n      }\n      typeToElements[astType].push(element);\n\n      // Build schema\n      elementSchemas[element] = {\n        element: element,\n        type: astType,\n        block: this.isBlockRule(ruleName),\n        attributes: terminal.attributes,\n        content: terminal.content as 'text' | 'rich' | 'json' | 'none' | undefined,\n      };\n\n      // Classify as block or inline\n      if (this.isBlockRule(ruleName)) {\n        blockTypes.add(astType);\n      } else if (this.isInlineRule(ruleName)) {\n        inlineElements.add(element);\n      }\n    }\n\n    // Build validation functions\n    const isValidElement = (element: string) => element in elementToType;\n    \n    const isValidChild = (parentType: string, childElement: string) => {\n      // Find rules that define valid children for this parent type\n      const rule = this.findRuleByType(parentType);\n      if (!rule) return false;\n      \n      return this.isValidInContext(rule, childElement);\n    };\n\n    const validateAttributes = (element: string, attrs: Record<string, unknown>) => {\n      const schema = elementSchemas[element];\n      if (!schema || !schema.attributes) return [];\n      \n      return this.validateAttrs(attrs, schema.attributes, element);\n    };\n\n    this.compiled = {\n      elementToType,\n      typeToElements,\n      elementSchemas,\n      isValidElement,\n      isValidChild,\n      validateAttributes,\n      blockTypes,\n      inlineElements,\n    };\n\n    return this.compiled;\n  }\n\n  /**\n   * Collect all terminal rules with their contexts\n   */\n  private collectTerminals(): Map<string, { element: string; attributes?: Record<string, AttributeDef>; content?: string }> {\n    const terminals = new Map();\n    const visited = new Set<string>();\n\n    const visit = (ruleName: string, rule: Rule) => {\n      // Avoid infinite recursion\n      const key = `${ruleName}:${JSON.stringify(rule)}`;\n      if (visited.has(key)) return;\n      visited.add(key);\n\n      switch (rule.type) {\n        case 'terminal':\n          terminals.set(ruleName, {\n            element: rule.element,\n            attributes: rule.attributes,\n            content: rule.content,\n          });\n          break;\n\n        case 'choice':\n        case 'sequence':\n          rule.rules.forEach((r, i) => {\n            if (r.type === 'ref') {\n              visit(r.name, this.grammar[r.name]);\n            } else {\n              visit(`${ruleName}[${i}]`, r);\n            }\n          });\n          break;\n\n        case 'repeat':\n        case 'optional':\n          if (rule.rule.type === 'ref') {\n            visit(rule.rule.name, this.grammar[rule.rule.name]);\n          } else {\n            visit(`${ruleName}:inner`, rule.rule);\n          }\n          break;\n\n        case 'ref':\n          if (this.grammar[rule.name]) {\n            visit(rule.name, this.grammar[rule.name]);\n          }\n          break;\n      }\n    };\n\n    // Start from all top-level rules\n    for (const [name, rule] of Object.entries(this.grammar)) {\n      visit(name, rule);\n    }\n\n    return terminals;\n  }\n\n  /**\n   * Infer AST type from element name and rule context\n   */\n  private inferAstType(element: string, ruleName: string): string {\n    // Special cases\n    const typeMap: Record<string, string> = {\n      'p': 'paragraph',\n      'paragraph': 'paragraph',\n      'h1': 'heading',\n      'h2': 'heading',\n      'h3': 'heading',\n      'h4': 'heading',\n      'h5': 'heading',\n      'h6': 'heading',\n      'heading': 'heading',\n      'fncall': 'function_call',\n      'bulletlistitem': 'bulletListItem',\n      'numberedlistitem': 'numberedListItem',\n      'checklistitem': 'checklistItem',\n      'tool:description': '_tool_description',\n      'tool:definition': '_tool_definition',\n    };\n\n    return typeMap[element] || element.replace(/[:-]/g, '_');\n  }\n\n  /**\n   * Check if a rule represents a block element\n   */\n  private isBlockRule(ruleName: string): boolean {\n    // Check if this rule is referenced by block-level rules\n    return ruleName.includes('block') || \n           ruleName === 'paragraph' ||\n           ruleName === 'heading' ||\n           ruleName === 'list' ||\n           ruleName === 'code' ||\n           ruleName === 'quote' ||\n           ruleName === 'separator' ||\n           ruleName === 'tool-block';\n  }\n\n  /**\n   * Check if a rule represents an inline element\n   */\n  private isInlineRule(ruleName: string): boolean {\n    return ruleName.includes('styled-text') ||\n           ruleName === 'mention' ||\n           ruleName === 'variable' ||\n           ruleName === 'link' ||\n           ruleName === 'text';\n  }\n\n  /**\n   * Find a rule that produces the given AST type\n   */\n  private findRuleByType(astType: string): Rule | null {\n    // This is a simplified version - in practice we'd need a more\n    // sophisticated mapping from AST types back to grammar rules\n    const ruleMap: Record<string, string> = {\n      'tool': 'tool-block',\n      'list': 'list',\n      'function_call': 'function-call',\n      'trigger': 'trigger',\n    };\n\n    const ruleName = ruleMap[astType];\n    return ruleName ? this.grammar[ruleName] : null;\n  }\n\n  /**\n   * Check if an element is valid in a given context\n   */\n  private isValidInContext(rule: Rule, element: string): boolean {\n    switch (rule.type) {\n      case 'terminal':\n        return rule.element === element;\n\n      case 'choice':\n        return rule.rules.some(r => this.isValidInContext(r, element));\n\n      case 'sequence':\n        // Check all parts of sequence\n        return rule.rules.some(r => this.isValidInContext(r, element));\n\n      case 'repeat':\n      case 'optional':\n        return this.isValidInContext(rule.rule, element);\n\n      case 'ref':\n        const referenced = this.grammar[rule.name];\n        return referenced ? this.isValidInContext(referenced, element) : false;\n\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Validate attributes against schema\n   */\n  private validateAttrs(\n    attrs: Record<string, unknown>,\n    schema: Record<string, AttributeDef>,\n    element: string\n  ): ValidationError[] {\n    const errors: ValidationError[] = [];\n\n    // Check required attributes\n    for (const [name, def] of Object.entries(schema)) {\n      if (def.required && !(name in attrs)) {\n        errors.push({\n          type: 'attribute',\n          path: `${element}@${name}`,\n          message: `Required attribute missing: ${name}`,\n        });\n      }\n    }\n\n    // Validate present attributes\n    for (const [name, value] of Object.entries(attrs)) {\n      const def = schema[name];\n      if (!def) continue; // Unknown attributes allowed\n\n      // Type validation\n      if (def.type === 'enum' && def.values && !def.values.includes(value as string)) {\n        errors.push({\n          type: 'attribute',\n          path: `${element}@${name}`,\n          message: `Invalid value: must be one of ${def.values.join(', ')}`,\n        });\n      }\n\n      // Pattern validation\n      if (def.pattern && typeof value === 'string' && !def.pattern.test(value)) {\n        errors.push({\n          type: 'attribute',\n          path: `${element}@${name}`,\n          message: `Invalid format for ${name}`,\n        });\n      }\n\n      // Custom validation\n      if (def.validate) {\n        const error = def.validate(value);\n        if (error) {\n          errors.push({\n            type: 'attribute',\n            path: `${element}@${name}`,\n            message: error,\n          });\n        }\n      }\n    }\n\n    return errors;\n  }\n\n  /**\n   * Generate TypeScript AST types from grammar\n   */\n  generateTypes(): string {\n    const compiled = this.compile();\n    const types: string[] = [];\n\n    // Generate block type union\n    const blockTypeNames = Array.from(compiled.blockTypes)\n      .map(t => `'${t}'`)\n      .join(' | ');\n    types.push(`export type BlockType = ${blockTypeNames};`);\n\n    // Generate element mappings\n    types.push('\\nexport const ELEMENT_TO_TYPE = {');\n    for (const [element, type] of Object.entries(compiled.elementToType)) {\n      types.push(`  '${element}': '${type}',`);\n    }\n    types.push('} as const;');\n\n    return types.join('\\n');\n  }\n}","/**\n * Document Executor for Idyllic Engine\n * \n * Handles execution of executable blocks within documents,\n * maintaining execution state and providing context to tools.\n */\n\nimport { z } from 'zod';\nimport type { \n  IdyllDocument, \n  Block, \n  ExecutableBlock, \n  RichContent \n} from './ast';\nimport type {\n  ExecutionState,\n  ExecutionReport,\n  ExecutionOptions,\n  BlockExecutionResult,\n  BlockExecutionContext,\n  BlockExecutionError,\n  ExecutionMetadata,\n  ExecutionRequest,\n} from './execution-types';\n\nexport class DocumentExecutor<TApi = any> {\n  private options: ExecutionOptions<TApi>;\n  \n  constructor(options: ExecutionOptions<TApi>) {\n    this.options = {\n      stopOnError: false,\n      timeout: 30000,\n      ...options,\n    };\n  }\n  \n  /**\n   * Execute a single block or entire document\n   */\n  async execute(request: ExecutionRequest): Promise<ExecutionReport> {\n    if (request.mode === 'single') {\n      return this.executeSingleBlock(request.document, request.blockId);\n    } else {\n      return this.executeDocument(request.document);\n    }\n  }\n  \n  /**\n   * Execute all executable blocks in a document\n   */\n  async executeDocument(document: IdyllDocument): Promise<ExecutionReport> {\n    const startTime = new Date();\n    const state: ExecutionState = new Map();\n    \n    // Find all executable blocks\n    const executableBlocks = this.findExecutableBlocks(document.blocks);\n    const total = executableBlocks.length;\n    \n    // Execute blocks sequentially\n    for (let i = 0; i < executableBlocks.length; i++) {\n      const block = executableBlocks[i];\n      \n      // Progress callback\n      this.options.onProgress?.(block.id, i + 1, total);\n      \n      // Create context for this block\n      const context: BlockExecutionContext & { api?: TApi } = {\n        currentBlockId: block.id,\n        previousResults: new Map(state), // Copy current state\n        document,\n        api: this.options.api,\n      };\n      \n      // Execute the block\n      const result = await this.executeBlock(block, context);\n      state.set(block.id, result);\n      \n      // Stop on error if requested\n      if (!result.success && this.options.stopOnError) {\n        break;\n      }\n    }\n    \n    const endTime = new Date();\n    \n    // Calculate metadata\n    const metadata: ExecutionMetadata = {\n      startTime,\n      endTime,\n      totalDuration: endTime.getTime() - startTime.getTime(),\n      blocksExecuted: state.size,\n      blocksSucceeded: Array.from(state.values()).filter(r => r.success).length,\n      blocksFailed: Array.from(state.values()).filter(r => !r.success).length,\n    };\n    \n    return { blocks: state, metadata };\n  }\n  \n  /**\n   * Execute a single block by ID\n   */\n  async executeSingleBlock(\n    document: IdyllDocument, \n    blockId: string\n  ): Promise<ExecutionReport> {\n    const startTime = new Date();\n    const state: ExecutionState = new Map();\n    \n    // Find the block\n    const block = this.findBlockById(document.blocks, blockId);\n    if (!block) {\n      throw new Error(`Block with ID ${blockId} not found`);\n    }\n    \n    if (!this.isExecutableBlock(block)) {\n      throw new Error(`Block ${blockId} is not executable`);\n    }\n    \n    // Build context with previous results (all blocks before this one)\n    const previousResults = this.getPreviousResults(document, blockId);\n    \n    const context: BlockExecutionContext & { api?: TApi } = {\n      currentBlockId: blockId,\n      previousResults,\n      document,\n      api: this.options.api,\n    };\n    \n    // Execute the block\n    const result = await this.executeBlock(block as ExecutableBlock, context);\n    state.set(blockId, result);\n    \n    const endTime = new Date();\n    \n    const metadata: ExecutionMetadata = {\n      startTime,\n      endTime,\n      totalDuration: endTime.getTime() - startTime.getTime(),\n      blocksExecuted: 1,\n      blocksSucceeded: result.success ? 1 : 0,\n      blocksFailed: result.success ? 0 : 1,\n    };\n    \n    return { blocks: state, metadata };\n  }\n  \n  /**\n   * Execute a single executable block\n   */\n  private async executeBlock(\n    block: ExecutableBlock,\n    context: BlockExecutionContext & { api?: TApi }\n  ): Promise<BlockExecutionResult> {\n    const startTime = Date.now();\n    \n    try {\n      // Resolve the tool\n      const tool = this.options.tools[block.tool];\n      if (!tool) {\n        throw new Error(`Tool not found: ${block.tool}`);\n      }\n      \n      // Validate parameters\n      let validatedParams: any;\n      try {\n        validatedParams = tool.schema.parse(block.parameters);\n      } catch (error) {\n        if (error instanceof z.ZodError) {\n          throw new Error(`Invalid parameters: ${error.errors.map(e => e.message).join(', ')}`);\n        }\n        throw error;\n      }\n      \n      // Extract content as string\n      const content = this.extractContent(block.instructions);\n      \n      // Execute with timeout\n      const timeoutPromise = new Promise((_, reject) => {\n        setTimeout(() => reject(new Error('Execution timeout')), this.options.timeout);\n      });\n      \n      const data = await Promise.race([\n        tool.execute(validatedParams, content, context),\n        timeoutPromise,\n      ]);\n      \n      return {\n        success: true,\n        data,\n        duration: Date.now() - startTime,\n        timestamp: new Date(),\n      };\n      \n    } catch (error) {\n      const errorObj: BlockExecutionError = {\n        message: error instanceof Error ? error.message : String(error),\n        code: 'EXECUTION_ERROR',\n        details: error,\n      };\n      \n      return {\n        success: false,\n        error: errorObj,\n        duration: Date.now() - startTime,\n        timestamp: new Date(),\n      };\n    }\n  }\n  \n  /**\n   * Find all executable blocks in document\n   */\n  private findExecutableBlocks(blocks: Block[]): ExecutableBlock[] {\n    const executable: ExecutableBlock[] = [];\n    \n    for (const block of blocks) {\n      if (this.isExecutableBlock(block)) {\n        executable.push(block as ExecutableBlock);\n      }\n      \n      // Check children recursively\n      if ('children' in block && block.children) {\n        executable.push(...this.findExecutableBlocks(block.children));\n      }\n    }\n    \n    return executable;\n  }\n  \n  /**\n   * Find a block by ID\n   */\n  private findBlockById(blocks: Block[], id: string): Block | null {\n    for (const block of blocks) {\n      if (block.id === id) {\n        return block;\n      }\n      \n      // Check children\n      if ('children' in block && block.children) {\n        const found = this.findBlockById(block.children, id);\n        if (found) return found;\n      }\n    }\n    \n    return null;\n  }\n  \n  /**\n   * Get results from all blocks before the given block\n   */\n  private getPreviousResults(document: IdyllDocument, beforeBlockId: string): ExecutionState {\n    const results: ExecutionState = new Map();\n    const executableBlocks = this.findExecutableBlocks(document.blocks);\n    \n    // Find all blocks before the target block\n    for (const block of executableBlocks) {\n      if (block.id === beforeBlockId) {\n        break;\n      }\n      // Note: We don't have actual results in this case, \n      // this would be populated from prior execution\n      // For now, return empty state\n    }\n    \n    return results;\n  }\n  \n  /**\n   * Check if a block is executable\n   */\n  private isExecutableBlock(block: Block): boolean {\n    return block.type === 'function_call' || block.type === 'trigger';\n  }\n  \n  /**\n   * Extract text content from rich content\n   */\n  private extractContent(content?: RichContent[]): string {\n    if (!content) return '';\n    \n    return content\n      .map(item => {\n        if ('text' in item) {\n          return item.text;\n        }\n        return '';\n      })\n      .join('');\n  }\n}","/**\n * Tool Registry for Idyllic Engine\n * \n * Provides utilities for managing and creating tool registries\n * with proper type safety and validation.\n */\n\nimport { z } from 'zod';\nimport type { ToolRegistry, ToolDefinition, BlockExecutionContext } from './execution-types';\n\n/**\n * Create a type-safe tool registry\n */\nexport function createToolRegistry<TApi = any>(\n  tools: ToolRegistry<TApi>\n): ToolRegistry<TApi> {\n  return tools;\n}\n\n/**\n * Define a single tool with type inference\n */\nexport function defineTool<TParams = any, TApi = any>(\n  definition: {\n    schema: z.ZodSchema<TParams>;\n    execute: (params: TParams, content: string, context: BlockExecutionContext & { api?: TApi }) => Promise<any> | any;\n    description?: string;\n  }\n): ToolDefinition<TParams, TApi> {\n  return definition;\n}\n\n/**\n * Merge multiple tool registries\n */\nexport function mergeToolRegistries<TApi = any>(\n  ...registries: ToolRegistry<TApi>[]\n): ToolRegistry<TApi> {\n  return registries.reduce((merged, registry) => {\n    return { ...merged, ...registry };\n  }, {} as ToolRegistry<TApi>);\n}\n\n/**\n * Create a tool registry from a simple function map\n * (for quick testing without schemas)\n */\nexport function createSimpleRegistry<TApi = any>(\n  tools: Record<string, (params: any, content: string, context?: BlockExecutionContext & { api?: TApi }) => any>\n): ToolRegistry<TApi> {\n  const registry: ToolRegistry<TApi> = {};\n  \n  for (const [name, fn] of Object.entries(tools)) {\n    registry[name] = {\n      schema: z.any(), // Accept any params\n      execute: (params, content, context) => fn(params, content, context),\n    };\n  }\n  \n  return registry;\n}","/**\n * Tool naming utilities for Idyll Engine\n * \n * Handles transformation between Idyll tool names (module:function) \n * and external platform requirements.\n */\n\n/**\n * Transform Idyll tool name to Azure function name\n * \"module:function\"  \"module--function\"\n * \"function\"  \"function\" (no module)\n */\nexport function toAzureFunctionName(idyllToolName: string): string {\n  return idyllToolName.replace(':', '--');\n}\n\n/**\n * Transform Azure function name back to Idyll tool name\n * \"module--function\"  \"module:function\"\n * \"function\"  \"function\" (no module)\n */\nexport function fromAzureFunctionName(azureFunctionName: string): string {\n  // Double hyphen is our separator\n  if (azureFunctionName.includes('--')) {\n    return azureFunctionName.replace('--', ':');\n  }\n  // No separator means no module namespace\n  return azureFunctionName;\n}\n\n/**\n * Validate that a tool name follows Idyll conventions\n * Must be valid JS identifiers: [module:]function\n */\nexport function validateToolName(toolName: string): { valid: boolean; error?: string } {\n  const pattern = /^([a-zA-Z_$][a-zA-Z0-9_$]*:)?[a-zA-Z_$][a-zA-Z0-9_$]*$/;\n  \n  if (!pattern.test(toolName)) {\n    return {\n      valid: false,\n      error: 'Tool name must be valid JS identifiers in format \"module:function\" or \"function\"'\n    };\n  }\n  \n  return { valid: true };\n}\n\n/**\n * Parse a tool name into module and function parts\n */\nexport function parseToolName(toolName: string): { module?: string; function: string } {\n  const colonIndex = toolName.indexOf(':');\n  \n  if (colonIndex === -1) {\n    return { function: toolName };\n  }\n  \n  return {\n    module: toolName.substring(0, colonIndex),\n    function: toolName.substring(colonIndex + 1)\n  };\n}\n\n/**\n * Build a tool name from module and function parts\n */\nexport function buildToolName(module: string | undefined, functionName: string): string {\n  return module ? `${module}:${functionName}` : functionName;\n}","/**\n * Document validation logic\n */\n\nimport {\n  Block,\n  IdyllDocument,\n  isExecutableBlock,\n  extractMentions,\n  extractVariables,\n  traverseBlocks,\n} from './ast';\nimport { ValidationContext, ValidationError } from '../types';\n\n// ============================================\n// Validation Types\n// ============================================\n\nexport interface ValidationResult {\n  valid: boolean;\n  errors: ValidationIssue[];\n  warnings: ValidationIssue[];\n}\n\nexport interface ValidationIssue {\n  type: 'error' | 'warning';\n  code: string;\n  message: string;\n  blockId?: string;\n  path?: string[];\n}\n\n// ============================================\n// Main Validation Function\n// ============================================\n\n/**\n * Validate a document structure and optionally its references\n */\nexport async function validateDocument(\n  document: IdyllDocument,\n  context?: ValidationContext\n): Promise<ValidationResult> {\n  const errors: ValidationIssue[] = [];\n  const warnings: ValidationIssue[] = [];\n  \n  // Phase 1: Structure validation\n  validateStructure(document, errors, warnings);\n  \n  // Phase 2: Reference validation (if context provided)\n  if (context) {\n    await validateReferences(document, context, errors, warnings);\n  }\n  \n  return {\n    valid: errors.length === 0,\n    errors,\n    warnings,\n  };\n}\n\n// ============================================\n// Structure Validation\n// ============================================\n\n/**\n * Validate document structure\n */\nfunction validateStructure(\n  document: IdyllDocument,\n  errors: ValidationIssue[],\n  warnings: ValidationIssue[]\n): void {\n  // Validate document has an ID\n  if (!document.id) {\n    errors.push({\n      type: 'error',\n      code: 'MISSING_DOCUMENT_ID',\n      message: 'Document must have an ID',\n    });\n  }\n  \n  // Validate document has blocks\n  if (!document.blocks || document.blocks.length === 0) {\n    warnings.push({\n      type: 'warning',\n      code: 'EMPTY_DOCUMENT',\n      message: 'Document has no content blocks',\n    });\n  }\n  \n  // Validate each block\n  const blockIds = new Set<string>();\n  for (const block of traverseBlocks(document.blocks)) {\n    validateBlock(block, blockIds, errors, warnings);\n  }\n}\n\n/**\n * Validate a single block\n */\nfunction validateBlock(\n  block: Block,\n  blockIds: Set<string>,\n  errors: ValidationIssue[],\n  warnings: ValidationIssue[]\n): void {\n  const blockId = block.id || 'unknown';\n  \n  // Check for duplicate IDs\n  if (block.id && blockIds.has(block.id)) {\n    errors.push({\n      type: 'error',\n      code: 'DUPLICATE_BLOCK_ID',\n      message: `Duplicate block ID: ${block.id}`,\n      blockId: block.id,\n    });\n  }\n  if (block.id) {\n    blockIds.add(block.id);\n  }\n  \n  // Validate block has required fields\n  if (!block.id) {\n    errors.push({\n      type: 'error',\n      code: 'MISSING_BLOCK_ID',\n      message: 'Block must have an ID',\n    });\n  }\n  \n  if (!block.type) {\n    errors.push({\n      type: 'error',\n      code: 'MISSING_BLOCK_TYPE',\n      message: 'Block must have a type',\n      blockId,\n    });\n    return; // Can't validate further without type\n  }\n  \n  // Validate executable blocks\n  if (isExecutableBlock(block)) {\n    if (!block.tool) {\n      errors.push({\n        type: 'error',\n        code: 'MISSING_TOOL',\n        message: 'Executable block must specify a tool',\n        blockId,\n      });\n    }\n    \n    if (!block.parameters) {\n      warnings.push({\n        type: 'warning',\n        code: 'MISSING_PARAMETERS',\n        message: 'Executable block has no parameters',\n        blockId,\n      });\n    }\n  }\n}\n\n// ============================================\n// Reference Validation\n// ============================================\n\n/**\n * Validate document references (mentions, variables, tools)\n */\nasync function validateReferences(\n  document: IdyllDocument,\n  context: ValidationContext,\n  errors: ValidationIssue[],\n  warnings: ValidationIssue[]\n): Promise<void> {\n  // Validate mentions\n  if (context.validateMention) {\n    const mentions = extractMentions(document.blocks);\n    for (const mention of mentions) {\n      if (!context.validateMention(mention)) {\n        errors.push({\n          type: 'error',\n          code: 'INVALID_MENTION',\n          message: `Invalid ${mention.mentionType} mention: ${mention.id}`,\n        });\n      }\n    }\n  }\n  \n  // Validate variables\n  if (context.validateVariable) {\n    const variables = extractVariables(document.blocks);\n    for (const variable of variables) {\n      const result = context.validateVariable(variable);\n      if (!result.valid) {\n        errors.push({\n          type: 'error',\n          code: 'INVALID_VARIABLE',\n          message: `Invalid variable: ${variable.name}`,\n        });\n      }\n    }\n  }\n  \n  // Validate tools\n  if (context.validateTool) {\n    for (const block of traverseBlocks(document.blocks)) {\n      if (isExecutableBlock(block) && block.tool) {\n        if (!context.validateTool(block.tool)) {\n          errors.push({\n            type: 'error',\n            code: 'INVALID_TOOL',\n            message: `Tool not found: ${block.tool}`,\n            blockId: block.id || 'unknown',\n          });\n        }\n      }\n    }\n  }\n}\n\n// ============================================\n// Validation Utilities\n// ============================================\n\n/**\n * Create a validation error from issues\n */\nexport function createValidationError(result: ValidationResult): ValidationError {\n  const errorMessages = result.errors.map(e => e.message);\n  return new ValidationError(\n    `Document validation failed with ${result.errors.length} error(s)`,\n    errorMessages,\n    { issues: result.errors }\n  );\n}\n\n/**\n * Format validation issues for display\n */\nexport function formatValidationIssues(issues: ValidationIssue[]): string {\n  return issues\n    .map(issue => {\n      const prefix = issue.type === 'error' ? '' : '';\n      const location = issue.blockId ? ` (block: ${issue.blockId})` : '';\n      return `${prefix} ${issue.message}${location}`;\n    })\n    .join('\\n');\n}","/**\n * Variable Resolution System for Idyllic Engine\n * \n * Handles the resolution of variables in custom tools using AI interpolation\n */\n\nimport type { Block, RichContent, VariableElement } from './ast';\nimport { isVariable, traverseBlocks } from './ast';\n\n/**\n * Variable with metadata for resolution\n */\nexport interface VariableDefinition {\n  name: string;\n  prompt?: string;\n  firstOccurrenceBlockId: string;\n  firstOccurrenceIndex: number;\n}\n\n/**\n * Context for variable resolution\n */\nexport interface VariableResolutionContext {\n  /** Agent-provided context (rich content) */\n  agentContext: string;\n  \n  /** Document context (surrounding blocks) */\n  documentContext?: string;\n  \n  /** Inherited agent context/personality */\n  inheritedContext?: Record<string, unknown>;\n}\n\n/**\n * Variable resolution result\n */\nexport interface VariableResolutionResult {\n  /** Resolved variable values */\n  variables: Map<string, string>;\n  \n  /** Any errors during resolution */\n  errors?: Array<{ variable: string; error: string }>;\n}\n\n/**\n * Extract all unique variables from blocks\n * Follows declare-once, use-many pattern\n */\nexport function extractVariableDefinitions(blocks: Block[]): VariableDefinition[] {\n  const definitions = new Map<string, VariableDefinition>();\n  const seenNames = new Set<string>();\n  \n  let globalIndex = 0;\n  \n  for (const block of traverseBlocks(blocks)) {\n    if ('content' in block && Array.isArray(block.content)) {\n      processContent(block.content, block.id);\n    }\n    \n    // Check executable block instructions\n    if ('instructions' in block && block.instructions) {\n      processContent(block.instructions, block.id);\n    }\n  }\n  \n  function processContent(content: RichContent[], blockId: string) {\n    for (const item of content) {\n      if (isVariable(item)) {\n        // First occurrence declares the variable\n        if (!seenNames.has(item.name)) {\n          seenNames.add(item.name);\n          definitions.set(item.name, {\n            name: item.name,\n            prompt: item.prompt,\n            firstOccurrenceBlockId: blockId,\n            firstOccurrenceIndex: globalIndex++,\n          });\n        }\n      } else if ('content' in item && Array.isArray(item.content)) {\n        // Recurse into nested content\n        processContent(item.content, blockId);\n      }\n    }\n  }\n  \n  return Array.from(definitions.values());\n}\n\n/**\n * Check for variable redeclaration errors\n */\nexport function checkVariableRedeclaration(blocks: Block[]): Array<{ name: string; error: string }> {\n  const errors: Array<{ name: string; error: string }> = [];\n  const declarations = new Map<string, { blockId: string; prompt?: string }>();\n  \n  for (const block of traverseBlocks(blocks)) {\n    const variables = extractVariablesFromBlock(block);\n    \n    for (const variable of variables) {\n      const existing = declarations.get(variable.name);\n      \n      if (existing) {\n        // Check if it's a redeclaration (different prompt)\n        if (variable.prompt && existing.prompt !== variable.prompt) {\n          errors.push({\n            name: variable.name,\n            error: `Variable \"${variable.name}\" redeclared with different prompt. Original: \"${existing.prompt}\", New: \"${variable.prompt}\"`,\n          });\n        }\n      } else if (variable.prompt) {\n        // First declaration with prompt\n        declarations.set(variable.name, {\n          blockId: block.id,\n          prompt: variable.prompt,\n        });\n      }\n    }\n  }\n  \n  return errors;\n}\n\n/**\n * Extract variables from a single block\n */\nfunction extractVariablesFromBlock(block: Block): VariableElement[] {\n  const variables: VariableElement[] = [];\n  \n  function extractFromContent(content: RichContent[]) {\n    for (const item of content) {\n      if (isVariable(item)) {\n        variables.push(item);\n      } else if ('content' in item && Array.isArray(item.content)) {\n        extractFromContent(item.content);\n      }\n    }\n  }\n  \n  if ('content' in block && Array.isArray(block.content)) {\n    extractFromContent(block.content);\n  }\n  \n  if ('instructions' in block && block.instructions) {\n    extractFromContent(block.instructions);\n  }\n  \n  return variables;\n}\n\n/**\n * Resolve variables using AI interpolation or fallback to mock\n */\nexport async function resolveVariables(\n  definitions: VariableDefinition[],\n  context: VariableResolutionContext\n): Promise<VariableResolutionResult> {\n  // Try to use AI resolver if available\n  try {\n    // Dynamic import to avoid circular dependencies\n    const { resolveVariablesWithAI } = await import('../agent/ai-variable-resolver');\n    return await resolveVariablesWithAI(definitions, context);\n  } catch (error) {\n    console.warn('AI variable resolver not available, using mock resolution');\n    \n    // Fall back to mock resolution\n    const variables = new Map<string, string>();\n    const errors: Array<{ variable: string; error: string }> = [];\n    \n    for (const def of definitions) {\n      try {\n        const resolvedValue = await mockResolveVariable(def, context);\n        variables.set(def.name, resolvedValue);\n      } catch (error) {\n        errors.push({\n          variable: def.name,\n          error: error instanceof Error ? error.message : 'Unknown error',\n        });\n      }\n    }\n    \n    return { variables, errors: errors.length > 0 ? errors : undefined };\n  }\n}\n\n/**\n * Mock variable resolution for testing\n * Replace with actual AI implementation\n */\nasync function mockResolveVariable(\n  definition: VariableDefinition,\n  context: VariableResolutionContext\n): Promise<string> {\n  // Simulate AI resolution based on variable name and context\n  const contextLower = context.agentContext.toLowerCase();\n  \n  switch (definition.name) {\n    case 'searchQuery':\n      if (contextLower.includes('ai breakthroughs')) {\n        return 'AI breakthroughs 2024';\n      }\n      if (contextLower.includes('machine learning')) {\n        return 'machine learning advances';\n      }\n      return 'technology news';\n      \n    case 'timeframe':\n      if (contextLower.includes('past month') || contextLower.includes('last month')) {\n        return 'past month';\n      }\n      if (contextLower.includes('past week') || contextLower.includes('last week')) {\n        return 'past week';\n      }\n      return 'recent';\n      \n    case 'focusArea':\n      if (contextLower.includes('practical')) {\n        return 'practical applications';\n      }\n      if (contextLower.includes('research')) {\n        return 'research developments';\n      }\n      return 'general overview';\n      \n    default:\n      // Use prompt as hint for resolution\n      if (definition.prompt) {\n        return `Resolved: ${definition.name} (${definition.prompt})`;\n      }\n      return `Resolved: ${definition.name}`;\n  }\n}\n\n/**\n * Apply resolved variable values to blocks\n * Updates variable elements with resolvedValue\n */\nexport function applyResolvedVariables(\n  blocks: Block[],\n  resolvedVariables: Map<string, string>\n): Block[] {\n  // Deep clone blocks to avoid mutation\n  const clonedBlocks = JSON.parse(JSON.stringify(blocks)) as Block[];\n  \n  for (const block of traverseBlocks(clonedBlocks)) {\n    if ('content' in block && Array.isArray(block.content)) {\n      block.content = applyToContent(block.content);\n    }\n    \n    if ('instructions' in block && block.instructions) {\n      block.instructions = applyToContent(block.instructions);\n    }\n  }\n  \n  function applyToContent(content: RichContent[]): RichContent[] {\n    return content.map(item => {\n      if (isVariable(item)) {\n        const resolvedValue = resolvedVariables.get(item.name);\n        if (resolvedValue !== undefined) {\n          return {\n            ...item,\n            resolvedValue,\n          } as VariableElement;\n        }\n      } else if ('content' in item && Array.isArray(item.content)) {\n        return {\n          ...item,\n          content: applyToContent(item.content),\n        };\n      }\n      return item;\n    });\n  }\n  \n  return clonedBlocks;\n}\n\n/**\n * Get interpolated text content with variables replaced\n */\nexport function interpolateContent(\n  content: RichContent[],\n  resolvedVariables: Map<string, string>\n): string {\n  let result = '';\n  \n  for (const item of content) {\n    if (item.type === 'text') {\n      result += item.text;\n    } else if (isVariable(item)) {\n      const value = resolvedVariables.get(item.name);\n      result += value || `{{${item.name}}}`;\n    } else if ('content' in item && Array.isArray(item.content)) {\n      result += interpolateContent(item.content, resolvedVariables);\n    }\n  }\n  \n  return result;\n}","/**\n * Custom Tool Executor for Idyllic Engine\n * \n * Executes custom tools defined with <tool> blocks, handling\n * variable resolution and multi-step execution\n */\n\nimport type { \n  Block, \n  ContentBlock, \n  ExecutableBlock, \n  IdyllDocument \n} from './ast';\nimport { isExecutableBlock, getExecutableBlocks } from './ast';\nimport type { \n  ToolExecutionContext, \n  ExecutionOptions,\n  BlockExecutionResult \n} from './execution-types';\nimport { DocumentExecutor } from './executor';\nimport {\n  extractVariableDefinitions,\n  checkVariableRedeclaration,\n  resolveVariables,\n  applyResolvedVariables,\n  interpolateContent,\n  type VariableResolutionContext,\n} from './variable-resolution';\n\n/**\n * Options for custom tool execution\n */\nexport interface CustomToolExecutionOptions<TApi = any> extends ExecutionOptions<TApi> {\n  /** Agent context provided when invoking the tool */\n  agentContext: string;\n  \n  /** Inherited context from agent */\n  inheritedContext?: Record<string, unknown>;\n}\n\n/**\n * Execute a custom tool defined as a ContentBlock\n */\nexport async function executeCustomTool<TApi = any>(\n  toolBlock: ContentBlock,\n  options: CustomToolExecutionOptions<TApi>\n): Promise<ToolExecutionContext> {\n  const startTime = Date.now();\n  \n  // Validate it's a tool block\n  if (toolBlock.type !== 'tool') {\n    throw new Error('Block is not a tool');\n  }\n  \n  const toolName = (toolBlock.props?.title as string) || 'Unnamed Tool';\n  \n  // Get tool definition blocks (children)\n  const definitionBlocks = toolBlock.children || [];\n  \n  // Check for variable redeclaration errors\n  const redeclarationErrors = checkVariableRedeclaration(definitionBlocks);\n  if (redeclarationErrors.length > 0) {\n    throw new Error(\n      `Variable redeclaration errors: ${redeclarationErrors.map(e => e.error).join('; ')}`\n    );\n  }\n  \n  // Extract variable definitions\n  const variableDefinitions = extractVariableDefinitions(definitionBlocks);\n  \n  // Resolve variables\n  const resolutionContext: VariableResolutionContext = {\n    agentContext: options.agentContext,\n    inheritedContext: options.inheritedContext,\n  };\n  \n  const resolutionResult = await resolveVariables(variableDefinitions, resolutionContext);\n  \n  if (resolutionResult.errors) {\n    console.warn('Variable resolution errors:', resolutionResult.errors);\n  }\n  \n  // Apply resolved variables to blocks\n  const blocksWithVariables = applyResolvedVariables(\n    definitionBlocks,\n    resolutionResult.variables\n  );\n  \n  // Interpolate content in executable blocks\n  const interpolatedBlocks = interpolateExecutableBlocks(\n    blocksWithVariables,\n    resolutionResult.variables\n  );\n  \n  // Create a document for execution\n  const executionDocument: IdyllDocument = {\n    id: `tool-exec-${Date.now()}`,\n    blocks: interpolatedBlocks,\n  };\n  \n  // Execute using DocumentExecutor\n  const executor = new DocumentExecutor(options);\n  const report = await executor.execute({\n    mode: 'document',\n    document: executionDocument,\n    options,\n  });\n  \n  // Build execution context\n  const executionContext: ToolExecutionContext = {\n    variables: resolutionResult.variables,\n    blocks: report.blocks,\n    metadata: {\n      toolName,\n      duration: Date.now() - startTime,\n      blocksExecuted: report.metadata.blocksExecuted,\n      blocksSucceeded: report.metadata.blocksSucceeded,\n      blocksFailed: report.metadata.blocksFailed,\n    },\n    toolDefinition: toolBlock,\n  };\n  \n  return executionContext;\n}\n\n/**\n * Interpolate variables in executable block content\n */\nfunction interpolateExecutableBlocks(\n  blocks: Block[],\n  resolvedVariables: Map<string, string>\n): Block[] {\n  return blocks.map(block => {\n    if (isExecutableBlock(block) && block.instructions) {\n      // Interpolate the instructions to create the content string\n      const interpolatedContent = interpolateContent(\n        block.instructions,\n        resolvedVariables\n      );\n      \n      // Return a modified block with interpolated content\n      // Note: We're modifying the instructions to be a simple text content\n      // In a real implementation, we might want to preserve the structure\n      return {\n        ...block,\n        instructions: [{\n          type: 'text',\n          text: interpolatedContent,\n        }],\n      } as ExecutableBlock;\n    }\n    \n    // Recursively handle children\n    if ('children' in block && block.children) {\n      return {\n        ...block,\n        children: interpolateExecutableBlocks(block.children, resolvedVariables),\n      };\n    }\n    \n    return block;\n  });\n}\n\n/**\n * Extract relevant result from tool execution context\n * This would be used by the subprocess to return only what's needed\n */\nexport function extractRelevantResult(\n  context: ToolExecutionContext,\n  extractionHint?: string\n): unknown {\n  // Get the last successful result by default\n  const results = Array.from(context.blocks.values());\n  const lastSuccess = results\n    .reverse()\n    .find(r => r.success);\n  \n  if (lastSuccess) {\n    return lastSuccess.data;\n  }\n  \n  // If no successful results, return error summary\n  const errors = results\n    .filter(r => !r.success)\n    .map(r => r.error?.message || 'Unknown error');\n  \n  return {\n    success: false,\n    errors,\n    toolName: context.metadata.toolName,\n  };\n}\n\n/**\n * Parse custom tool from document\n */\nexport function parseCustomTool(document: IdyllDocument): ContentBlock | null {\n  for (const block of document.blocks) {\n    if ('type' in block && block.type === 'tool') {\n      return block as ContentBlock;\n    }\n  }\n  return null;\n}","/**\n * Diff Application Logic for Idyll Documents\n * \n * Applies edit operations to document blocks with proper error handling.\n */\n\nimport { \n  Block, \n  EditOperation, \n  EditAttrOperation,\n  EditContentOperation,\n  EditParamsOperation,\n  EditIdOperation,\n  InsertOperation,\n  DeleteOperation,\n  ReplaceOperation,\n  MoveOperation,\n  RichContent \n} from './ast';\nimport { v4 as uuidv4 } from 'uuid';\n\nexport interface DiffResult {\n  success: boolean;\n  blocks?: Block[];\n  error?: string;\n}\n\n/**\n * Apply a list of edit operations to document blocks\n */\nexport function applyDiff(blocks: Block[], operations: EditOperation[]): DiffResult {\n  try {\n    let result = [...blocks];\n\n    for (const operation of operations) {\n      switch (operation.type) {\n        case 'edit:attr':\n          result = applyEditAttr(result, operation);\n          break;\n\n        case 'edit:content':\n          result = applyEditContent(result, operation);\n          break;\n\n        case 'edit:params':\n          result = applyEditParams(result, operation);\n          break;\n\n        case 'edit:id':\n          result = applyEditId(result, operation);\n          break;\n\n        case 'insert':\n          result = applyInsert(result, operation);\n          break;\n\n        case 'delete':\n          result = applyDelete(result, operation);\n          break;\n\n        case 'replace':\n          result = applyReplace(result, operation);\n          break;\n\n        case 'move':\n          result = applyMove(result, operation);\n          break;\n\n        default:\n          throw new Error(`Unknown operation type: ${(operation as any).type}`);\n      }\n    }\n\n    return { success: true, blocks: result };\n  } catch (error) {\n    return { \n      success: false, \n      blocks,\n      error: error instanceof Error ? error.message : String(error) \n    };\n  }\n}\n\n// ============================================\n// Operation Application Functions\n// ============================================\n\nfunction applyEditAttr(blocks: Block[], op: EditAttrOperation): Block[] {\n  let found = false;\n  \n  const result = blocks.map(block => {\n    if (block.id === op.blockId) {\n      found = true;\n      return { \n        ...block, \n        props: { ...(block.props || {}), [op.name]: op.value } \n      };\n    }\n    \n    // Search in children for nested blocks (even though we prefer flat structure)\n    if ('children' in block && block.children && block.children.length > 0) {\n      const updatedChildren = applyEditAttr(block.children, op);\n      if (!found && updatedChildren !== block.children) {\n        found = true;\n      }\n      return { ...block, children: updatedChildren };\n    }\n    \n    return block;\n  });\n  \n  if (!found) {\n    throw new Error(`Block not found: ${op.blockId}`);\n  }\n  \n  return result;\n}\n\nfunction applyEditContent(blocks: Block[], op: EditContentOperation): Block[] {\n  let found = false;\n  \n  const result = blocks.map(block => {\n    if (block.id === op.blockId) {\n      found = true;\n      // Only content blocks have content property\n      if ('content' in block) {\n        return { ...block, content: op.content };\n      } else {\n        throw new Error(`Block ${op.blockId} is not a content block`);\n      }\n    }\n    \n    if ('children' in block && block.children && block.children.length > 0) {\n      const updatedChildren = applyEditContent(block.children, op);\n      if (!found && updatedChildren !== block.children) {\n        found = true;\n      }\n      return { ...block, children: updatedChildren };\n    }\n    \n    return block;\n  });\n  \n  if (!found) {\n    throw new Error(`Block not found: ${op.blockId}`);\n  }\n  \n  return result;\n}\n\nfunction applyEditParams(blocks: Block[], op: EditParamsOperation): Block[] {\n  let found = false;\n  \n  const result = blocks.map(block => {\n    if (block.id === op.blockId) {\n      found = true;\n      // Only executable blocks have parameters\n      if ('parameters' in block) {\n        return { ...block, parameters: op.params };\n      } else {\n        throw new Error(`Block ${op.blockId} is not an executable block`);\n      }\n    }\n    \n    if ('children' in block && block.children && block.children.length > 0) {\n      const updatedChildren = applyEditParams(block.children, op);\n      if (!found && updatedChildren !== block.children) {\n        found = true;\n      }\n      return { ...block, children: updatedChildren };\n    }\n    \n    return block;\n  });\n  \n  if (!found) {\n    throw new Error(`Block not found: ${op.blockId}`);\n  }\n  \n  return result;\n}\n\nfunction applyEditId(blocks: Block[], op: EditIdOperation): Block[] {\n  let found = false;\n  \n  const result = blocks.map(block => {\n    if (block.id === op.blockId) {\n      found = true;\n      return { ...block, id: op.newId };\n    }\n    \n    if ('children' in block && block.children && block.children.length > 0) {\n      const updatedChildren = applyEditId(block.children, op);\n      if (!found && updatedChildren !== block.children) {\n        found = true;\n      }\n      return { ...block, children: updatedChildren };\n    }\n    \n    return block;\n  });\n  \n  if (!found) {\n    throw new Error(`Block not found: ${op.blockId}`);\n  }\n  \n  return result;\n}\n\nfunction applyInsert(blocks: Block[], op: InsertOperation): Block[] {\n  // Validate position specification\n  const positionCount = [op.atStart, op.atEnd, op.afterBlockId, op.beforeBlockId]\n    .filter(Boolean).length;\n  \n  if (positionCount !== 1) {\n    throw new Error('Insert operation must specify exactly one position');\n  }\n  \n  // Ensure all inserted blocks have IDs\n  const blocksToInsert = op.blocks.map(block => ({\n    ...block,\n    id: block.id || uuidv4(),\n  }));\n\n  if (op.atStart) {\n    return [...blocksToInsert, ...blocks];\n  }\n\n  if (op.atEnd) {\n    return [...blocks, ...blocksToInsert];\n  }\n\n  const result: Block[] = [];\n  let inserted = false;\n\n  for (const block of blocks) {\n    if (op.beforeBlockId && block.id === op.beforeBlockId) {\n      result.push(...blocksToInsert);\n      inserted = true;\n    }\n\n    result.push(block);\n\n    if (op.afterBlockId && block.id === op.afterBlockId) {\n      result.push(...blocksToInsert);\n      inserted = true;\n    }\n  }\n\n  if (!inserted) {\n    throw new Error(`Could not find anchor block for insert operation`);\n  }\n\n  return result;\n}\n\nfunction applyDelete(blocks: Block[], op: DeleteOperation): Block[] {\n  // Remove from top level and recursively from children\n  return blocks\n    .filter(block => block.id !== op.blockId)\n    .map(block => {\n      if ('children' in block && block.children && block.children.length > 0) {\n        return { ...block, children: applyDelete(block.children, op) };\n      }\n      return block;\n    });\n}\n\nfunction applyReplace(blocks: Block[], op: ReplaceOperation): Block[] {\n  // When replacing with a single block, preserve the original ID\n  const replacementBlocks = op.blocks.map((block, index) => {\n    const newId = op.blocks.length === 1 && index === 0 ? op.blockId : (block.id || uuidv4());\n    return {\n      ...block,\n      id: newId,\n    };\n  });\n\n  const result: Block[] = [];\n  let replaced = false;\n\n  for (const block of blocks) {\n    if (block.id === op.blockId) {\n      result.push(...replacementBlocks);\n      replaced = true;\n    } else {\n      result.push(block);\n    }\n  }\n\n  if (!replaced) {\n    throw new Error(`Could not find block ${op.blockId} to replace`);\n  }\n\n  return result;\n}\n\nfunction applyMove(blocks: Block[], op: MoveOperation): Block[] {\n  // Determine what blocks to move\n  let blocksToMove: Block[] = [];\n  let remainingBlocks: Block[] = [];\n\n  if (op.blockId) {\n    // Single block move\n    const blockToMove = findBlockById(blocks, op.blockId);\n    if (!blockToMove) {\n      throw new Error(`Block not found: ${op.blockId}`);\n    }\n    blocksToMove = [blockToMove];\n    remainingBlocks = blocks.filter(b => b.id !== op.blockId);\n  } else if (op.blockIds) {\n    // Multiple blocks move\n    const ids = op.blockIds.split(',').map(id => id.trim());\n    for (const id of ids) {\n      const block = findBlockById(blocks, id);\n      if (!block) {\n        throw new Error(`Block not found: ${id}`);\n      }\n      blocksToMove.push(block);\n    }\n    remainingBlocks = blocks.filter(b => !ids.includes(b.id));\n  } else if (op.fromBlockId && op.toBlockId) {\n    // Range move\n    const fromIndex = blocks.findIndex(b => b.id === op.fromBlockId);\n    const toIndex = blocks.findIndex(b => b.id === op.toBlockId);\n    \n    if (fromIndex === -1) {\n      throw new Error(`Block not found: ${op.fromBlockId}`);\n    }\n    if (toIndex === -1) {\n      throw new Error(`Block not found: ${op.toBlockId}`);\n    }\n    \n    const startIndex = Math.min(fromIndex, toIndex);\n    const endIndex = Math.max(fromIndex, toIndex);\n    \n    blocksToMove = blocks.slice(startIndex, endIndex + 1);\n    remainingBlocks = [\n      ...blocks.slice(0, startIndex),\n      ...blocks.slice(endIndex + 1)\n    ];\n  } else {\n    throw new Error('Move operation must specify blockId, blockIds, or fromBlockId/toBlockId');\n  }\n\n  // Now insert the moved blocks at the new position\n  const insertOp: InsertOperation = {\n    type: 'insert',\n    afterBlockId: op.afterBlockId,\n    beforeBlockId: op.beforeBlockId,\n    atStart: op.atStart,\n    atEnd: op.atEnd,\n    blocks: blocksToMove\n  };\n\n  return applyInsert(remainingBlocks, insertOp);\n}\n\n// ============================================\n// Helper Functions\n// ============================================\n\nfunction findBlockById(blocks: Block[], id: string): Block | null {\n  for (const block of blocks) {\n    if (block.id === id) {\n      return block;\n    }\n    \n    if ('children' in block && block.children) {\n      const found = findBlockById(block.children, id);\n      if (found) return found;\n    }\n  }\n  \n  return null;\n}\n\n// Re-export types for convenience\nexport type { EditOperation } from './ast';","/**\n * Bidirectional converter between BlockNote and Idyllic XML formats\n * \n * Provides isomorphic conversion that preserves all data and structure.\n */\n\nimport type { \n  Block, \n  ContentBlock, \n  ExecutableBlock, \n  RichContent,\n  TextContent,\n  InlineElement,\n  ContentBlockType,\n  ExecutableBlockType\n} from './ast';\nimport { isContentBlock, isExecutableBlock } from './ast';\n\n// BlockNote type definitions (based on the kitchen sink example)\nexport interface BlockNoteBlock {\n  id: string;\n  type: string;\n  props: Record<string, any>;\n  content: BlockNoteContent[] | BlockNoteTableContent;\n  children: BlockNoteBlock[];\n}\n\nexport interface BlockNoteContent {\n  type: string;\n  text?: string;\n  styles?: Record<string, any>;\n  props?: Record<string, any>;\n}\n\nexport interface BlockNoteTableContent {\n  type: 'tableContent';\n  rows: Array<{\n    cells: Array<{\n      type: 'tableCell';\n      props: Record<string, any>;\n      content: BlockNoteContent[];\n    }>;\n  }>;\n  columnWidths: (number | null)[];\n}\n\n/**\n * Convert BlockNote document to Idyllic blocks\n */\nexport function blockNoteToIdyllic(blockNoteBlocks: BlockNoteBlock[]): Block[] {\n  return blockNoteBlocks.map(convertBlockNoteBlock);\n}\n\n/**\n * Convert Idyllic blocks to BlockNote document\n */\nexport function idyllicToBlockNote(idyllicBlocks: Block[]): BlockNoteBlock[] {\n  return idyllicBlocks.map(convertIdyllicBlock);\n}\n\n// ============================================\n// BlockNote to Idyllic Conversion\n// ============================================\n\nfunction convertBlockNoteBlock(bnBlock: BlockNoteBlock): Block {\n  const { id, type, props, content, children } = bnBlock;\n\n  // Handle executable blocks\n  if (type === 'trigger') {\n    return {\n      id,\n      type: 'trigger',\n      tool: props.trigger || '',\n      parameters: props.params ? JSON.parse(props.params) : {},\n      instructions: Array.isArray(content) ? convertBlockNoteContent(content) : [],\n      metadata: {\n        enabled: props.enabled,\n        modelId: props.modelId,\n      }\n    } as ExecutableBlock;\n  }\n\n  if (type === 'tool') {\n    // Tool blocks in BlockNote map to a special content block in Idyllic\n    return {\n      id,\n      type: 'tool',\n      content: [], // Tool description would go here\n      props: {\n        title: props.title,\n        icon: props.icon,\n        toolDefinition: props.toolDefinition\n      },\n      children: children.map(convertBlockNoteBlock)\n    } as ContentBlock;\n  }\n\n  // Handle table specially\n  if (type === 'table') {\n    return {\n      id,\n      type: 'data', // Tables map to data blocks in Idyllic\n      content: [{ type: 'text', text: JSON.stringify(content) }],\n      props: {\n        title: 'Table',\n        originalType: 'table',\n        ...props\n      },\n      children: []\n    } as ContentBlock;\n  }\n\n  // Handle functionCall blocks\n  if (type === 'functionCall') {\n    return {\n      id,\n      type: 'function_call',\n      tool: props.tool || '',\n      parameters: props.params ? JSON.parse(props.params) : {},\n      result: {\n        success: !props.error,\n        data: props.response || undefined,\n        error: props.error || undefined\n      },\n      instructions: Array.isArray(content) && content.length > 0 \n        ? convertBlockNoteContent(content) \n        : [],\n      metadata: {\n        modelId: props.modelId\n      }\n    } as ExecutableBlock;\n  }\n\n  // Map BlockNote types to Idyllic types\n  const typeMapping: Record<string, ContentBlockType> = {\n    'paragraph': 'paragraph',\n    'heading': 'heading',\n    'bulletListItem': 'bulletListItem',\n    'numberedListItem': 'numberedListItem',\n    'checkListItem': 'checklistItem',\n    'quote': 'quote',\n    'codeBlock': 'code',\n    'separator': 'separator',\n  };\n\n  const idyllicType = typeMapping[type] || 'paragraph';\n\n  // Handle content - ensure at least one empty text node\n  const idyllicContent = Array.isArray(content) && content.length > 0\n    ? convertBlockNoteContent(content)\n    : [{ type: 'text', text: '' } as TextContent];\n\n  // Build the content block\n  const block: ContentBlock = {\n    id,\n    type: idyllicType,\n    content: idyllicContent,\n    children: children.map(convertBlockNoteBlock)\n  };\n\n  // Add props if they exist\n  if (Object.keys(props).length > 0) {\n    block.props = { ...props };\n  }\n\n  return block;\n}\n\nfunction convertBlockNoteContent(content: BlockNoteContent[]): RichContent[] {\n  return content.map(item => {\n    if (item.type === 'text') {\n      const textContent: TextContent = {\n        type: 'text',\n        text: item.text || ''\n      };\n\n      // Convert BlockNote styles to Idyllic styles\n      if (item.styles && Object.keys(item.styles).length > 0) {\n        const styles = [];\n        if (item.styles.bold) styles.push('bold');\n        if (item.styles.italic) styles.push('italic');\n        if (item.styles.underline) styles.push('underline');\n        if (item.styles.strikethrough) styles.push('strikethrough');\n        if (item.styles.code) styles.push('code');\n        \n        if (styles.length > 0) {\n          textContent.styles = styles as any;\n        }\n      }\n\n      return textContent;\n    }\n\n    if (item.type === 'mention' && item.props) {\n      const mention: InlineElement = {\n        type: 'mention',\n        mentionType: mapMentionType(item.props.mentionType),\n        id: item.props.id,\n        label: item.props.label\n      };\n      return mention;\n    }\n\n    if (item.type === 'link' && item.props) {\n      const link: InlineElement = {\n        type: 'link',\n        href: item.props.href || '',\n        content: item.props.content ? convertBlockNoteContent(item.props.content) : []\n      };\n      return link;\n    }\n\n    // Fallback to text\n    return {\n      type: 'text',\n      text: JSON.stringify(item)\n    };\n  });\n}\n\nfunction mapMentionType(bnType: string): 'user' | 'document' | 'agent' | 'custom' {\n  switch (bnType) {\n    case 'user': return 'user';\n    case 'document': return 'document';\n    case 'agent': return 'agent';\n    case 'tool': return 'custom'; // Tools are custom mentions in Idyllic\n    default: return 'custom';\n  }\n}\n\n// ============================================\n// Idyllic to BlockNote Conversion\n// ============================================\n\nfunction convertIdyllicBlock(block: Block): BlockNoteBlock {\n  const { id } = block;\n\n  if (isExecutableBlock(block)) {\n    if (block.type === 'trigger') {\n      return {\n        id,\n        type: 'trigger',\n        props: {\n          trigger: block.tool,\n          params: JSON.stringify(block.parameters),\n          enabled: block.metadata?.enabled ?? true,\n          modelId: block.metadata?.modelId\n        },\n        content: block.instructions && block.instructions.length > 0 \n          ? convertIdyllicContent(block.instructions) \n          : [{ type: 'text', text: '', styles: {} }],\n        children: []\n      };\n    }\n\n    if (block.type === 'function_call') {\n      return {\n        id,\n        type: 'functionCall',\n        props: {\n          tool: block.tool,\n          params: JSON.stringify(block.parameters),\n          response: block.result?.data ? JSON.stringify(block.result.data) : '',\n          error: block.result?.error ? JSON.stringify(block.result.error) : '',\n          modelId: block.metadata?.modelId\n        },\n        content: block.instructions && block.instructions.length > 0 \n          ? convertIdyllicContent(block.instructions) \n          : [{ type: 'text', text: '', styles: {} }],\n        children: []\n      };\n    }\n  }\n\n  // Handle content blocks\n  const contentBlock = block as ContentBlock;\n  \n  // Special handling for tool blocks\n  if (contentBlock.type === 'tool') {\n    return {\n      id,\n      type: 'tool',\n      props: {\n        title: contentBlock.props?.title || 'Tool',\n        icon: contentBlock.props?.icon || '',\n        toolDefinition: contentBlock.props?.toolDefinition || ''\n      },\n      content: [],\n      children: contentBlock.children ? contentBlock.children.map(convertIdyllicBlock) : []\n    };\n  }\n\n  // Special handling for data blocks that were originally tables\n  if (contentBlock.type === 'data' && contentBlock.props?.originalType === 'table') {\n    try {\n      const firstContent = contentBlock.content[0];\n      const tableData = JSON.parse(\n        firstContent && firstContent.type === 'text' ? firstContent.text : '{}'\n      );\n      return {\n        id,\n        type: 'table',\n        props: { textColor: contentBlock.props.textColor || 'default' },\n        content: tableData,\n        children: []\n      };\n    } catch {\n      // Fall through to regular conversion\n    }\n  }\n\n  // Map Idyllic types back to BlockNote\n  const typeMapping: Record<string, string> = {\n    'paragraph': 'paragraph',\n    'heading': 'heading',\n    'bulletListItem': 'bulletListItem',\n    'numberedListItem': 'numberedListItem',\n    'checklistItem': 'checkListItem',\n    'quote': 'quote',\n    'code': 'codeBlock',\n    'separator': 'separator',\n    'data': 'paragraph', // Generic data blocks become paragraphs\n  };\n\n  const bnType = typeMapping[contentBlock.type] || 'paragraph';\n\n  // Build BlockNote props\n  const bnProps: Record<string, any> = {};\n  \n  // Standard props\n  if (bnType !== 'separator' && bnType !== 'codeBlock') {\n    bnProps.textColor = contentBlock.props?.textColor || 'default';\n    bnProps.textAlignment = contentBlock.props?.textAlignment || 'left';\n    bnProps.backgroundColor = contentBlock.props?.backgroundColor || 'default';\n  }\n\n  // Type-specific props\n  if (contentBlock.type === 'heading') {\n    bnProps.level = contentBlock.props?.level || 1;\n  } else if (contentBlock.type === 'checklistItem') {\n    bnProps.checked = contentBlock.props?.checked || false;\n  } else if (contentBlock.type === 'code') {\n    bnProps.language = contentBlock.props?.language || 'text';\n  } else if (contentBlock.type === 'separator') {\n    bnProps.text = contentBlock.props?.text || '';\n  }\n\n  // Copy any additional props\n  if (contentBlock.props) {\n    Object.keys(contentBlock.props).forEach(key => {\n      if (!bnProps[key]) {\n        bnProps[key] = contentBlock.props![key];\n      }\n    });\n  }\n\n  // Ensure content is never empty for BlockNote\n  const bnContent = convertIdyllicContent(contentBlock.content);\n  const finalContent = bnContent.length > 0 ? bnContent : [{ type: 'text', text: '', styles: {} }];\n\n  return {\n    id,\n    type: bnType,\n    props: bnProps,\n    content: finalContent,\n    children: contentBlock.children ? contentBlock.children.map(convertIdyllicBlock) : []\n  };\n}\n\nfunction convertIdyllicContent(content: RichContent[]): BlockNoteContent[] {\n  return content.map(item => {\n    if (item.type === 'text') {\n      const bnContent: BlockNoteContent = {\n        type: 'text',\n        text: item.text,\n        styles: {}\n      };\n\n      // Convert styles\n      if (item.styles) {\n        item.styles.forEach(style => {\n          bnContent.styles![style] = true;\n        });\n      }\n\n      return bnContent;\n    }\n\n    if (item.type === 'mention') {\n      return {\n        type: 'mention',\n        props: {\n          id: item.id,\n          label: item.label || '',\n          iconUrl: '',\n          mentionId: generateMentionId(),\n          parameters: '',\n          mentionType: item.mentionType === 'custom' ? 'tool' : item.mentionType\n        }\n      };\n    }\n\n    if (item.type === 'link') {\n      return {\n        type: 'link',\n        props: {\n          href: item.href,\n          content: convertIdyllicContent(item.content)\n        }\n      };\n    }\n\n    if (item.type === 'variable') {\n      // Variables become special mentions\n      return {\n        type: 'mention',\n        props: {\n          id: `var:${item.name}`,\n          label: item.name,\n          iconUrl: '',\n          mentionId: generateMentionId(),\n          parameters: '',\n          mentionType: 'custom'\n        }\n      };\n    }\n\n    if (item.type === 'annotation') {\n      // Annotations become styled text\n      const annotatedContent = convertIdyllicContent(item.content);\n      return {\n        type: 'text',\n        text: annotatedContent.map(c => c.text).join(''),\n        styles: { backgroundColor: 'yellow' }\n      };\n    }\n\n    // Fallback\n    return {\n      type: 'text',\n      text: `[${(item as any).type || 'unknown'}]`,\n      styles: {}\n    };\n  });\n}\n\nfunction generateMentionId(): string {\n  return `${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;\n}\n\n// ============================================\n// Validation and Testing\n// ============================================\n\n/**\n * Test if conversion is truly isomorphic by round-tripping\n */\nexport function testIsomorphism(original: BlockNoteBlock[]): {\n  isIsomorphic: boolean;\n  differences?: string[];\n} {\n  // Convert to Idyllic and back\n  const idyllic = blockNoteToIdyllic(original);\n  const roundTripped = idyllicToBlockNote(idyllic);\n  \n  // Compare\n  const differences: string[] = [];\n  \n  if (original.length !== roundTripped.length) {\n    differences.push(`Block count mismatch: ${original.length} vs ${roundTripped.length}`);\n  }\n  \n  // Deep comparison would go here\n  // For now, just check count\n  \n  return {\n    isIsomorphic: differences.length === 0,\n    differences\n  };\n}","/**\n * Lightweight Agent implementation for idyll-engine\n *\n * This is a clean implementation inspired by the app's Agent class\n * but without the database dependencies and app-specific logic.\n */\n\nimport { generateText, streamText, Message, CoreTool } from \"ai\";\nimport {\n  AgentConfig,\n  AgentContext,\n  AgentExecuteOptions,\n  AgentExecuteResult,\n  AgentActivity,\n} from \"./types\";\nimport { ActivityMemory } from \"./memory\";\nimport { ToolRegistry } from \"../document/tool-registry\";\nimport { BlockExecutionContext } from \"../document/execution-types\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { buildDetailedSystemPrompt } from \"./system-prompt\";\nimport { getModel } from \"./model-provider\";\nimport { extractCustomTools } from \"./custom-tools\";\nimport { mergeToolRegistries } from \"../document/tool-registry\";\nimport { compressToolResponse } from \"./response-compressor\";\nimport {\n  toAzureFunctionName,\n  fromAzureFunctionName,\n} from \"../document/tool-naming\";\n\n/**\n * Agent class for executing conversations with tools\n */\nexport class Agent {\n  private config: AgentConfig;\n  private memory: ActivityMemory;\n  private context: AgentContext;\n  private aiTools: Record<string, CoreTool> = {};\n  private currentMessages: Message[] = [];\n\n  constructor(config: AgentConfig) {\n    this.config = config;\n    this.memory = new ActivityMemory(config.memoryLimit);\n    this.context = {\n      agentId: config.document.id,\n      agentName: config.document.name,\n      model: config.document.model,\n      activities: [],\n    };\n\n    // Initialize AI tools from registry\n    this.initializeTools();\n  }\n\n  /**\n   * Initialize tools for AI SDK\n   */\n  private initializeTools() {\n    // Extract custom tools from agent document\n    const customTools = extractCustomTools(\n      this.config.document,\n      this.config.tools,\n      () => {\n        // Get the last user message as agent context\n        const lastUserMessage = this.currentMessages\n          .filter((m) => m.role === \"user\")\n          .pop();\n        return typeof lastUserMessage?.content === \"string\"\n          ? lastUserMessage.content\n          : JSON.stringify(lastUserMessage?.content || \"\");\n      }\n    );\n\n    // Merge base tools with custom tools\n    const allTools = mergeToolRegistries(this.config.tools, customTools);\n\n    // Convert all tools to AI SDK format\n    for (const [name, tool] of Object.entries(allTools)) {\n      // Transform tool name to be OpenAI-compatible using Azure adapter pattern\n      const aiToolName = toAzureFunctionName(name);\n\n      // Create AI SDK tool wrapper\n      this.aiTools[aiToolName] = {\n        description: tool.description,\n        parameters: tool.schema,\n        execute: async (params: any) => {\n          console.log(` Executing tool: ${name}`);\n\n          // Create execution context\n          const context: BlockExecutionContext = {\n            blockId: uuidv4(),\n            documentId: this.config.document.id,\n            canEdit: false,\n            user: { id: this.context.userId || \"cli-user\" },\n            mode: \"agent\",\n            agent: {\n              id: this.context.agentId,\n              name: this.context.agentName || \"CLI Agent\",\n            },\n            previousResults: new Map(),\n          };\n\n          try {\n            // Execute tool\n            const content = params.content || \"\";\n            delete params.content; // Remove content from params\n\n            const result = await tool.execute(params, content, context);\n\n            // Compress response for custom tools\n            const isCustomTool = name.startsWith(\"custom:\");\n            const finalResult = isCustomTool\n              ? await compressToolResponse({\n                  toolName: name,\n                  toolParams: params,\n                  toolContent: content,\n                  rawResponse: result,\n                  recentMessages: this.currentMessages.slice(-3),\n                })\n              : result;\n\n            if (isCustomTool) {\n              console.log(` Custom tool ${name} executed and compressed`);\n            }\n\n            // Track tool call\n            this.memory.add({\n              type: \"tool\",\n              toolCalls: [\n                {\n                  name,\n                  args: params,\n                  result: finalResult,\n                },\n              ],\n            });\n\n            return finalResult;\n          } catch (error) {\n            const errorMessage =\n              error instanceof Error ? error.message : \"Unknown error\";\n\n            // Track error\n            this.memory.add({\n              type: \"tool\",\n              toolCalls: [\n                {\n                  name,\n                  args: params,\n                },\n              ],\n              error: errorMessage,\n            });\n\n            throw error;\n          }\n        },\n      };\n    }\n  }\n\n  /**\n   * Get the system prompt with memory injection\n   */\n  private getSystemPrompt(): string {\n    const memoryContext = this.memory.formatForPrompt();\n    const toolNames = Object.keys(this.aiTools);\n\n    return buildDetailedSystemPrompt(\n      this.config.document,\n      toolNames,\n      memoryContext\n    );\n  }\n\n  /**\n   * Execute a chat message (non-streaming)\n   */\n  async chat(\n    messages: Message[],\n    options?: AgentExecuteOptions\n  ): Promise<AgentExecuteResult> {\n    // Store current messages for context\n    this.currentMessages = messages;\n\n    const userMessage = messages[messages.length - 1]?.content;\n\n    try {\n      // Add to memory\n      const activity = this.memory.add({\n        type: \"chat\",\n        userMessage:\n          typeof userMessage === \"string\"\n            ? userMessage\n            : JSON.stringify(userMessage),\n      });\n\n      const result = await generateText({\n        model: getModel(this.config.document.model),\n        system: this.getSystemPrompt(),\n        messages,\n        tools: this.aiTools,\n        toolChoice: \"auto\",\n        maxSteps: options?.maxSteps ?? 10,\n        temperature: options?.temperature ?? 0.7,\n      });\n\n      // Update activity with response\n      activity.assistantMessage = result.text;\n      activity.usage = result.usage;\n      if (result.toolCalls && result.toolCalls.length > 0) {\n        activity.toolCalls = result.toolCalls.map((tc) => ({\n          name: tc.toolName,\n          args: tc.args as Record<string, any>,\n        }));\n      }\n\n      return {\n        message: {\n          id: uuidv4(),\n          role: \"assistant\",\n          content: result.text,\n          createdAt: new Date(),\n        },\n        usage: result.usage,\n        finishReason: result.finishReason,\n      };\n    } catch (error) {\n      // Track error\n      this.memory.add({\n        type: \"chat\",\n        userMessage:\n          typeof userMessage === \"string\"\n            ? userMessage\n            : JSON.stringify(userMessage),\n        error: error instanceof Error ? error.message : \"Unknown error\",\n      });\n\n      throw error;\n    }\n  }\n\n  /**\n   * Execute a chat message (streaming)\n   * Returns streamText result that can be used with toDataStreamResponse()\n   */\n  async chatStream(\n    messages: Message[],\n    options?: AgentExecuteOptions & {\n      onChunk?: (chunk: string) => void;\n      onToolCall?: (toolName: string, args: any) => void;\n    }\n  ) {\n    const userMessage = messages[messages.length - 1]?.content;\n\n    try {\n      // Add to memory\n      const activity = this.memory.add({\n        type: \"chat\",\n        userMessage:\n          typeof userMessage === \"string\"\n            ? userMessage\n            : JSON.stringify(userMessage),\n      });\n\n      const result = await streamText({\n        model: getModel(this.config.document.model),\n        system: this.getSystemPrompt(),\n        messages,\n        tools: this.aiTools,\n        maxSteps: options?.maxSteps ?? 10,\n        temperature: options?.temperature ?? 0.7,\n        onChunk: async ({ chunk }) => {\n          if (chunk.type === \"text-delta\" && options?.onChunk) {\n            options.onChunk(chunk.textDelta);\n          }\n          if (chunk.type === \"tool-call\" && options?.onToolCall) {\n            // Transform tool name back from AI format to original format\n            const originalToolName = fromAzureFunctionName(chunk.toolName);\n            options.onToolCall(originalToolName, chunk.args);\n          }\n        },\n        onFinish: async ({ text, toolCalls, usage, finishReason }) => {\n          // Update activity when stream finishes\n          activity.assistantMessage = text;\n          if (toolCalls && toolCalls.length > 0) {\n            activity.toolCalls = toolCalls.map((tc) => ({\n              name: fromAzureFunctionName(tc.toolName),\n              args: tc.args,\n              result: tc.result,\n            }));\n          }\n        },\n      });\n\n      return result;\n    } catch (error) {\n      // Track error\n      this.memory.add({\n        type: \"chat\",\n        userMessage:\n          typeof userMessage === \"string\"\n            ? userMessage\n            : JSON.stringify(userMessage),\n        error: error instanceof Error ? error.message : \"Unknown error\",\n      });\n\n      throw error;\n    }\n  }\n\n  /**\n   * Get memory/activity history\n   */\n  getMemory(): ActivityMemory {\n    return this.memory;\n  }\n\n  /**\n   * Get agent context\n   */\n  getContext(): AgentContext {\n    return {\n      ...this.context,\n      activities: this.memory.toJSON(),\n    };\n  }\n\n  /**\n   * Clear memory\n   */\n  clearMemory(): void {\n    this.memory.clear();\n  }\n}\n","/**\n * In-memory activity tracking for agents\n */\n\nimport { formatDistanceToNow } from 'date-fns';\nimport { AgentActivity } from './types';\n\n/**\n * Simple in-memory activity store\n */\nexport class ActivityMemory {\n  private activities: AgentActivity[] = [];\n  private maxSize: number;\n\n  constructor(maxSize = 20) {\n    this.maxSize = maxSize;\n  }\n\n  /**\n   * Add an activity record\n   */\n  add(activity: Omit<AgentActivity, 'id' | 'timestamp'>): AgentActivity {\n    const record: AgentActivity = {\n      ...activity,\n      id: crypto.randomUUID(),\n      timestamp: new Date(),\n    };\n\n    this.activities.unshift(record);\n    \n    // Keep only maxSize records\n    if (this.activities.length > this.maxSize) {\n      this.activities = this.activities.slice(0, this.maxSize);\n    }\n\n    return record;\n  }\n\n  /**\n   * Get recent activities\n   */\n  getRecent(limit?: number): AgentActivity[] {\n    return limit ? this.activities.slice(0, limit) : this.activities;\n  }\n\n  /**\n   * Clear all activities\n   */\n  clear(): void {\n    this.activities = [];\n  }\n\n  /**\n   * Format activities as memory context for agent\n   */\n  formatForPrompt(limit = 10): string {\n    const recent = this.getRecent(limit);\n    \n    if (recent.length === 0) {\n      return '';\n    }\n\n    const formatted = recent.map(activity => {\n      const timeAgo = formatDistanceToNow(activity.timestamp, { addSuffix: true });\n      const parts = [`[${timeAgo}] ${activity.type}`];\n      \n      if (activity.userMessage) {\n        parts.push(`User: \"${activity.userMessage.substring(0, 100)}${activity.userMessage.length > 100 ? '...' : ''}\"`);\n      }\n      \n      if (activity.assistantMessage) {\n        parts.push(`Assistant: \"${activity.assistantMessage.substring(0, 100)}${activity.assistantMessage.length > 100 ? '...' : ''}\"`);\n      }\n      \n      if (activity.toolCalls && activity.toolCalls.length > 0) {\n        parts.push(`Tools: ${activity.toolCalls.map(tc => tc.name).join(', ')}`);\n      }\n      \n      if (activity.error) {\n        parts.push(`Error: ${activity.error}`);\n      }\n      \n      return parts.join(' | ');\n    }).join('\\n');\n\n    return `<recent_activity>\n${formatted}\n</recent_activity>`;\n  }\n\n  /**\n   * Get activities as JSON\n   */\n  toJSON(): AgentActivity[] {\n    return this.activities;\n  }\n}","/**\n * System prompt builder for agents\n * \n * Converts AgentDocument to a proper system prompt with:\n * - Background context\n * - Tool definitions\n * - Custom instructions from blocks\n */\n\nimport { AgentDocument, Block, isExecutableBlock, isTextContent } from '../document/ast';\nimport { serializeToXML } from '../document/parser-grammar';\n\n/**\n * Build system prompt from agent document\n */\nexport function buildSystemPrompt(agent: AgentDocument, availableTools: string[]): string {\n  const sections: string[] = [];\n  \n  // Agent identity\n  sections.push(`You are ${agent.name || 'an AI assistant'}.`);\n  if (agent.description) {\n    sections.push(agent.description);\n  }\n  \n  // Model info\n  sections.push(`\\nModel: ${agent.model || 'default'}`);\n  \n  // Available tools\n  if (availableTools.length > 0) {\n    sections.push(`\\nAvailable tools:\\n${availableTools.map(t => `- ${t}`).join('\\n')}`);\n  }\n  \n  // Process blocks for custom instructions and tool definitions\n  const instructions: string[] = [];\n  const customTools: string[] = [];\n  const triggers: string[] = [];\n  \n  for (const block of agent.blocks) {\n    if (block.type === 'tool') {\n      // Extract tool definition\n      const title = block.props?.title as string || 'Untitled Tool';\n      customTools.push(`Custom tool: ${title}`);\n    } else if (block.type === 'trigger') {\n      // Note triggers\n      const trigger = block.props?.trigger as string;\n      if (trigger) {\n        triggers.push(`Trigger: ${trigger}`);\n      }\n    } else if ('content' in block && block.content) {\n      // Extract text content as instructions\n      const text = extractTextFromBlock(block);\n      if (text) {\n        instructions.push(text);\n      }\n    }\n  }\n  \n  // Add custom tools section\n  if (customTools.length > 0) {\n    sections.push(`\\nCustom tools defined:\\n${customTools.join('\\n')}`);\n  }\n  \n  // Add triggers section\n  if (triggers.length > 0) {\n    sections.push(`\\nTriggers configured:\\n${triggers.join('\\n')}`);\n  }\n  \n  // Add instructions\n  if (instructions.length > 0) {\n    sections.push(`\\nInstructions:\\n${instructions.join('\\n\\n')}`);\n  }\n  \n  // Add XML context for understanding the format\n  sections.push(`\\nWhen working with documents, use the Idyllic XML format.`);\n  \n  return sections.join('\\n');\n}\n\n/**\n * Extract plain text from a block\n */\nfunction extractTextFromBlock(block: Block): string {\n  if (!('content' in block) || !block.content) {\n    return '';\n  }\n  \n  const texts: string[] = [];\n  \n  for (const content of block.content) {\n    if (isTextContent(content)) {\n      texts.push(content.text);\n    }\n  }\n  \n  return texts.join('');\n}\n\n/**\n * Create a more detailed prompt with XML examples\n */\nexport function buildDetailedSystemPrompt(\n  agent: AgentDocument, \n  availableTools: string[],\n  includeMemory?: string\n): string {\n  let prompt = buildSystemPrompt(agent, availableTools);\n  \n  // Add memory if provided\n  if (includeMemory) {\n    prompt = `${prompt}\\n\\n${includeMemory}`;\n  }\n  \n  // Add document structure explanation\n  prompt += `\\n\\n<document_format>\nDocuments are structured using XML with blocks like:\n- <p> for paragraphs\n- <h1>, <h2>, etc. for headings\n- <fncall idyll-tool=\"...\"> for tool execution\n- <variable name=\"...\" /> for variables\n- <mention:type id=\"...\">label</mention:type> for references\n</document_format>`;\n  \n  return prompt;\n}","/**\n * Custom tool extraction and execution for agents\n * \n * Extracts tool definitions from agent system prompts and\n * creates executable tools that use the custom tool executor.\n */\n\nimport { z } from 'zod';\nimport { AgentDocument, Block, ContentBlock } from '../document/ast';\nimport { ToolDefinition, ToolRegistry } from '../document/tool-registry';\nimport { executeCustomTool, parseCustomTool } from '../document/custom-tool-executor';\nimport { parseXML } from '../document/parser-grammar';\n\n/**\n * Extract custom tools from agent document\n */\nexport function extractCustomTools(\n  agentDoc: AgentDocument,\n  baseTools: ToolRegistry,\n  getAgentContext?: () => string\n): ToolRegistry {\n  const customTools: ToolRegistry = {};\n  \n  console.log(' Extracting custom tools from agent document...');\n  \n  // Find all tool blocks\n  for (const block of agentDoc.blocks) {\n    if (block.type === 'tool' && 'props' in block) {\n      console.log(' Found tool block:', JSON.stringify(block, null, 2));\n      const title = block.props?.title as string || 'Untitled Tool';\n      const icon = block.props?.icon as string;\n      \n      // Extract description from content\n      const description = extractTextContent(block);\n      \n      // Extract tool definition blocks from children\n      const definitionBlocks = extractToolDefinitionBlocks(block);\n      \n      if (definitionBlocks.length === 0) {\n        console.warn(`Tool \"${title}\" has no definition blocks`);\n        continue;\n      }\n      \n      // Convert title to valid tool name (snake_case)\n      const toolName = title\n        .toLowerCase()\n        .replace(/[^a-z0-9]+/g, '_')\n        .replace(/^_+|_+$/g, '');\n      \n      // Create the custom tool\n      customTools[`custom:${toolName}`] = {\n        description: description || `Custom tool: ${title}`,\n        schema: z.object({\n          context: z.string()\n            .describe('Relevant context to help resolve any variables in the tool')\n            .optional(),\n        }),\n        execute: async (params, content, context) => {\n          console.log(` Executing custom tool: ${title}`);\n          \n          // Create a virtual document with the tool definition\n          const toolDoc = {\n            id: `custom-tool-${toolName}`,\n            blocks: definitionBlocks,\n          };\n          \n          // Create custom tool block for execution\n          const customToolBlock: ContentBlock = {\n            id: context.blockId || 'custom-tool-exec',\n            type: 'tool',\n            content: [],\n            children: definitionBlocks,\n            props: { title, icon },\n          };\n          \n          // Build agent context from params and content\n          // The AI typically passes context in params.context or uses content\n          let agentContext = '';\n          if (params.context) {\n            agentContext = params.context;\n          } else if (content) {\n            agentContext = content;\n          } else if (getAgentContext) {\n            // Use the agent context getter if provided\n            agentContext = getAgentContext();\n          } else {\n            // Try to infer from the execution context\n            agentContext = `Tool invoked: ${title}`;\n          }\n          \n          console.log(` Agent context for variable resolution: \"${agentContext}\"`);\n          console.log(` Params:`, params);\n          console.log(` Content:`, content);\n          console.log(` GetAgentContext available:`, !!getAgentContext);\n          \n          try {\n            // Execute the custom tool\n            const executionContext = await executeCustomTool(customToolBlock, {\n              tools: baseTools,\n              agentContext: agentContext,\n            });\n            \n            // Extract the final result\n            const lastBlockId = Array.from(executionContext.blocks.keys()).pop();\n            const lastResult = lastBlockId ? executionContext.blocks.get(lastBlockId) : undefined;\n            \n            console.log(` Execution complete. Last block ID: ${lastBlockId}`);\n            console.log(` Last result:`, lastResult);\n            console.log(` All blocks:`, Array.from(executionContext.blocks.entries()));\n            \n            // Check if we have any successful results\n            const results = Array.from(executionContext.blocks.values());\n            const successfulResults = results.filter(r => r.success);\n            const failedResults = results.filter(r => !r.success);\n            \n            console.log(` Execution summary: ${successfulResults.length} successful, ${failedResults.length} failed`);\n            \n            // If we have successful results, return the full context for compression\n            if (successfulResults.length > 0) {\n              console.log(` Returning full ToolExecutionContext for compression`);\n              return executionContext;\n            }\n            \n            // If everything failed, throw the last error\n            if (lastResult && !lastResult.success) {\n              const errorMsg = typeof lastResult.error === 'string' \n                ? lastResult.error \n                : JSON.stringify(lastResult.error) || 'Tool execution failed';\n              throw new Error(errorMsg);\n            }\n            \n            // Fallback\n            return executionContext;\n          } catch (error) {\n            console.error(` Custom tool \"${title}\" failed:`, error);\n            throw error;\n          }\n        },\n      };\n    }\n  }\n  \n  return customTools;\n}\n\n/**\n * Extract text content from a block\n */\nfunction extractTextContent(block: Block): string {\n  if (!('content' in block) || !block.content) {\n    return '';\n  }\n  \n  const texts: string[] = [];\n  for (const content of block.content) {\n    if (content.type === 'text') {\n      texts.push(content.text);\n    }\n  }\n  \n  return texts.join('').trim();\n}\n\n/**\n * Extract tool definition blocks from a tool block\n * \n * Tool blocks have a structure like:\n * <tool>\n *   <tool:description>text content</tool:description>\n *   <tool:definition>\n *     <p>...</p>\n *     <fncall>...</fncall>\n *   </tool:definition>\n * </tool>\n */\nfunction extractToolDefinitionBlocks(toolBlock: Block): Block[] {\n  if (!('children' in toolBlock) || !toolBlock.children) {\n    return [];\n  }\n  \n  const definitionBlocks: Block[] = [];\n  \n  for (const child of toolBlock.children) {\n    // Look for blocks with specific types from our parser\n    if ('type' in child) {\n      // The parser converts <tool:definition> to a block with type 'tool:definition'\n      // But we need to check the actual parsed structure\n      if (child.type === 'paragraph' || child.type === 'function_call') {\n        definitionBlocks.push(child);\n      } else if ('children' in child && child.children) {\n        // Recursively extract from nested structures\n        definitionBlocks.push(...extractToolDefinitionBlocks(child));\n      }\n    }\n  }\n  \n  return definitionBlocks;\n}","/**\n * Response compression for verbose tool outputs\n * \n * Uses a mini model to intelligently extract relevant information\n * from complex tool execution contexts.\n */\n\nimport { generateText } from 'ai';\nimport { getModel } from './model-provider';\nimport { Message } from 'ai';\nimport { ToolExecutionContext } from '../document/execution-types';\n\nexport interface CompressionContext {\n  toolName: string;\n  toolParams: Record<string, any>;\n  toolContent?: string;\n  rawResponse: any;\n  recentMessages: Message[];\n}\n\n/**\n * Compress verbose tool responses using AI\n */\nexport async function compressToolResponse(\n  context: CompressionContext\n): Promise<any> {\n  // For non-complex responses, return as-is\n  if (!isComplexResponse(context.rawResponse)) {\n    console.log(` Response compressor: ${context.toolName} - No compression needed (simple response)`);\n    return context.rawResponse;\n  }\n  \n  console.log(`  Response compressor: ${context.toolName} - Compressing verbose response...`);\n  \n  // Build context summary\n  const conversationContext = context.recentMessages\n    .slice(-3) // Last 3 messages\n    .map(m => `${m.role}: ${typeof m.content === 'string' ? m.content : JSON.stringify(m.content)}`)\n    .join('\\n');\n  \n  // Format the raw response for the AI\n  const responseStr = formatResponse(context.rawResponse);\n  \n  const result = await generateText({\n    model: getModel('gpt-4.1-mini'),\n    temperature: 0, // Deterministic extraction\n    system: 'You are a response compressor. Extract only the most relevant information from tool responses. Return ONLY a clean JSON object with the essential findings.',\n    prompt: `Tool: ${context.toolName}\nParameters: ${JSON.stringify(context.toolParams, null, 2)}\n${context.toolContent ? `Content: ${context.toolContent}` : ''}\n\nRecent conversation:\n${conversationContext}\n\nVerbose tool response:\n${responseStr}\n\nExtract the key findings, results, and conclusions. Return as a clean JSON object.`,\n  });\n  \n  const originalSize = JSON.stringify(context.rawResponse).length;\n  const compressedSize = result.text.length;\n  const ratio = ((originalSize - compressedSize) / originalSize * 100).toFixed(1);\n  \n  console.log(` Response compressed: ${originalSize}  ${compressedSize} chars (${ratio}% reduction)`);\n  \n  try {\n    const parsed = JSON.parse(result.text);\n    console.log(` Compressed result:`, parsed);\n    return parsed;\n  } catch {\n    // If parsing fails, return the text response\n    console.log(` Compressed result (text):`, result.text);\n    return result.text;\n  }\n}\n\n/**\n * Check if a response is complex enough to need compression\n */\nfunction isComplexResponse(response: unknown): boolean {\n  // ToolExecutionContext is always complex\n  if (response && typeof response === 'object') {\n    if ('variables' in response && 'blocks' in response && 'metadata' in response) {\n      return true;\n    }\n  }\n  \n  // Large responses need compression\n  const size = JSON.stringify(response).length;\n  return size > 1000;\n}\n\n/**\n * Format response for AI consumption\n */\nfunction formatResponse(response: unknown): string {\n  // Special handling for ToolExecutionContext\n  if (response && typeof response === 'object' && 'blocks' in response) {\n    const ctx = response as ToolExecutionContext;\n    const parts: string[] = [];\n    \n    // Variables\n    if (ctx.variables.size > 0) {\n      parts.push('Variables resolved:');\n      ctx.variables.forEach((value, key) => {\n        parts.push(`  ${key}: ${value}`);\n      });\n    }\n    \n    // Block results\n    if (ctx.blocks.size > 0) {\n      parts.push('\\nBlock executions:');\n      ctx.blocks.forEach((result, blockId) => {\n        if (result.success) {\n          parts.push(`   ${blockId}: ${JSON.stringify(result.data)}`);\n        } else {\n          parts.push(`   ${blockId}: ${result.error}`);\n        }\n      });\n    }\n    \n    // Metadata\n    if (ctx.metadata) {\n      parts.push(`\\nExecution summary:`);\n      parts.push(`  Tool: ${ctx.metadata.toolName}`);\n      parts.push(`  Blocks executed: ${ctx.metadata.blocksExecuted}`);\n      parts.push(`  Succeeded: ${ctx.metadata.blocksSucceeded}`);\n      parts.push(`  Failed: ${ctx.metadata.blocksFailed}`);\n    }\n    \n    return parts.join('\\n');\n  }\n  \n  // Default formatting\n  return JSON.stringify(response, null, 2);\n}","/**\n * @idyllic-labs/idyll-engine\n * \n * Document execution engine for Idyllic\n */\n\n// Document AST types\nexport * from './document/ast';\n\n// Document parsing and serialization\nexport { parseXML, serializeToXML } from './document/parser-grammar';\n\n// Document execution\nexport { DocumentExecutor } from './document/executor';\nexport * from './document/execution-types';\nexport { createToolRegistry, defineTool, mergeToolRegistries, createSimpleRegistry } from './document/tool-registry';\n\n// Tool naming utilities\nexport { \n  toAzureFunctionName, \n  fromAzureFunctionName, \n  validateToolName, \n  parseToolName, \n  buildToolName \n} from './document/tool-naming';\n\n// Document validation\nexport { validateDocument, formatValidationIssues } from './document/validator';\n\n// Legacy types (for backward compatibility)\nexport { \n  type ValidationContext,\n  type ExecutionContext,\n  type ToolResult,\n  type ToolResolver,\n  type ToolExecutor as LegacyToolExecutor,\n  type ToolDefinition as LegacyToolDefinition,\n} from './types';\n\n// Grammar system (for advanced usage)\nexport { GRAMMAR } from './document/grammar';\nexport { GrammarCompiler } from './document/grammar-compiler';\n\n// Variable resolution system\nexport * from './document/variable-resolution';\n\n// Custom tool execution\nexport * from './document/custom-tool-executor';\n\n// Diff system\nexport { applyDiff } from './document/diff-applier';\nexport type { DiffResult } from './document/diff-applier';\n\n// BlockNote converter\nexport { blockNoteToIdyllic, idyllicToBlockNote, testIsomorphism } from './document/blocknote-converter';\nexport type { BlockNoteBlock, BlockNoteContent, BlockNoteTableContent } from './document/blocknote-converter';\n\n// Agent system\nexport { Agent } from './agent/agent';\nexport { ActivityMemory } from './agent/memory';\nexport { buildSystemPrompt, buildDetailedSystemPrompt } from './agent/system-prompt';\nexport { getModel, checkModelConfig } from './agent/model-provider';\nexport type { \n  AgentConfig, \n  AgentContext, \n  AgentActivity,\n  AgentExecuteOptions,\n  AgentExecuteResult \n} from './agent/types';"],"mappings":"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","names":["marker","symbol","_a","name","_AISDKError","_TypeValidationError","validator","SecureJSON","TypeValidationError","InvalidArgumentError","getOriginalFetch","fetch","APICallError","chunkSchema","responseSchema","z","_a","token","logprob","type","UnsupportedFunctionalityError","convertUint8ArrayToBase64","init_dist","choice","toolCall","postJsonToApi","combineHeaders","createJsonResponseHandler","createEventSourceResponseHandler","parseProviderOptions","_b","_c","generateId","marker","symbol","_a","_AISDKError","AISDKError","name","InvalidArgumentError","import_secure_json_parse","createIdGenerator","generateId","validatorSymbol","btoa","atob","init_dist","InvalidArgumentError","_a","init_dist","getErrorMessage","marker","symbol","_a","_AISDKError","AISDKError","name","APICallError","EmptyResponseBodyError","InvalidArgumentError","JSONParseError","LoadSettingError","_TypeValidationError","TypeValidationError","UnsupportedFunctionalityError","combineHeaders","extractResponseHeaders","removeUndefinedEntries","isAbortError","loadSetting","LoadSettingError","validator","validatorSymbol","isValidator","asValidator","zodValidator","validateTypes","safeValidateTypes","TypeValidationError","parseJSON","SecureJSON","JSONParseError","safeParseJSON","convertUint8ArrayToBase64","btoa","import_secure_json_parse","createIdGenerator","generateId","getOriginalFetch","postJsonToApi","postToApi","createJsonErrorResponseHandler","createJsonResponseHandler","atob","init_dist","InvalidArgumentError","fetch","APICallError","responseSchema","resolve","Buffer","init_dist_es","init_dist_es","init_dist_es","init_dist_es","fromUtf8","init_dist_es","a_lookUpTable","init_module","AwsCrc32","Crc32","init_dist_es","init_dist_es","init_dist_es","toUtf8","fromUtf8","name","HEADER_VALUE_TYPE","init_module","init_module","toUtf8","fromUtf8","init_dist_es","isArrayBuffer","init_dist_es","Buffer","fromArrayBuffer","fromString","init_dist_es","isArrayBuffer","fromUtf8","init_fromUtf8","init_dist_es","fromString","init_toUint8Array","init_fromUtf8","init_toUtf8","init_dist_es","fromArrayBuffer","init_dist_es","init_fromUtf8","init_toUint8Array","init_toUtf8","match","z","prepareTools","_a","UnsupportedFunctionalityError","convertUint8ArrayToBase64","i","part","fetch","removeUndefinedEntries","combineHeaders","loadSetting","generateId","modelMaxImagesPerCall","init_dist","init_dist_es","chunkSchema","extractResponseHeaders","EmptyResponseBodyError","fromUtf8","safeParseJSON","safeValidateTypes","createIdGenerator","InvalidArgumentError","postJsonToApi","createJsonErrorResponseHandler","createJsonResponseHandler","_b","_c","_d","_e","_f","resolve","getErrorMessage","marker","symbol","_a","_AISDKError","AISDKError","name","APICallError","EmptyResponseBodyError","InvalidArgumentError","JSONParseError","LoadAPIKeyError","TooManyEmbeddingValuesForCallError","_TypeValidationError","TypeValidationError","UnsupportedFunctionalityError","combineHeaders","createEventSourceParserStream","splitLines","extractResponseHeaders","removeUndefinedEntries","isAbortError","loadApiKey","LoadAPIKeyError","validator","validatorSymbol","isValidator","asValidator","zodValidator","validateTypes","safeValidateTypes","TypeValidationError","parseJSON","SecureJSON","JSONParseError","safeParseJSON","parseProviderOptions","InvalidArgumentError","resolve","convertUint8ArrayToBase64","btoa","withoutTrailingSlash","import_secure_json_parse","createIdGenerator","generateId","getOriginalFetch","postJsonToApi","postToApi","createJsonErrorResponseHandler","createEventSourceResponseHandler","createJsonResponseHandler","atob","init_dist","fetch","APICallError","chunkSchema","EmptyResponseBodyError","responseSchema","z","_a","UnsupportedFunctionalityError","convertUint8ArrayToBase64","prepareTools","generateId","withoutTrailingSlash","loadApiKey","init_dist","createJsonErrorResponseHandler","parseProviderOptions","combineHeaders","resolve","postJsonToApi","createJsonResponseHandler","createEventSourceResponseHandler","TooManyEmbeddingValuesForCallError","azure","google","bedrock","init_dist","name","terminal","name","compiled","name","z","name","resolveVariablesWithAI","error","uuidv4","generateText","uuidv4","z","extractTextContent","z","generateText","name","uuidv4","generateText"]}