{"version":3,"sources":["../src/document/ast.ts","../src/grammar/parser/xml-parser.ts","../src/types.ts","../src/grammar/core/dsl.ts","../src/grammar/core/compiler.ts","../src/grammar/schemas/document.ts","../src/grammar/schemas/agent.ts","../src/grammar/schemas/diff.ts","../src/grammar/schemas/index.ts","../src/grammar/validation.ts","../src/document/executor.ts","../src/document/abstract-function-executor.ts","../src/document/function-registry.ts","../src/document/function-naming.ts","../src/document/validator.ts","../src/document/variable-resolution.ts","../src/document/custom-function-executor.ts","../src/document/diff-applier.ts","../src/agent/agent.ts","../src/agent/memory.ts","../src/agent/system-prompt.ts","../src/agent/custom-functions.ts","../src/utils/logger.ts","../src/agent/response-pipeline.ts"],"sourcesContent":["/**\n * Core AST types for Idyllic documents\n * \n * This defines the semantic model for documents, independent of:\n * - BlockNote editor representation\n * - XML serialization format\n * - Specific function implementations\n */\n\n// ============================================\n// Core Document Types\n// ============================================\n\n/**\n * The root document structure\n */\nexport interface IdyllDocument {\n  id: string;\n  nodes: Node[];\n  metadata?: DocumentMetadata;\n}\n\n\n/**\n * Agent system prompt document\n */\nexport interface AgentDocument {\n  type: 'agent';\n  id: string;\n  name?: string;\n  description?: string;\n  model?: string;\n  nodes: Node[];\n}\n\n/**\n * Diff document for edit operations\n */\nexport interface DiffDocument {\n  type: 'diff';\n  targetDocument?: string;\n  timestamp: Date;\n  operations: EditOperation[];\n}\n\n/**\n * Edit operation types\n */\nexport type EditOperation = \n  | EditAttrOperation\n  | EditContentOperation\n  | EditParamsOperation\n  | EditIdOperation\n  | InsertOperation\n  | DeleteOperation\n  | ReplaceOperation\n  | MoveOperation;\n\nexport interface EditAttrOperation {\n  type: 'edit:attr';\n  blockId: string;\n  name: string;\n  value: string;\n}\n\nexport interface EditContentOperation {\n  type: 'edit:content';\n  blockId: string;\n  content: RichContent[];\n}\n\nexport interface EditParamsOperation {\n  type: 'edit:params';\n  blockId: string;\n  params: Record<string, unknown>;\n}\n\nexport interface EditIdOperation {\n  type: 'edit:id';\n  blockId: string;\n  newId: string;\n}\n\nexport interface InsertOperation {\n  type: 'insert';\n  afterBlockId?: string;\n  beforeBlockId?: string;\n  atStart?: boolean;\n  atEnd?: boolean;\n  blocks: Node[];\n}\n\nexport interface DeleteOperation {\n  type: 'delete';\n  blockId: string;\n}\n\nexport interface ReplaceOperation {\n  type: 'replace';\n  blockId: string;\n  blocks: Node[];\n}\n\nexport interface MoveOperation {\n  type: 'move';\n  blockId?: string;\n  blockIds?: string[];\n  fromBlockId?: string;\n  toBlockId?: string;\n  afterBlockId?: string;\n  beforeBlockId?: string;\n  atStart?: boolean;\n  atEnd?: boolean;\n}\n\nexport interface DocumentMetadata {\n  version?: string;\n  created?: Date;\n  modified?: Date;\n  [key: string]: unknown;\n}\n\n/**\n * A node can be either content (text, headings, etc) or executable\n */\nexport type Node = ContentNode | ExecutableNode;\n\n\n// ============================================\n// Content Nodes\n// ============================================\n\nexport interface ContentNode {\n  id: string;\n  type: ContentNodeType;\n  content: RichContent[];\n  children?: Node[];\n  props?: Record<string, unknown>;\n}\n\n// Define node types directly\nexport type NodeType = \n  | 'p' | 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6'\n  | 'ul' | 'ol' | 'li'\n  | 'blockquote' | 'code' | 'pre'\n  | 'hr' | 'br'\n  | 'function_call' | 'trigger' | '_params' | '_content' | '_result'\n  | 'heading' | 'paragraph';  // Added for compatibility\n\n// ContentNodeType includes all content-related types\nexport type ContentNodeType = \n  | 'paragraph' | 'heading'\n  | 'bulletListItem' | 'numberedListItem' | 'checklistItem'\n  | 'code' | 'quote' | 'separator' | 'data' | 'function';\n\n// ============================================\n// Executable Nodes\n// ============================================\n\nexport interface ExecutableNode {\n  id: string;\n  type: ExecutableNodeType;\n  fn: string; // e.g., \"documents:create\", \"ai:generate-text\"\n  parameters: Record<string, unknown>;\n  content?: RichContent[]; // Natural language content/instructions\n  result?: ExecutionResult;\n  metadata?: ExecutableMetadata;\n  props?: Record<string, unknown>; // Additional properties for compatibility\n}\n\nexport type ExecutableNodeType = 'function_call' | 'trigger';\n\n\nexport interface ExecutableMetadata {\n  enabled?: boolean; // For triggers\n  modelId?: string; // For AI operations\n  [key: string]: unknown;\n}\n\nexport interface ExecutionResult {\n  success: boolean;\n  data?: unknown;\n  error?: ExecutionError;\n  timestamp?: Date;\n}\n\nexport interface ExecutionError {\n  code: string;\n  message: string;\n  details?: unknown;\n}\n\n// ============================================\n// Rich Content Types\n// ============================================\n\n/**\n * Rich content represents inline formatted text and elements\n */\nexport type RichContent = TextContent | InlineElement;\n\nexport interface TextContent {\n  type: 'text';\n  text: string;\n  styles?: TextStyle[];\n}\n\nexport type TextStyle = \n  | 'bold'\n  | 'italic'\n  | 'underline'\n  | 'strikethrough'\n  | 'code';\n\nexport type InlineElement = \n  | MentionElement\n  | VariableElement\n  | LinkElement\n  | AnnotationElement;\n\nexport interface MentionElement {\n  type: 'mention';\n  mentionType: 'user' | 'document' | 'agent' | 'custom';\n  id: string;\n  label?: string;\n}\n\nexport interface VariableElement {\n  type: 'variable';\n  name: string; // e.g., \"previousResult\", \"currentDate\"\n  prompt?: string; // Optional prompt for user input\n  value?: string; // Optional resolved value\n}\n\nexport interface LinkElement {\n  type: 'link';\n  href: string;\n  content: RichContent[];\n}\n\nexport interface AnnotationElement {\n  type: 'annotation';\n  content: RichContent[];\n  annotation: {\n    title?: string;\n    comment?: string;\n    confidence?: number;\n    [key: string]: unknown;\n  };\n}\n\n// ============================================\n// Utility Types\n// ============================================\n\n/**\n * Type guards for runtime type checking\n */\nexport function isContentNode(node: Node): node is ContentNode {\n  return !isExecutableNode(node);\n}\n\n\nexport function isExecutableNode(node: Node): node is ExecutableNode {\n  return node.type === 'function_call' || node.type === 'trigger';\n}\n\n\nexport function isTextContent(content: RichContent): content is TextContent {\n  return content.type === 'text';\n}\n\nexport function isMention(content: RichContent): content is MentionElement {\n  return content.type === 'mention';\n}\n\nexport function isVariable(content: RichContent): content is VariableElement {\n  return content.type === 'variable';\n}\n\n// ============================================\n// Document Traversal Utilities\n// ============================================\n\n/**\n * Traverse all nodes in a document (including nested children)\n */\nexport function* traverseNodes(nodes: Node[]): Generator<Node> {\n  for (const node of nodes) {\n    yield node;\n    if ('children' in node && node.children) {\n      yield* traverseNodes(node.children);\n    }\n  }\n}\n\n\n/**\n * Find a node by ID\n */\nexport function findNode(nodes: Node[], id: string): Node | undefined {\n  for (const node of traverseNodes(nodes)) {\n    if (node.id === id) {\n      return node;\n    }\n  }\n  return undefined;\n}\n\n\n/**\n * Get all executable nodes\n */\nexport function getExecutableNodes(nodes: Node[]): ExecutableNode[] {\n  const executable: ExecutableNode[] = [];\n  for (const node of traverseNodes(nodes)) {\n    if (isExecutableNode(node)) {\n      executable.push(node);\n    }\n  }\n  return executable;\n}\n\n\n/**\n * Extract all mentions from a document\n */\nexport function extractMentions(nodes: Node[]): MentionElement[] {\n  const mentions: MentionElement[] = [];\n  \n  function extractFromContent(content: RichContent[]) {\n    for (const item of content) {\n      if (isMention(item)) {\n        mentions.push(item);\n      } else if ('content' in item && Array.isArray(item.content)) {\n        extractFromContent(item.content);\n      }\n    }\n  }\n  \n  for (const node of traverseNodes(nodes)) {\n    if ('content' in node && Array.isArray(node.content)) {\n      extractFromContent(node.content);\n    }\n    if (isExecutableNode(node) && node.content) {\n      extractFromContent(node.content);\n    }\n  }\n  \n  return mentions;\n}\n\n/**\n * Extract all variables from a document\n */\nexport function extractVariables(nodes: Node[]): VariableElement[] {\n  const variables: VariableElement[] = [];\n  \n  function extractFromContent(content: RichContent[]) {\n    for (const item of content) {\n      if (isVariable(item)) {\n        variables.push(item);\n      } else if ('content' in item && Array.isArray(item.content)) {\n        extractFromContent(item.content);\n      }\n    }\n  }\n  \n  for (const node of traverseNodes(nodes)) {\n    if ('content' in node && Array.isArray(node.content)) {\n      extractFromContent(node.content);\n    }\n    if (isExecutableNode(node) && node.content) {\n      extractFromContent(node.content);\n    }\n  }\n  \n  return variables;\n}","/**\n * Grammar-based XML parser for Idyllic documents\n *\n * This parser uses the grammar as the single source of truth\n * for parsing, validation, and AST construction\n */\n\nimport * as xml2js from \"xml-js\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport {\n  IdyllDocument,\n  AgentDocument,\n  DiffDocument,\n  EditOperation,\n  Node,\n  ContentNode,\n  ExecutableNode,\n  RichContent,\n  TextContent,\n  TextStyle,\n  MentionElement,\n  VariableElement,\n  LinkElement,\n  AnnotationElement,\n  ContentNodeType,\n  isExecutableNode,\n  isTextContent,\n} from \"../../document/ast\";\nimport { ParseError } from \"../../types\";\nimport { GRAMMAR } from \"../index\";\nimport { GrammarCompiler } from \"../core/compiler\";\nimport { \n  validateDocument, \n  validateAgentDocument, \n  validateDiffDocument \n} from \"../validation\";\n\n// Initialize grammar compiler\nconst compiler = new GrammarCompiler(GRAMMAR);\nconst compiled = compiler.compile();\n\n// ============================================\n// XML to AST Parsing\n// ============================================\n\n/**\n * Parse XML string into AST - determines document type automatically\n */\nexport function parseXmlToAst(\n  xmlString: string\n): IdyllDocument | AgentDocument | DiffDocument {\n  if (!xmlString || !xmlString.trim()) {\n    throw new ParseError(\"Empty XML content provided\");\n  }\n\n  // Parse XML\n  const options: xml2js.Options.XML2JS = {\n    compact: false,\n    textKey: \"text\",\n    ignoreDeclaration: true,\n    ignoreInstruction: true,\n    ignoreComment: true,\n    ignoreDoctype: true,\n    ignoreText: false,\n    trim: false,\n    sanitize: false,\n    nativeType: false,\n  };\n\n  let result: xml2js.Element;\n  try {\n    result = xml2js.xml2js(xmlString, options) as xml2js.Element;\n  } catch (error) {\n    throw new ParseError(\n      `Invalid XML format: ${\n        error instanceof Error ? error.message : \"Failed to parse XML\"\n      }`\n    );\n  }\n\n  // Determine root type and parse accordingly\n  const rootElement = result.elements?.[0];\n  if (!rootElement || rootElement.type !== \"element\") {\n    throw new ParseError(\"No root element found\");\n  }\n\n  switch (rootElement.name) {\n    case \"document\": {\n      const document = parseDocument(rootElement);\n      // Validate the parsed document with Zod\n      try {\n        return validateDocument(document);\n      } catch (error) {\n        throw new ParseError(\n          `Document validation failed: ${error instanceof Error ? error.message : 'Unknown validation error'}`\n        );\n      }\n    }\n    case \"agent\": {\n      const agent = parseAgent(rootElement);\n      // Validate the parsed agent document with Zod\n      try {\n        return validateAgentDocument(agent);\n      } catch (error) {\n        throw new ParseError(\n          `Agent document validation failed: ${error instanceof Error ? error.message : 'Unknown validation error'}`\n        );\n      }\n    }\n    case \"diff\": {\n      const diff = parseDiff(rootElement);\n      // Validate the parsed diff document with Zod\n      try {\n        return validateDiffDocument(diff);\n      } catch (error) {\n        throw new ParseError(\n          `Diff document validation failed: ${error instanceof Error ? error.message : 'Unknown validation error'}`\n        );\n      }\n    }\n    default:\n      throw new ParseError(\n        `Unknown root element: ${rootElement.name}. Expected: document, agent, or diff`\n      );\n  }\n}\n\n/**\n * Parse document root\n */\nfunction parseDocument(documentElement: xml2js.Element): IdyllDocument {\n  // Validate document element\n  const attrs = documentElement.attributes || {};\n  const validationErrors = compiled.validateAttributes(\"document\", attrs);\n  if (validationErrors.length > 0) {\n    throw new ParseError(\n      `Document validation failed: ${validationErrors[0].message}`\n    );\n  }\n\n  const documentId = (attrs.id as string) || uuidv4();\n\n  // Parse nodes\n  const nodes: Node[] = [];\n  const childElements = documentElement.elements || [];\n\n  for (const element of childElements) {\n    if (element.type === \"element\" && element.name) {\n      const node = parseNode(element);\n      if (node) {\n        nodes.push(node);\n      }\n    }\n  }\n\n  return {\n    id: documentId,\n    nodes: nodes.length > 0 ? nodes : [createEmptyParagraph()],\n    metadata: extractMetadata(attrs),\n  };\n}\n\n/**\n * Parse agent root\n */\nfunction parseAgent(agentElement: xml2js.Element): AgentDocument {\n  const attrs = agentElement.attributes || {};\n  const validationErrors = compiled.validateAttributes(\"agent\", attrs);\n  if (validationErrors.length > 0) {\n    throw new ParseError(\n      `Agent validation failed: ${validationErrors[0].message}`\n    );\n  }\n\n  const agentId = (attrs.id as string) || uuidv4();\n\n  // Parse nodes (same as document)\n  const nodes: Node[] = [];\n  const childElements = agentElement.elements || [];\n\n  for (const element of childElements) {\n    if (element.type === \"element\" && element.name) {\n      const node = parseNode(element);\n      if (node) {\n        nodes.push(node);\n      }\n    }\n  }\n\n  return {\n    type: \"agent\",\n    id: agentId,\n    name: attrs.name as string,\n    description: attrs.description as string,\n    model: attrs.model as string,\n    nodes,\n  };\n}\n\n/**\n * Parse diff root\n */\nfunction parseDiff(diffElement: xml2js.Element): DiffDocument {\n  const attrs = diffElement.attributes || {};\n  const validationErrors = compiled.validateAttributes(\"diff\", attrs);\n  if (validationErrors.length > 0) {\n    throw new ParseError(\n      `Diff validation failed: ${validationErrors[0].message}`\n    );\n  }\n\n  // Parse edit operations\n  const operations: EditOperation[] = [];\n  const childElements = diffElement.elements || [];\n\n  for (const element of childElements) {\n    if (element.type === \"element\" && element.name) {\n      const operation = parseEditOperation(element);\n      if (operation) {\n        operations.push(operation);\n      }\n    }\n  }\n\n  return {\n    type: \"diff\",\n    targetDocument: attrs.targetDocument as string,\n    timestamp: attrs.timestamp\n      ? new Date(attrs.timestamp as string)\n      : new Date(),\n    operations,\n  };\n}\n\n/**\n * Parse edit operation\n */\nfunction parseEditOperation(element: xml2js.Element): EditOperation | null {\n  if (!element.name) return null;\n\n  const attrs = element.attributes || {};\n\n  switch (element.name) {\n    case \"edit:prop\":\n      return {\n        type: \"edit:attr\",\n        blockId: attrs[\"block-id\"] as string,\n        name: attrs.name as string,\n        value: attrs.value as string,\n      };\n\n    case \"edit:content\":\n      return {\n        type: \"edit:content\",\n        blockId: attrs[\"block-id\"] as string,\n        content: parseRichContent(element),\n      };\n\n    case \"insert\":\n      const insertNodes: Node[] = [];\n      for (const child of element.elements || []) {\n        if (child.type === \"element\" && child.name) {\n          const node = parseNode(child);\n          if (node) {\n            insertNodes.push(node);\n          }\n        }\n      }\n      return {\n        type: \"insert\",\n        afterBlockId: attrs[\"after-block-id\"] as string,\n        beforeBlockId: attrs[\"before-block-id\"] as string,\n        atStart: attrs[\"at-start\"] === \"true\",\n        atEnd: attrs[\"at-end\"] === \"true\",\n        blocks: insertNodes,\n      };\n\n    case \"delete\":\n      return {\n        type: \"delete\",\n        blockId: attrs[\"block-id\"] as string,\n      };\n\n    case \"replace\":\n      const replaceNodes: Node[] = [];\n      for (const child of element.elements || []) {\n        if (child.type === \"element\" && child.name) {\n          const node = parseNode(child);\n          if (node) {\n            replaceNodes.push(node);\n          }\n        }\n      }\n      return {\n        type: \"replace\",\n        blockId: attrs[\"block-id\"] as string,\n        blocks: replaceNodes,\n      };\n\n    default:\n      console.warn(`Unknown edit operation: ${element.name}`);\n      return null;\n  }\n}\n\n/**\n * Parse a node element using grammar rules\n */\nfunction parseNode(element: xml2js.Element): Node | null {\n  if (!element.name) return null;\n\n  const elementType = compiled.elementToType[element.name];\n  if (!elementType) {\n    return null;\n  }\n\n  const id = (element.attributes?.id as string) || uuidv4();\n  const attrs = element.attributes || {};\n\n  // Validate attributes\n  const errors = compiled.validateAttributes(element.name, attrs);\n  if (errors.length > 0) {\n    throw new ParseError(\n      `Invalid attributes for ${element.name}: ${errors[0].message}`\n    );\n  }\n\n  // Route based on element type\n  switch (elementType) {\n    case \"function_call\":\n      return parseFunctionCall(element, id, attrs);\n    case \"trigger\":\n      return parseTrigger(element, id, attrs);\n    case \"function\":\n      return parseFunction(element, id, attrs);\n    default:\n      return parseContentNode(element, id, attrs, elementType);\n  }\n}\n\n/**\n * Parse function call node\n */\nfunction parseFunctionCall(\n  element: xml2js.Element,\n  id: string,\n  attrs: Record<string, unknown>\n): ExecutableNode {\n  const functionName = attrs[\"idyll-fn\"] as string;\n\n  let parameters: Record<string, unknown> = {};\n  let content: RichContent[] = [];\n  let result: unknown;\n\n  // Parse child elements according to grammar\n  for (const child of element.elements || []) {\n    if (child.type === \"element\" && child.name) {\n      switch (child.name) {\n        case \"params\":\n          const paramsText = extractTextContent(child);\n          if (paramsText) {\n            try {\n              parameters = JSON.parse(paramsText);\n            } catch {\n              throw new ParseError(`Invalid JSON in params: ${paramsText}`);\n            }\n          }\n          break;\n\n        case \"content\":\n          content = parseRichContent(child);\n          break;\n\n        case \"result\":\n          const resultText = extractTextContent(child);\n          if (resultText) {\n            try {\n              result = JSON.parse(resultText);\n            } catch {\n              result = resultText;\n            }\n          }\n          break;\n      }\n    }\n  }\n\n  return {\n    id,\n    type: \"function_call\",\n    fn: functionName,\n    parameters,\n    content: content.length > 0 ? content : undefined,\n    result: result ? { success: true, data: result } : undefined,\n    metadata: {\n      modelId: attrs.modelId as string,\n    },\n  };\n}\n\n/**\n * Parse trigger node\n */\nfunction parseTrigger(\n  element: xml2js.Element,\n  id: string,\n  attrs: Record<string, unknown>\n): ExecutableNode {\n  const functionName = attrs[\"idyll-trigger\"] as string;\n  const enabled = attrs.enabled !== false;\n\n  let parameters: Record<string, unknown> = {};\n  let content: RichContent[] = [];\n\n  for (const child of element.elements || []) {\n    if (child.type === \"element\" && child.name) {\n      switch (child.name) {\n        case \"params\":\n          const paramsText = extractTextContent(child);\n          if (paramsText) {\n            try {\n              parameters = JSON.parse(paramsText);\n            } catch {\n              throw new ParseError(`Invalid JSON in params: ${paramsText}`);\n            }\n          }\n          break;\n\n        case \"content\":\n          content = parseRichContent(child);\n          break;\n      }\n    }\n  }\n\n  return {\n    id,\n    type: \"trigger\",\n    fn: functionName,\n    parameters,\n    content: content.length > 0 ? content : undefined,\n    metadata: { enabled },\n  };\n}\n\n/**\n * Parse function node\n */\nfunction parseFunction(\n  element: xml2js.Element,\n  id: string,\n  attrs: Record<string, unknown>\n): ContentNode {\n  // Functions are stored as content nodes with special props\n  const title = attrs.title as string;\n  const icon = attrs.icon as string;\n\n  let description = \"\";\n  let definition: Node[] = [];\n\n  for (const child of element.elements || []) {\n    if (child.type === \"element\" && child.name) {\n      switch (child.name) {\n        case \"function:description\":\n          description = extractTextContent(child);\n          break;\n\n        case \"function:definition\":\n          // Parse nodes within function definition\n          for (const defChild of child.elements || []) {\n            if (defChild.type === \"element\" && defChild.name) {\n              // Check that it's not another function (grammar constraint)\n              if (compiled.elementToType[defChild.name] === \"function\") {\n                throw new ParseError(\"Functions cannot contain other functions\");\n              }\n\n              const node = parseNode(defChild);\n              if (node) {\n                definition.push(node);\n              }\n            }\n          }\n          break;\n      }\n    }\n  }\n\n  return {\n    id,\n    type: \"function\" as ContentNodeType,\n    content: [], // Empty content array, description is in props\n    children: definition.length > 0 ? definition : undefined,\n    props: { title, icon, description },\n  };\n}\n\n/**\n * Parse content node\n */\nfunction parseContentNode(\n  element: xml2js.Element,\n  id: string,\n  attrs: Record<string, unknown>,\n  blockType: string\n): ContentNode {\n  const content = parseRichContent(element);\n\n  // Parse children for nested nodes\n  const children: Node[] = [];\n  for (const child of element.elements || []) {\n    if (child.type === \"element\" && child.name) {\n      const childType = compiled.elementToType[child.name];\n      if (childType && compiled.blockTypes.has(childType)) {\n        const childNode = parseNode(child);\n        if (childNode) {\n          children.push(childNode);\n        }\n      }\n    }\n  }\n\n  // Handle heading level\n  if (blockType === \"heading\") {\n    if (element.name === \"heading\") {\n      // Already has level attribute\n    } else if (element.name) {\n      const match = element.name.match(/^h(\\d)$/);\n      if (match) {\n        attrs.level = parseInt(match[1], 10);\n      }\n    }\n  }\n\n  return {\n    id,\n    type: blockType as ContentNodeType,\n    content,\n    children: children.length > 0 ? children : undefined,\n    props: attrs,\n  };\n}\n\n/**\n * Parse rich content using grammar rules\n */\nfunction parseRichContent(element: xml2js.Element): RichContent[] {\n  const content: RichContent[] = [];\n\n  if (!element.elements) return content;\n\n  for (const child of element.elements) {\n    if (child.type === \"text\" && child.text) {\n      content.push({\n        type: \"text\",\n        text: child.text as string,\n      });\n    } else if (child.type === \"element\" && child.name) {\n      const inlineElement = parseInlineElement(child);\n      if (inlineElement) {\n        if (Array.isArray(inlineElement)) {\n          // Filter out any null values from the array\n          content.push(...inlineElement.filter(item => item != null));\n        } else {\n          content.push(inlineElement);\n        }\n      }\n    }\n  }\n\n  return content;\n}\n\n/**\n * Parse inline element\n */\nfunction parseInlineElement(\n  element: xml2js.Element\n): RichContent | RichContent[] | null {\n  if (!element.name) return null;\n\n  // Check if it's a mention\n  if (element.name.startsWith(\"mention:\")) {\n    const mentionType = element.name.substring(8) as any;\n    const id = element.attributes?.id as string;\n    const label =\n      (element.attributes?.label as string) || extractTextContent(element);\n\n    return {\n      type: \"mention\",\n      mentionType,\n      id,\n      label,\n    } as MentionElement;\n  }\n\n  // Check if it's a variable\n  if (element.name === \"variable\") {\n    const name = element.attributes?.name as string;\n    const prompt = element.attributes?.prompt as string;\n    const value = element.attributes?.value as string;\n    \n    // Variable must have a name\n    if (!name) {\n      console.warn('Variable element missing required \"name\" attribute');\n      return null;\n    }\n    \n    return {\n      type: \"variable\",\n      name,\n      ...(prompt && { prompt }),\n      ...(value && { value }),\n    } as VariableElement;\n  }\n\n  // Check if it's a link\n  if (element.name === \"a\") {\n    const href = element.attributes?.href as string;\n    return {\n      type: \"link\",\n      href,\n      content: parseRichContent(element),\n    } as LinkElement;\n  }\n\n  // Check if it's an annotation\n  if (element.name === \"annotation\") {\n    return {\n      type: \"annotation\",\n      content: parseRichContent(element),\n      annotation: (element.attributes as any) || {},\n    } as AnnotationElement;\n  }\n\n  // Check if it's annotated text\n  if (element.name === \"annotatedtext\") {\n    const annotation = element.attributes?.annotation as string;\n    return {\n      type: \"annotation\",\n      content: parseRichContent(element),\n      annotation: { title: annotation },\n    } as AnnotationElement;\n  }\n\n  // Check if it's AI edit response\n  if (element.name === \"aieditresponse\") {\n    const status = element.attributes?.status as string;\n    return {\n      type: \"annotation\",\n      content: parseRichContent(element),\n      annotation: { type: \"ai-edit\", status },\n    } as AnnotationElement;\n  }\n\n  // Check if it's a style element\n  const styleMap: Record<string, TextStyle> = {\n    strong: \"bold\",\n    b: \"bold\",\n    em: \"italic\",\n    i: \"italic\",\n    u: \"underline\",\n    underline: \"underline\",\n    s: \"strikethrough\",\n    strike: \"strikethrough\",\n    del: \"strikethrough\",\n    code: \"code\",\n    tt: \"code\",\n  };\n\n  const style = styleMap[element.name];\n  if (style) {\n    const innerContent = parseRichContent(element);\n    return innerContent.map((item) => {\n      if (isTextContent(item)) {\n        return {\n          ...item,\n          styles: [...(item.styles || []), style],\n        } as TextContent;\n      }\n      return item;\n    });\n  }\n\n  return null;\n}\n\n// ============================================\n// AST to XML Serialization\n// ============================================\n\n/**\n * Serialize AST document to XML string\n */\nexport function serializeAstToXml(\n  document: IdyllDocument | AgentDocument | DiffDocument\n): string {\n  let root: xml2js.Element;\n\n  if (\"type\" in document) {\n    if (document.type === \"agent\") {\n      root = serializeAgentDocument(document);\n    } else if (document.type === \"diff\") {\n      root = serializeDiffDocument(document);\n    } else {\n      throw new Error(`Unknown document type`);\n    }\n  } else {\n    root = serializeIdyllDocument(document);\n  }\n\n  const options: xml2js.Options.JS2XML = {\n    compact: false,\n    spaces: 2,\n    textKey: \"text\",\n  };\n\n  // xml2js expects the root element to be wrapped in an object with elements array\n  const wrapped = {\n    elements: [root]\n  };\n\n  return `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n${xml2js.js2xml(\n    wrapped,\n    options\n  )}`;\n}\n\n/**\n * Serialize IdyllDocument\n */\nfunction serializeIdyllDocument(document: IdyllDocument): xml2js.Element {\n  return {\n    type: \"element\",\n    name: \"document\",\n    attributes: {\n      id: document.id,\n      ...serializeMetadata(document.metadata),\n    },\n    elements: document.nodes.map(serializeNode),\n  };\n}\n\n/**\n * Serialize AgentDocument\n */\nfunction serializeAgentDocument(document: AgentDocument): xml2js.Element {\n  return {\n    type: \"element\",\n    name: \"agent\",\n    attributes: {\n      id: document.id,\n      ...(document.name && { name: document.name }),\n      ...(document.description && { description: document.description }),\n      ...(document.model && { model: document.model }),\n    },\n    elements: document.nodes.map(serializeNode),\n  };\n}\n\n/**\n * Serialize DiffDocument\n */\nfunction serializeDiffDocument(document: DiffDocument): xml2js.Element {\n  return {\n    type: \"element\",\n    name: \"diff\",\n    attributes: {\n      ...(document.targetDocument && {\n        targetDocument: document.targetDocument,\n      }),\n      timestamp: document.timestamp.toISOString(),\n    },\n    elements: document.operations.map(serializeEditOperation),\n  };\n}\n\n/**\n * Serialize a node to XML element\n */\nfunction serializeNode(node: Node): xml2js.Element {\n  if (isExecutableNode(node)) {\n    return serializeExecutableNode(node);\n  }\n\n  // Special handling for function nodes\n  if (node.type === \"function\") {\n    return serializeFunctionNode(node);\n  }\n\n  return serializeContentNode(node);\n}\n\n/**\n * Serialize executable node\n */\nfunction serializeExecutableNode(node: ExecutableNode): xml2js.Element {\n  const elements: xml2js.Element[] = [];\n\n  // Add params\n  if (Object.keys(node.parameters).length > 0) {\n    elements.push({\n      type: \"element\",\n      name: \"params\",\n      elements: [\n        {\n          type: \"cdata\",\n          cdata: JSON.stringify(node.parameters),\n        },\n      ],\n    });\n  }\n\n  // Add content\n  if (node.content && node.content.length > 0) {\n    elements.push({\n      type: \"element\",\n      name: \"content\",\n      elements: serializeRichContent(node.content),\n    });\n  }\n\n  if (node.type === \"function_call\") {\n    // Add result\n    if (node.result) {\n      elements.push({\n        type: \"element\",\n        name: \"result\",\n        elements: [\n          {\n            type: \"cdata\",\n            cdata: JSON.stringify(node.result.data || node.result),\n          },\n        ],\n      });\n    }\n\n    return {\n      type: \"element\",\n      name: \"fncall\",\n      attributes: {\n        id: node.id,\n        \"idyll-fn\": node.fn,\n        ...(node.metadata?.modelId && { modelId: node.metadata.modelId }),\n      },\n      elements,\n    };\n  } else {\n    return {\n      type: \"element\",\n      name: \"trigger\",\n      attributes: {\n        id: node.id,\n        \"idyll-trigger\": node.fn,\n        enabled: String(node.metadata?.enabled !== false),\n      },\n      elements,\n    };\n  }\n}\n\n/**\n * Serialize function node\n */\nfunction serializeFunctionNode(node: ContentNode): xml2js.Element {\n  const elements: xml2js.Element[] = [];\n\n  // Add description from props\n  const description = (node.props?.description as string) || \"\";\n\n  elements.push({\n    type: \"element\",\n    name: \"function:description\",\n    elements: [{ type: \"text\", text: description }],\n  });\n\n  // Add definition\n  if (node.children && node.children.length > 0) {\n    elements.push({\n      type: \"element\",\n      name: \"function:definition\",\n      elements: node.children.map(serializeNode),\n    });\n  }\n\n  const attributes: Record<string, string> = {\n    id: node.id,\n    title: node.props?.title as string,\n  };\n\n  if (node.props?.icon) {\n    attributes.icon = node.props.icon as string;\n  }\n\n  return {\n    type: \"element\",\n    name: \"function\",\n    attributes,\n    elements,\n  };\n}\n\n/**\n * Serialize content node\n */\nfunction serializeContentNode(node: ContentNode): xml2js.Element {\n  const elements = [\n    ...serializeRichContent(node.content),\n    ...(node.children || []).map(serializeNode),\n  ];\n\n  // Get element name from type\n  const typeToElement = Object.entries(compiled.elementToType).reduce(\n    (acc, [elem, type]) => {\n      if (!acc[type]) acc[type] = [];\n      acc[type].push(elem);\n      return acc;\n    },\n    {} as Record<string, string[]>\n  );\n\n  let elementName = typeToElement[node.type]?.[0] || \"p\";\n\n  // Special handling for headings\n  if (node.type === \"heading\" && node.props?.level) {\n    elementName = `h${node.props.level}`;\n  }\n\n  return {\n    type: \"element\",\n    name: elementName,\n    attributes: {\n      id: node.id,\n      ...cleanProps(node.props),\n    },\n    elements: elements.length > 0 ? elements : undefined,\n  };\n}\n\n/**\n * Serialize rich content\n */\nfunction serializeRichContent(\n  content: RichContent[]\n): (xml2js.Element | { type: \"text\"; text: string })[] {\n  return content.map((item) => {\n    if (isTextContent(item)) {\n      if (item.styles && item.styles.length > 0) {\n        // Map styles to elements\n        const styleToElement: Record<TextStyle, string> = {\n          bold: \"strong\",\n          italic: \"em\",\n          underline: \"u\",\n          strikethrough: \"s\",\n          code: \"code\",\n        };\n\n        // Wrap in style elements\n        let element: xml2js.Element = {\n          type: \"element\",\n          name: styleToElement[item.styles[0]],\n          elements: [{ type: \"text\", text: item.text }],\n        };\n\n        // Nest additional styles\n        for (let i = 1; i < item.styles.length; i++) {\n          element = {\n            type: \"element\",\n            name: styleToElement[item.styles[i]],\n            elements: [element],\n          };\n        }\n\n        return element;\n      }\n      return { type: \"text\", text: item.text };\n    }\n\n    // Handle other inline elements\n    switch (item.type) {\n      case \"mention\":\n        return {\n          type: \"element\",\n          name: `mention:${item.mentionType}`,\n          attributes: {\n            id: item.id,\n            ...(item.label && { label: item.label }),\n          },\n          elements: item.label\n            ? undefined\n            : [{ type: \"text\", text: item.label || \"\" }],\n        };\n\n      case \"variable\":\n        return {\n          type: \"element\",\n          name: \"variable\",\n          attributes: {\n            name: item.name,\n            ...(item.prompt && { prompt: item.prompt }),\n            ...(item.value && { value: item.value }),\n          },\n        };\n\n      case \"link\":\n        return {\n          type: \"element\",\n          name: \"a\",\n          attributes: { href: item.href },\n          elements: serializeRichContent(item.content),\n        };\n\n      case \"annotation\":\n        return {\n          type: \"element\",\n          name: \"annotation\",\n          attributes: {\n            ...(item.annotation.title && { title: String(item.annotation.title) }),\n            ...(item.annotation.comment && { comment: String(item.annotation.comment) }),\n            ...(item.annotation.confidence !== undefined && { confidence: String(item.annotation.confidence) }),\n          },\n          elements: serializeRichContent(item.content),\n        };\n\n      default:\n        return { type: \"text\", text: \"\" };\n    }\n  });\n}\n\n// ============================================\n// Utility Functions\n// ============================================\n\nfunction extractTextContent(element: xml2js.Element): string {\n  let text = \"\";\n\n  if (element.elements) {\n    for (const child of element.elements) {\n      if (child.type === \"text\" && child.text) {\n        text += child.text;\n      } else if (child.type === \"cdata\" && child.cdata) {\n        text += child.cdata;\n      } else if (child.type === \"element\") {\n        text += extractTextContent(child);\n      }\n    }\n  }\n\n  return text;\n}\n\nfunction createEmptyParagraph(): ContentNode {\n  return {\n    id: uuidv4(),\n    type: \"paragraph\",\n    content: [],\n  };\n}\n\nfunction extractMetadata(\n  attrs: Record<string, unknown>\n): Record<string, unknown> | undefined {\n  const metadata: Record<string, unknown> = {};\n\n  if (attrs.version) metadata.version = attrs.version;\n  if (attrs.created) metadata.created = new Date(attrs.created as string);\n  if (attrs.modified) metadata.modified = new Date(attrs.modified as string);\n\n  return Object.keys(metadata).length > 0 ? metadata : undefined;\n}\n\nfunction serializeMetadata(\n  metadata?: Record<string, unknown>\n): Record<string, string> {\n  if (!metadata) return {};\n\n  const result: Record<string, string> = {};\n\n  if (metadata.version) result.version = String(metadata.version);\n  if (metadata.created instanceof Date)\n    result.created = metadata.created.toISOString();\n  if (metadata.modified instanceof Date)\n    result.modified = metadata.modified.toISOString();\n\n  return result;\n}\n\n/**\n * Clean props by removing default/empty values to reduce XML verbosity\n */\nfunction cleanProps(props?: Record<string, unknown>): Record<string, unknown> {\n  if (!props) return {};\n\n  const cleaned: Record<string, unknown> = {};\n  \n  // Default values to exclude\n  const defaultValues = new Set([\n    'default',\n    'left',     // default text alignment\n    'normal',   // default font weight, etc.\n    '',         // empty strings\n    null,\n    undefined\n  ]);\n\n  for (const [key, value] of Object.entries(props)) {\n    // Skip default values\n    if (defaultValues.has(value as any)) {\n      continue;\n    }\n    \n    // Skip empty arrays and objects\n    if (Array.isArray(value) && value.length === 0) {\n      continue;\n    }\n    if (value && typeof value === 'object' && Object.keys(value).length === 0) {\n      continue;\n    }\n    \n    // Keep non-default values\n    cleaned[key] = value;\n  }\n\n  return cleaned;\n}\n\n/**\n * Serialize edit operation\n */\nfunction serializeEditOperation(operation: EditOperation): xml2js.Element {\n  switch (operation.type) {\n    case \"edit:attr\":\n      return {\n        type: \"element\",\n        name: \"edit:prop\",\n        attributes: {\n          \"block-id\": operation.blockId,\n          name: operation.name,\n          value: operation.value,\n        },\n      };\n\n    case \"edit:content\":\n      return {\n        type: \"element\",\n        name: \"edit:content\",\n        attributes: {\n          \"block-id\": operation.blockId,\n        },\n        elements: serializeRichContent(operation.content),\n      };\n\n    case \"insert\":\n      return {\n        type: \"element\",\n        name: \"insert\",\n        attributes: {\n          ...(operation.afterBlockId && {\n            \"after-block-id\": operation.afterBlockId,\n          }),\n          ...(operation.beforeBlockId && {\n            \"before-block-id\": operation.beforeBlockId,\n          }),\n          ...(operation.atStart && { \"at-start\": \"true\" }),\n          ...(operation.atEnd && { \"at-end\": \"true\" }),\n        },\n        elements: operation.blocks.map(serializeNode),\n      };\n\n    case \"delete\":\n      return {\n        type: \"element\",\n        name: \"delete\",\n        attributes: {\n          \"block-id\": operation.blockId,\n        },\n      };\n\n    case \"replace\":\n      return {\n        type: \"element\",\n        name: \"replace\",\n        attributes: {\n          \"block-id\": operation.blockId,\n        },\n        elements: operation.blocks.map(serializeNode),\n      };\n\n    default:\n      throw new Error(`Unknown operation type`);\n  }\n}\n\n","/**\n * Consolidated type definitions for Idyll Engine\n */\n\nimport type { MentionElement, VariableElement } from './document/ast';\n\n// ============================================\n// Validation Context\n// ============================================\n\n/**\n * Context for validating document references\n */\nexport interface ValidationContext {\n  /**\n   * Validate that a mention reference exists\n   * @param mention The mention to validate\n   * @returns True if valid, false otherwise\n   */\n  validateMention?(mention: MentionElement): boolean;\n  \n  /**\n   * Validate that a variable exists and optionally get its value\n   * @param variable The variable to validate\n   * @returns Validation result with optional value\n   */\n  validateVariable?(variable: VariableElement): {\n    valid: boolean;\n    value?: unknown;\n  };\n  \n  /**\n   * Validate that a function exists\n   * @param functionName The function name to validate\n   * @returns True if function exists, false otherwise\n   */\n  validateFunction?(functionName: string): boolean;\n}\n\n// ============================================\n// Execution Context\n// ============================================\n\n/**\n * Runtime context for document/agent execution\n */\nexport interface ExecutionContext {\n  /**\n   * User performing the execution\n   */\n  user: {\n    id: string;\n    name?: string;\n    email?: string;\n  };\n  \n  /**\n   * Available variables during execution\n   */\n  variables: Record<string, unknown>;\n  \n  /**\n   * Resolve a mention to its value\n   * @param mention The mention to resolve\n   * @returns The resolved value or undefined\n   */\n  resolveMention?(mention: MentionElement): unknown;\n  \n  /**\n   * Resolve a variable to its value\n   * @param variable The variable to resolve\n   * @returns The resolved value or undefined\n   */\n  resolveVariable?(variable: VariableElement): unknown;\n  \n  /**\n   * Additional metadata\n   */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Context specific to document execution\n */\nexport interface DocumentExecutionContext extends ExecutionContext {\n  /**\n   * Document being executed\n   */\n  documentId: string;\n  \n  /**\n   * Whether the user can edit the document\n   */\n  canEdit: boolean;\n}\n\n/**\n * Context specific to agent execution\n */\nexport interface AgentExecutionContext extends ExecutionContext {\n  /**\n   * Agent performing the execution\n   */\n  agentId: string;\n  \n  /**\n   * Thread ID if in a conversation\n   */\n  threadId?: string;\n  \n  /**\n   * Conversation history if available\n   */\n  messages?: Array<{\n    role: 'user' | 'assistant' | 'system';\n    content: string;\n  }>;\n}\n\n// ============================================\n// Function Definition\n// ============================================\n\n/**\n * Definition of a function that can be executed\n */\nexport interface FunctionDefinition {\n  /**\n   * Unique function identifier (e.g., \"documents:create\")\n   */\n  name: string;\n  \n  /**\n   * Human-readable title\n   */\n  title?: string;\n  \n  /**\n   * Function description\n   */\n  description?: string;\n  \n  /**\n   * Whether the function requires content/instructions\n   */\n  contentRequirement?: 'required' | 'optional' | 'disabled';\n  \n  /**\n   * Validate parameters before execution\n   * @param params The parameters to validate\n   * @returns Validation result\n   */\n  validate(params: unknown): FunctionValidationResult;\n}\n\nexport type FunctionValidationResult = \n  | { success: true }\n  | { success: false; errors: string[] };\n\n// ============================================\n// Function Resolution & Execution\n// ============================================\n\n/**\n * Interface for resolving function definitions\n */\nexport interface FunctionResolver {\n  /**\n   * Resolve a function by name\n   * @param name Function identifier\n   * @returns Function definition or null if not found\n   */\n  resolve(name: string): FunctionDefinition | null;\n  \n  /**\n   * List all available functions\n   * @returns Array of function names\n   */\n  list?(): string[];\n}\n\n/**\n * Interface for implementing functions\n */\nexport interface FunctionImpl {\n  /**\n   * Execute a function with given parameters\n   * @param functionName Function name\n   * @param params Function parameters (already validated)\n   * @param context Execution context\n   * @returns Function execution result\n   */\n  execute(\n    functionName: string, \n    params: Record<string, unknown>, \n    context: FunctionExecutionContext\n  ): Promise<FunctionResult>;\n}\n\n/**\n * Context provided during function execution\n */\nexport interface FunctionExecutionContext {\n  /**\n   * Execution mode - where the function is being executed from\n   */\n  mode: 'document' | 'agent';\n  \n  /**\n   * User executing the function\n   */\n  user: {\n    id: string;\n    name?: string;\n    email?: string;\n  };\n  \n  /**\n   * Instructions/content provided with the function call\n   */\n  instructions?: string;\n  \n  /**\n   * Document-specific context\n   */\n  document?: {\n    id: string;\n    nodeId: string;\n  };\n  \n  /**\n   * Agent-specific context\n   */\n  agent?: {\n    id: string;\n    threadId?: string;\n  };\n  \n  /**\n   * Additional metadata\n   */\n  metadata?: Record<string, unknown>;\n}\n\n// ============================================\n// Function Results\n// ============================================\n\n/**\n * Result from function execution\n */\nexport interface FunctionResult {\n  success: boolean;\n  data?: unknown;\n  error?: FunctionError;\n  /**\n   * Human-readable message about the result\n   */\n  message?: string;\n}\n\nexport interface FunctionError {\n  code: string;\n  message: string;\n  details?: unknown;\n}\n\n/**\n * Helper class for creating function results\n */\nexport class FunctionResponse {\n  static success(data: unknown, message?: string): FunctionResult {\n    return {\n      success: true,\n      data,\n      message,\n    };\n  }\n  \n  static error(error: string | FunctionError, details?: unknown): FunctionResult {\n    if (typeof error === 'string') {\n      return {\n        success: false,\n        error: {\n          code: 'FUNCTION_ERROR',\n          message: error,\n          details,\n        },\n      };\n    }\n    return {\n      success: false,\n      error,\n    };\n  }\n  \n  static empty(): FunctionResult {\n    return {\n      success: true,\n    };\n  }\n}\n\n// ============================================\n// Error Types\n// ============================================\n\n/**\n * Base error class for all engine errors\n */\nexport class IdyllEngineError extends Error {\n  constructor(\n    message: string,\n    public code: string,\n    public details?: unknown\n  ) {\n    super(message);\n    this.name = 'IdyllEngineError';\n  }\n}\n\n/**\n * Error during document parsing\n */\nexport class ParseError extends IdyllEngineError {\n  constructor(message: string, details?: unknown) {\n    super(message, 'PARSE_ERROR', details);\n    this.name = 'ParseError';\n  }\n}\n\n/**\n * Error during document validation\n */\nexport class ValidationError extends IdyllEngineError {\n  constructor(\n    message: string,\n    public errors: string[],\n    details?: unknown\n  ) {\n    super(message, 'VALIDATION_ERROR', details);\n    this.name = 'ValidationError';\n  }\n}\n\n/**\n * Error during function execution\n */\nexport class FunctionExecutionError extends IdyllEngineError {\n  constructor(\n    message: string,\n    public functionName: string,\n    public nodeId?: string,\n    details?: unknown\n  ) {\n    super(message, 'FUNCTION_EXECUTION_ERROR', details);\n    this.name = 'FunctionExecutionError';\n  }\n}\n\n/**\n * Error when a function is not found\n */\nexport class FunctionNotFoundError extends IdyllEngineError {\n  constructor(functionName: string) {\n    super(`Function not found: ${functionName}`, 'FUNCTION_NOT_FOUND', { functionName });\n    this.name = 'FunctionNotFoundError';\n  }\n}\n\n/**\n * Error during agent execution\n */\nexport class AgentExecutionError extends IdyllEngineError {\n  constructor(\n    message: string,\n    public agentId: string,\n    details?: unknown\n  ) {\n    super(message, 'AGENT_EXECUTION_ERROR', details);\n    this.name = 'AgentExecutionError';\n  }\n}\n\n// ============================================\n// Error Utilities\n// ============================================\n\n/**\n * Check if an error is an engine error\n */\nexport function isIdyllEngineError(error: unknown): error is IdyllEngineError {\n  return error instanceof IdyllEngineError;\n}\n\n/**\n * Format error for display\n */\nexport function formatError(error: unknown): string {\n  if (isIdyllEngineError(error)) {\n    return `${error.code}: ${error.message}`;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return String(error);\n}","/**\n * Grammar DSL Types and Builder Functions\n * \n * Provides the core types and helper functions for building grammars.\n */\n\n// ============================================\n// DSL Types\n// ============================================\n\nexport type Rule = \n  | TerminalRule\n  | SequenceRule\n  | ChoiceRule\n  | RepeatRule\n  | OptionalRule\n  | RefRule;\n\ninterface TerminalRule {\n  type: 'terminal';\n  element: string;\n  attributes?: Record<string, AttributeDef>;\n  content?: 'text' | 'rich' | 'json' | 'none';\n}\n\ninterface SequenceRule {\n  type: 'sequence';\n  rules: Rule[];\n}\n\ninterface ChoiceRule {\n  type: 'choice';\n  rules: Rule[];\n}\n\ninterface RepeatRule {\n  type: 'repeat';\n  rule: Rule;\n  min: number;\n  max: number | null; // null = unbounded\n}\n\ninterface OptionalRule {\n  type: 'optional';\n  rule: Rule;\n}\n\ninterface RefRule {\n  type: 'ref';\n  name: string;\n}\n\nexport interface AttributeDef {\n  type: 'string' | 'number' | 'boolean' | 'enum';\n  required?: boolean;\n  values?: readonly string[];\n  pattern?: RegExp;\n  validate?: (value: unknown) => string | null;\n  default?: any;\n}\n\n// ============================================\n// DSL Builder Functions\n// ============================================\n\nexport function terminal(element: string, attrs?: Record<string, AttributeDef>, content?: 'text' | 'rich' | 'json' | 'none'): TerminalRule {\n  return { type: 'terminal', element, attributes: attrs, content };\n}\n\nexport function seq(...rules: (Rule | string)[]): SequenceRule {\n  return { \n    type: 'sequence', \n    rules: rules.map(r => typeof r === 'string' ? ref(r) : r)\n  };\n}\n\nexport function choice(...rules: (Rule | string)[]): ChoiceRule {\n  return { \n    type: 'choice', \n    rules: rules.map(r => typeof r === 'string' ? ref(r) : r)\n  };\n}\n\nexport function repeat(rule: Rule | string, min = 0, max: number | null = null): RepeatRule {\n  return { \n    type: 'repeat', \n    rule: typeof rule === 'string' ? ref(rule) : rule,\n    min, \n    max \n  };\n}\n\nexport function optional(rule: Rule | string): OptionalRule {\n  return { \n    type: 'optional', \n    rule: typeof rule === 'string' ? ref(rule) : rule\n  };\n}\n\nexport function ref(name: string): RefRule {\n  return { type: 'ref', name };\n}\n\n// Shorthand helpers\nexport const zeroOrMore = (rule: Rule | string) => repeat(rule, 0, null);\nexport const oneOrMore = (rule: Rule | string) => repeat(rule, 1, null);\nexport const zeroOrOne = optional;","/**\n * Grammar Compiler - Transforms grammar into usable structures\n * \n * This compiler takes our EBNF-style grammar and generates:\n * 1. Element-to-type mappings\n * 2. Validation functions\n * 3. AST type definitions\n * 4. Schema for backward compatibility\n */\n\nimport type { Rule, AttributeDef } from './dsl';\n\n// Define types locally since we removed schema.ts\nexport interface ElementSchema {\n  element: string;\n  type?: string;\n  block: boolean;\n  content?: 'text' | 'rich' | 'json' | 'none';\n  attributes?: Record<string, AttributeDef>;\n}\n\nexport interface ValidationError {\n  type: 'attribute' | 'content' | 'structure';\n  message: string;\n  path?: string;\n}\n\nexport interface CompiledGrammar {\n  // Element name -> AST type mapping\n  elementToType: Record<string, string>;\n  \n  // AST type -> element name(s) mapping\n  typeToElements: Record<string, string[]>;\n  \n  // Element name -> schema mapping (for compatibility)\n  elementSchemas: Record<string, ElementSchema>;\n  \n  // Validation functions\n  isValidElement: (element: string) => boolean;\n  isValidChild: (parentType: string, childElement: string) => boolean;\n  validateAttributes: (element: string, attrs: Record<string, unknown>) => ValidationError[];\n  \n  // Type information\n  blockTypes: Set<string>;\n  inlineElements: Set<string>;\n}\n\nexport class GrammarCompiler {\n  private grammar: Record<string, Rule>;\n  private compiled: CompiledGrammar | null = null;\n\n  constructor(grammar: Record<string, Rule>) {\n    this.grammar = grammar;\n  }\n\n  /**\n   * Compile the grammar into usable structures\n   */\n  compile(): CompiledGrammar {\n    if (this.compiled) return this.compiled;\n\n    const elementToType: Record<string, string> = {};\n    const typeToElements: Record<string, string[]> = {};\n    const elementSchemas: Record<string, ElementSchema> = {};\n    const blockTypes = new Set<string>();\n    const inlineElements = new Set<string>();\n\n    // First pass: collect all terminals and their types\n    const terminals = this.collectTerminals();\n    \n    // Build element mappings\n    for (const [ruleName, terminal] of terminals) {\n      const element = terminal.element;\n      if (element.startsWith('_')) continue; // Skip pseudo-elements\n\n      // Determine AST type\n      const astType = this.inferAstType(element, ruleName);\n      \n      // Element -> Type mapping\n      elementToType[element] = astType;\n      \n      // Type -> Elements mapping\n      if (!typeToElements[astType]) {\n        typeToElements[astType] = [];\n      }\n      typeToElements[astType].push(element);\n\n      // Build schema\n      elementSchemas[element] = {\n        element: element,\n        type: astType,\n        block: this.isBlockRule(ruleName),\n        attributes: terminal.attributes,\n        content: terminal.content as 'text' | 'rich' | 'json' | 'none' | undefined,\n      };\n\n      // Classify as block or inline\n      if (this.isBlockRule(ruleName)) {\n        blockTypes.add(astType);\n      } else if (this.isInlineRule(ruleName)) {\n        inlineElements.add(element);\n      }\n    }\n\n    // Build validation functions\n    const isValidElement = (element: string) => element in elementToType;\n    \n    const isValidChild = (parentType: string, childElement: string) => {\n      // Find rules that define valid children for this parent type\n      const rule = this.findRuleByType(parentType);\n      if (!rule) return false;\n      \n      return this.isValidInContext(rule, childElement);\n    };\n\n    const validateAttributes = (element: string, attrs: Record<string, unknown>) => {\n      const schema = elementSchemas[element];\n      if (!schema || !schema.attributes) return [];\n      \n      return this.validateAttrs(attrs, schema.attributes, element);\n    };\n\n    this.compiled = {\n      elementToType,\n      typeToElements,\n      elementSchemas,\n      isValidElement,\n      isValidChild,\n      validateAttributes,\n      blockTypes,\n      inlineElements,\n    };\n\n    return this.compiled;\n  }\n\n  /**\n   * Collect all terminal rules with their contexts\n   */\n  private collectTerminals(): Map<string, { element: string; attributes?: Record<string, AttributeDef>; content?: string }> {\n    const terminals = new Map();\n    const visited = new Set<string>();\n\n    const visit = (ruleName: string, rule: Rule) => {\n      // Avoid infinite recursion\n      const key = `${ruleName}:${JSON.stringify(rule)}`;\n      if (visited.has(key)) return;\n      visited.add(key);\n\n      switch (rule.type) {\n        case 'terminal':\n          terminals.set(ruleName, {\n            element: rule.element,\n            attributes: rule.attributes,\n            content: rule.content,\n          });\n          break;\n\n        case 'choice':\n        case 'sequence':\n          rule.rules.forEach((r, i) => {\n            if (r.type === 'ref') {\n              visit(r.name, this.grammar[r.name]);\n            } else {\n              visit(`${ruleName}[${i}]`, r);\n            }\n          });\n          break;\n\n        case 'repeat':\n        case 'optional':\n          if (rule.rule.type === 'ref') {\n            visit(rule.rule.name, this.grammar[rule.rule.name]);\n          } else {\n            visit(`${ruleName}:inner`, rule.rule);\n          }\n          break;\n\n        case 'ref':\n          if (this.grammar[rule.name]) {\n            visit(rule.name, this.grammar[rule.name]);\n          }\n          break;\n      }\n    };\n\n    // Start from all top-level rules\n    for (const [name, rule] of Object.entries(this.grammar)) {\n      visit(name, rule);\n    }\n\n    return terminals;\n  }\n\n  /**\n   * Infer AST type from element name and rule context\n   */\n  private inferAstType(element: string, ruleName: string): string {\n    // Special cases\n    const typeMap: Record<string, string> = {\n      'p': 'paragraph',\n      'paragraph': 'paragraph',\n      'h1': 'heading',\n      'h2': 'heading',\n      'h3': 'heading',\n      'h4': 'heading',\n      'h5': 'heading',\n      'h6': 'heading',\n      'heading': 'heading',\n      'fncall': 'function_call',\n      'bulletlistitem': 'bulletListItem',\n      'numberedlistitem': 'numberedListItem',\n      'checklistitem': 'checklistItem',\n      'function:description': '_function_description',\n      'function:definition': '_function_definition',\n    };\n\n    return typeMap[element] || element.replace(/[:-]/g, '_');\n  }\n\n  /**\n   * Check if a rule represents a block element\n   */\n  private isBlockRule(ruleName: string): boolean {\n    // Check if this rule is referenced by block-level rules\n    return ruleName.includes('block') || \n           ruleName === 'paragraph' ||\n           ruleName === 'heading' ||\n           ruleName === 'list' ||\n           ruleName === 'code' ||\n           ruleName === 'quote' ||\n           ruleName === 'separator' ||\n           ruleName === 'function-block';\n  }\n\n  /**\n   * Check if a rule represents an inline element\n   */\n  private isInlineRule(ruleName: string): boolean {\n    return ruleName.includes('styled-text') ||\n           ruleName === 'mention' ||\n           ruleName === 'variable' ||\n           ruleName === 'link' ||\n           ruleName === 'text';\n  }\n\n  /**\n   * Find a rule that produces the given AST type\n   */\n  private findRuleByType(astType: string): Rule | null {\n    // This is a simplified version - in practice we'd need a more\n    // sophisticated mapping from AST types back to grammar rules\n    const ruleMap: Record<string, string> = {\n      'function': 'function-block',\n      'list': 'list',\n      'function_call': 'function-call',\n      'trigger': 'trigger',\n    };\n\n    const ruleName = ruleMap[astType];\n    return ruleName ? this.grammar[ruleName] : null;\n  }\n\n  /**\n   * Check if an element is valid in a given context\n   */\n  private isValidInContext(rule: Rule, element: string): boolean {\n    switch (rule.type) {\n      case 'terminal':\n        return rule.element === element;\n\n      case 'choice':\n        return rule.rules.some(r => this.isValidInContext(r, element));\n\n      case 'sequence':\n        // Check all parts of sequence\n        return rule.rules.some(r => this.isValidInContext(r, element));\n\n      case 'repeat':\n      case 'optional':\n        return this.isValidInContext(rule.rule, element);\n\n      case 'ref':\n        const referenced = this.grammar[rule.name];\n        return referenced ? this.isValidInContext(referenced, element) : false;\n\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Validate attributes against schema\n   */\n  private validateAttrs(\n    attrs: Record<string, unknown>,\n    schema: Record<string, AttributeDef>,\n    element: string\n  ): ValidationError[] {\n    const errors: ValidationError[] = [];\n\n    // Check required attributes\n    for (const [name, def] of Object.entries(schema)) {\n      if (def.required && !(name in attrs)) {\n        errors.push({\n          type: 'attribute',\n          path: `${element}@${name}`,\n          message: `Required attribute missing: ${name}`,\n        });\n      }\n    }\n\n    // Validate present attributes\n    for (const [name, value] of Object.entries(attrs)) {\n      const def = schema[name];\n      if (!def) continue; // Unknown attributes allowed\n\n      // Type validation\n      if (def.type === 'enum' && def.values && !def.values.includes(value as string)) {\n        errors.push({\n          type: 'attribute',\n          path: `${element}@${name}`,\n          message: `Invalid value: must be one of ${def.values.join(', ')}`,\n        });\n      }\n\n      // Pattern validation\n      if (def.pattern && typeof value === 'string' && !def.pattern.test(value)) {\n        errors.push({\n          type: 'attribute',\n          path: `${element}@${name}`,\n          message: `Invalid format for ${name}`,\n        });\n      }\n\n      // Custom validation\n      if (def.validate) {\n        const error = def.validate(value);\n        if (error) {\n          errors.push({\n            type: 'attribute',\n            path: `${element}@${name}`,\n            message: error,\n          });\n        }\n      }\n    }\n\n    return errors;\n  }\n\n  /**\n   * Generate TypeScript AST types from grammar\n   */\n  generateTypes(): string {\n    const compiled = this.compile();\n    const types: string[] = [];\n\n    // Generate block type union\n    const blockTypeNames = Array.from(compiled.blockTypes)\n      .map(t => `'${t}'`)\n      .join(' | ');\n    types.push(`export type BlockType = ${blockTypeNames};`);\n\n    // Generate element mappings\n    types.push('\\nexport const ELEMENT_TO_TYPE = {');\n    for (const [element, type] of Object.entries(compiled.elementToType)) {\n      types.push(`  '${element}': '${type}',`);\n    }\n    types.push('} as const;');\n\n    return types.join('\\n');\n  }\n}","/**\n * Document Grammar for Idyll Documents\n * \n * Defines the structure for content documents with blocks and rich text.\n */\n\nimport { Rule, terminal, seq, choice, repeat, optional, ref, oneOrMore, zeroOrMore } from '../core/dsl';\n\nexport const DOCUMENT_GRAMMAR: Record<string, Rule> = {\n  // Document root\n  document: seq(\n    terminal('document', { \n      id: { type: 'string', required: false },\n      version: { type: 'string', required: false },\n      created: { type: 'string', required: false },\n      modified: { type: 'string', required: false }\n    }),\n    zeroOrMore('block')\n  ),\n\n  // Blocks\n  block: choice(\n    'content-block',\n    'executable-block', \n    'function-block'\n  ),\n\n  'content-block': choice(\n    'paragraph',\n    'heading',\n    'bullet-list-item',\n    'numbered-list-item',\n    'checklist-item',\n    'code',\n    'quote',\n    'separator',\n    'data'\n  ),\n\n  'executable-block': choice(\n    'function-call',\n    'trigger'\n  ),\n\n  // Content blocks\n  paragraph: choice(\n    terminal('p', {}, 'rich'),\n    terminal('paragraph', {}, 'rich') // legacy support\n  ),\n  \n  heading: choice(\n    terminal('h1', {}, 'rich'),\n    terminal('h2', {}, 'rich'),\n    terminal('h3', {}, 'rich'),\n    terminal('h4', {}, 'rich'),\n    terminal('h5', {}, 'rich'),\n    terminal('h6', {}, 'rich'),\n    terminal('heading', { // legacy support\n      level: { type: 'number', required: true, validate: (v: unknown) => {\n        const num = Number(v);\n        return num >= 1 && num <= 6 ? null : 'Level must be 1-6';\n      }}\n    }, 'rich')\n  ),\n\n  // List items (individual blocks, no containers)\n  'bullet-list-item': terminal('bulletlistitem', {}, 'rich'),\n  \n  'numbered-list-item': terminal('numberedlistitem', {}, 'rich'),\n  \n  'checklist-item': terminal('checklistitem', {\n    checked: { type: 'boolean', required: true }\n  }, 'rich'),\n\n  code: terminal('code', { \n    language: { type: 'string', required: false } \n  }, 'text'),\n\n  quote: terminal('quote', {\n    author: { type: 'string', required: false },\n    source: { type: 'string', required: false }\n  }, 'rich'),\n\n  separator: terminal('separator', {}, 'none'),\n  \n  data: terminal('data', {\n    title: { type: 'string', required: false }\n  }, 'text'),\n\n  // Executable blocks\n  'function-call': seq(\n    terminal('fncall', {\n      'idyll-fn': {\n        type: 'string',\n        required: true,\n        // Format: \\\"module:function\\\" or just \\\"function\\\" (e.g., \\\"demo:echo\\\", \\\"ai:analyzeText\\\", \\\"echo\\\")\n        // Module and function names MUST be valid JS identifiers\n        // For Azure Functions compatibility, transform at adapter layer:\n        // \\\"module:function\\\" → \\\"module--function\\\" (double hyphen separator)\n        pattern: /^([a-zA-Z_$][a-zA-Z0-9_$]*:)?[a-zA-Z_$][a-zA-Z0-9_$]*$/\n      },\n      modelId: { type: 'string', required: false }\n    }),\n    optional('params'),\n    optional('content'),\n    optional('result')\n  ),\n\n  trigger: seq(\n    terminal('trigger', {\n      'idyll-trigger': {\n        type: 'string',\n        required: true,\n        // Format: \\\"module:trigger\\\" or just \\\"trigger\\\" (e.g., \\\"time:schedule\\\", \\\"webhook:receive\\\", \\\"daily\\\")\n        // Module and trigger names MUST be valid JS identifiers\n        // For Azure Functions compatibility, transform at adapter layer:\n        // \\\"module:trigger\\\" → \\\"module--trigger\\\" (double hyphen separator)\n        pattern: /^([a-zA-Z_$][a-zA-Z0-9_$]*:)?[a-zA-Z_$][a-zA-Z0-9_$]*$/\n      },\n      enabled: { type: 'boolean', default: true }\n    }),\n    optional('params'),\n    optional('content')\n  ),\n\n  // Function blocks (custom function definitions)\n  'function-block': seq(\n    terminal('function', {\n      title: { type: 'string', required: true },\n      icon: { type: 'string', required: false }\n    }),\n    ref('function-description'),\n    ref('function-definition')\n  ),\n\n  'function-description': terminal('function:description', {}, 'text'),\n\n  'function-definition': seq(\n    terminal('function:definition'),\n    zeroOrMore(choice('content-block', 'executable-block')) // no nested function blocks!\n  ),\n\n  // Function call children\n  params: seq(\n    terminal('params'),\n    ref('json-content')\n  ),\n\n  content: seq(\n    terminal('content'),\n    ref('rich-content')\n  ),\n\n  result: seq(\n    terminal('result'),\n    ref('json-content')\n  ),\n\n  // Content types\n  'rich-content': zeroOrMore(choice(\n    'text',\n    'styled-text',\n    'mention',\n    'variable',\n    'link',\n    'annotation',\n    'annotated-text',\n    'ai-edit-response'\n  )),\n\n  'text-content': terminal('_text', {}, 'text'), // pseudo-element for plain text\n  'json-content': terminal('_json', {}, 'json'), // pseudo-element for JSON\n\n  // Inline elements\n  'styled-text': choice(\n    seq(choice(terminal('strong'), terminal('b')), ref('rich-content')),\n    seq(choice(terminal('em'), terminal('i')), ref('rich-content')),\n    seq(choice(terminal('u'), terminal('underline')), ref('rich-content')),\n    seq(choice(terminal('s'), terminal('strike'), terminal('del')), ref('rich-content')),\n    seq(choice(terminal('code'), terminal('tt')), ref('rich-content'))\n  ),\n  \n  annotation: seq(\n    terminal('annotation', {\n      title: { type: 'string', required: false },\n      comment: { type: 'string', required: false },\n      confidence: { type: 'number', required: false }\n    }),\n    ref('rich-content')\n  ),\n\n  mention: choice(\n    terminal('mention:user', { \n      id: { type: 'string', required: true },\n      label: { type: 'string', required: false }\n    }, 'text'),\n    terminal('mention:document', { \n      id: { type: 'string', required: true },\n      label: { type: 'string', required: false }\n    }, 'text'),\n    terminal('mention:agent', { \n      id: { type: 'string', required: true },\n      label: { type: 'string', required: false }\n    }, 'text'),\n    terminal('mention:custom', {\n      id: { type: 'string', required: true },\n      type: { type: 'string', required: true },\n      label: { type: 'string', required: false }\n    }, 'text')\n  ),\n\n  variable: terminal('variable', { \n    name: { type: 'string', required: true },\n    prompt: { type: 'string', required: false },\n    value: { type: 'string', required: false }\n  }, 'none'),\n\n  link: seq(\n    terminal('a', { \n      href: { type: 'string', required: true, pattern: /^https?:\\/\\/.+/ } \n    }),\n    ref('rich-content')\n  ),\n  \n  'annotated-text': seq(\n    terminal('annotatedtext', {\n      annotation: { type: 'string', required: true }\n    }),\n    ref('rich-content')\n  ),\n  \n  'ai-edit-response': seq(\n    terminal('aieditresponse', {\n      status: { type: 'enum', values: ['pending', 'accepted', 'rejected'] as const, required: true }\n    }),\n    ref('rich-content')\n  ),\n\n  text: terminal('_text', {}, 'text'), // Raw text node\n};","/**\n * Agent Grammar for Idyll System Prompts\n * \n * Defines the structure for agent documents containing system prompts.\n */\n\nimport { Rule, terminal, seq, zeroOrMore } from '../core/dsl';\n\nexport const AGENT_GRAMMAR: Record<string, Rule> = {\n  // Agent system prompt root\n  agent: seq(\n    terminal('agent', {\n      id: { type: 'string', required: false },\n      name: { type: 'string', required: false },\n      description: { type: 'string', required: false },\n      model: { type: 'string', required: false }\n    }),\n    zeroOrMore('block')\n  )\n};\n\n// Note: Agent grammar references 'block' from document grammar\n// This will be resolved when grammars are combined","/**\n * Diff Grammar for Idyll Document Transformations\n * \n * Defines the structure for diff operations that modify documents.\n */\n\nimport { Rule, terminal, seq, oneOrMore, choice, ref } from '../core/dsl';\n\nexport const DIFF_GRAMMAR: Record<string, Rule> = {\n  // Diff operations root\n  diff: seq(\n    terminal('diff', {\n      targetDocument: { type: 'string', required: false },\n      timestamp: { type: 'string', required: false }\n    }),\n    oneOrMore('edit-operation')\n  ),\n\n  // Edit operations\n  'edit-operation': choice(\n    'edit-attr',\n    'edit-content',\n    'edit-params',\n    'edit-id',\n    'insert',\n    'delete',\n    'replace',\n    'move'\n  ),\n\n  'edit-attr': terminal('edit:attr', {\n    'block-id': { type: 'string', required: true },\n    name: { type: 'string', required: true },\n    value: { type: 'string', required: true }\n  }, 'none'),\n\n  'edit-content': seq(\n    terminal('edit:content', {\n      'block-id': { type: 'string', required: true }\n    }),\n    ref('rich-content')\n  ),\n\n  'edit-params': seq(\n    terminal('edit:params', {\n      'block-id': { type: 'string', required: true }\n    }),\n    ref('json-content')\n  ),\n\n  'edit-id': terminal('edit:id', {\n    'block-id': { type: 'string', required: true },\n    value: { type: 'string', required: true }\n  }, 'none'),\n\n  insert: seq(\n    terminal('insert', {\n      'after-block-id': { type: 'string', required: false },\n      'before-block-id': { type: 'string', required: false },\n      'at-start': { type: 'boolean', required: false },\n      'at-end': { type: 'boolean', required: false }\n    }),\n    oneOrMore('block')\n  ),\n\n  delete: terminal('delete', {\n    'block-id': { type: 'string', required: true }\n  }, 'none'),\n\n  replace: seq(\n    terminal('replace', {\n      'block-id': { type: 'string', required: true }\n    }),\n    oneOrMore('block')\n  ),\n\n  move: terminal('move', {\n    'block-id': { type: 'string', required: false },\n    'block-ids': { type: 'string', required: false },\n    'from-block-id': { type: 'string', required: false },\n    'to-block-id': { type: 'string', required: false },\n    'after-block-id': { type: 'string', required: false },\n    'before-block-id': { type: 'string', required: false },\n    'at-start': { type: 'boolean', required: false },\n    'at-end': { type: 'boolean', required: false }\n  }, 'none')\n};\n\n// Note: Diff grammar references 'rich-content', 'json-content', and 'block' \n// from document grammar. These will be resolved when grammars are combined","/**\n * Grammar Schemas - Combined Export\n * \n * Exports all grammar definitions for different document types.\n */\n\n// Re-export individual grammars\nexport { DOCUMENT_GRAMMAR } from './document';\nexport { AGENT_GRAMMAR } from './agent';\nexport { DIFF_GRAMMAR } from './diff';\n\n// Combine all grammars into a single object (matches the current structure)\nimport { DOCUMENT_GRAMMAR } from './document';\nimport { AGENT_GRAMMAR } from './agent';\nimport { DIFF_GRAMMAR } from './diff';\n\nexport const GRAMMAR = {\n  ...DOCUMENT_GRAMMAR,\n  ...AGENT_GRAMMAR,\n  ...DIFF_GRAMMAR,\n};","/**\n * Zod validation schemas for Idyllic AST types\n * \n * Provides runtime validation that complements TypeScript compile-time types.\n * These schemas validate:\n * - XML parser output → AST transformation\n * - Diff operations before application\n * - Function execution inputs/outputs\n * - Serialization roundtrip verification\n */\n\nimport { z } from 'zod';\nimport type {\n  IdyllDocument,\n  AgentDocument,\n  DiffDocument,\n  Node,\n  ContentNode,\n  ExecutableNode,\n  RichContent,\n  TextContent,\n  InlineElement,\n  MentionElement,\n  VariableElement,\n  LinkElement,\n  AnnotationElement,\n  EditOperation,\n  ExecutionResult,\n  ExecutionError,\n  ExecutableMetadata,\n  DocumentMetadata\n} from '../document/ast';\n\n// ============================================\n// Base Type Schemas\n// ============================================\n\n// UUID validation (though we allow any string IDs for flexibility)\nconst IdSchema = z.string().min(1);\n\n// Function name validation (namespace:function pattern)\nconst FunctionNameSchema = z.string().regex(\n  /^[\\w-]+:[\\w-]+$/,\n  'Function name must follow \"namespace:function\" pattern'\n);\n\n// ============================================\n// Rich Content Schemas\n// ============================================\n\nconst TextStyleSchema = z.enum([\n  'bold',\n  'italic', \n  'underline',\n  'strikethrough',\n  'code'\n]);\n\nconst TextContentSchema = z.object({\n  type: z.literal('text'),\n  text: z.string(),\n  styles: z.array(TextStyleSchema).optional()\n});\n\nconst MentionElementSchema = z.object({\n  type: z.literal('mention'),\n  mentionType: z.enum(['user', 'document', 'agent', 'custom']),\n  id: IdSchema,\n  label: z.string().optional()\n});\n\nconst VariableElementSchema = z.object({\n  type: z.literal('variable'),\n  name: z.string().min(1),\n  prompt: z.string().optional(),\n  value: z.string().optional()\n});\n\n// Simplified LinkElement schema (allowing any content for now)\nconst LinkElementSchema = z.object({\n  type: z.literal('link'),\n  href: z.string().url(),\n  content: z.array(z.any()) // Simplified to avoid circular reference\n});\n\n// Simplified AnnotationElement schema\nconst AnnotationElementSchema = z.object({\n  type: z.literal('annotation'),\n  content: z.array(z.any()), // Simplified to avoid circular reference\n  annotation: z.object({\n    title: z.string().optional(),\n    comment: z.string().optional(),\n    confidence: z.number().min(0).max(1).optional()\n  }).catchall(z.any())\n});\n\nconst InlineElementSchema = z.union([\n  MentionElementSchema,\n  VariableElementSchema,\n  LinkElementSchema,\n  AnnotationElementSchema\n]);\n\nconst RichContentSchema = z.union([\n  TextContentSchema,\n  MentionElementSchema,\n  VariableElementSchema,\n  LinkElementSchema,\n  AnnotationElementSchema\n]);\n\n// ============================================\n// Execution Result Schemas  \n// ============================================\n\nconst ExecutionErrorSchema = z.object({\n  code: z.string(),\n  message: z.string(),\n  details: z.any().optional()\n});\n\nconst ExecutionResultSchema = z.object({\n  success: z.boolean(),\n  data: z.any().optional(),\n  error: ExecutionErrorSchema.optional(),\n  timestamp: z.date().optional()\n});\n\nconst ExecutableMetadataSchema = z.object({\n  enabled: z.boolean().optional(),\n  modelId: z.string().optional()\n}).catchall(z.any());\n\n// ============================================\n// Node Schemas\n// ============================================\n\nconst ContentNodeTypeSchema = z.enum([\n  'paragraph',\n  'heading', \n  'bulletListItem',\n  'numberedListItem',\n  'checklistItem',\n  'code',\n  'quote',\n  'separator',\n  'data',\n  'function'\n]);\n\nconst ExecutableNodeTypeSchema = z.enum([\n  'function_call',\n  'trigger'\n]);\n\n// Simplified ContentNode schema (children validation will be limited)\nconst ContentNodeSchema = z.object({\n  id: IdSchema,\n  type: ContentNodeTypeSchema,\n  content: z.array(RichContentSchema),\n  children: z.array(z.any()).optional(), // Simplified to avoid circular reference\n  props: z.object({}).passthrough().optional()\n});\n\nconst ExecutableNodeSchema = z.object({\n  id: IdSchema,\n  type: ExecutableNodeTypeSchema,\n  fn: FunctionNameSchema,\n  parameters: z.object({}).passthrough(),\n  content: z.array(RichContentSchema).optional(),\n  result: ExecutionResultSchema.optional(),\n  metadata: ExecutableMetadataSchema.optional(),\n  props: z.object({}).passthrough().optional()\n});\n\nconst NodeSchema = z.union([\n  ContentNodeSchema,\n  ExecutableNodeSchema\n]);\n\n// ============================================\n// Edit Operation Schemas\n// ============================================\n\nconst EditAttrOperationSchema = z.object({\n  type: z.literal('edit:attr'),\n  blockId: IdSchema,\n  name: z.string().min(1),\n  value: z.string()\n});\n\nconst EditContentOperationSchema = z.object({\n  type: z.literal('edit:content'),\n  blockId: IdSchema,\n  content: z.array(RichContentSchema)\n});\n\nconst EditParamsOperationSchema = z.object({\n  type: z.literal('edit:params'),\n  blockId: IdSchema,\n  params: z.object({}).passthrough()\n});\n\nconst EditIdOperationSchema = z.object({\n  type: z.literal('edit:id'),\n  blockId: IdSchema,\n  newId: IdSchema\n});\n\nconst InsertOperationSchema = z.object({\n  type: z.literal('insert'),\n  afterBlockId: IdSchema.optional(),\n  beforeBlockId: IdSchema.optional(),\n  atStart: z.boolean().optional(),\n  atEnd: z.boolean().optional(),\n  blocks: z.array(NodeSchema)\n}).refine(\n  (data) => {\n    // Exactly one position must be specified\n    const positionCount = [\n      data.afterBlockId,\n      data.beforeBlockId,\n      data.atStart,\n      data.atEnd\n    ].filter(Boolean).length;\n    return positionCount === 1;\n  },\n  {\n    message: 'Insert operation must specify exactly one position'\n  }\n);\n\nconst DeleteOperationSchema = z.object({\n  type: z.literal('delete'),\n  blockId: IdSchema\n});\n\nconst ReplaceOperationSchema = z.object({\n  type: z.literal('replace'),\n  blockId: IdSchema,\n  blocks: z.array(NodeSchema)\n});\n\nconst MoveOperationSchema = z.object({\n  type: z.literal('move'),\n  blockId: IdSchema.optional(),\n  blockIds: z.array(IdSchema).optional(),\n  fromBlockId: IdSchema.optional(),\n  toBlockId: IdSchema.optional(),\n  afterBlockId: IdSchema.optional(),\n  beforeBlockId: IdSchema.optional(),\n  atStart: z.boolean().optional(),\n  atEnd: z.boolean().optional()\n}).refine(\n  (data) => {\n    // Must specify what to move\n    const sourceCount = [\n      data.blockId,\n      data.blockIds,\n      data.fromBlockId && data.toBlockId\n    ].filter(Boolean).length;\n    \n    // Must specify where to move to\n    const targetCount = [\n      data.afterBlockId,\n      data.beforeBlockId,\n      data.atStart,\n      data.atEnd\n    ].filter(Boolean).length;\n    \n    return sourceCount === 1 && targetCount === 1;\n  },\n  {\n    message: 'Move operation must specify exactly one source and one target'\n  }\n);\n\nconst EditOperationSchema = z.union([\n  EditAttrOperationSchema,\n  EditContentOperationSchema,\n  EditParamsOperationSchema,\n  EditIdOperationSchema,\n  InsertOperationSchema,\n  DeleteOperationSchema,\n  ReplaceOperationSchema,\n  MoveOperationSchema\n]);\n\n// ============================================\n// Document Schemas\n// ============================================\n\nconst DocumentMetadataSchema = z.object({\n  version: z.string().optional(),\n  created: z.date().optional(),\n  modified: z.date().optional()\n}).catchall(z.any());\n\nconst IdyllDocumentSchema = z.object({\n  id: IdSchema,\n  nodes: z.array(NodeSchema),\n  metadata: DocumentMetadataSchema.optional()\n});\n\nconst AgentDocumentSchema = z.object({\n  type: z.literal('agent'),\n  id: IdSchema,\n  name: z.string().optional(),\n  description: z.string().optional(),\n  model: z.string().optional(),\n  nodes: z.array(NodeSchema)\n});\n\nconst DiffDocumentSchema = z.object({\n  type: z.literal('diff'),\n  targetDocument: z.string().optional(),\n  timestamp: z.date(),\n  operations: z.array(EditOperationSchema)\n});\n\n// ============================================\n// Validation Functions\n// ============================================\n\n/**\n * Validate a complete Idyll document\n */\nexport function validateDocument(data: unknown): IdyllDocument {\n  return IdyllDocumentSchema.parse(data);\n}\n\n/**\n * Validate an agent document\n */\nexport function validateAgentDocument(data: unknown): AgentDocument {\n  return AgentDocumentSchema.parse(data);\n}\n\n/**\n * Validate a diff document\n */\nexport function validateDiffDocument(data: unknown): DiffDocument {\n  return DiffDocumentSchema.parse(data);\n}\n\n/**\n * Validate a single node\n */\nexport function validateNode(data: unknown): Node {\n  return NodeSchema.parse(data);\n}\n\n/**\n * Validate an array of nodes\n */\nexport function validateNodes(data: unknown): Node[] {\n  return z.array(NodeSchema).parse(data);\n}\n\n/**\n * Validate rich content\n */\nexport function validateRichContent(data: unknown): RichContent {\n  return RichContentSchema.parse(data);\n}\n\n/**\n * Validate an edit operation\n */\nexport function validateEditOperation(data: unknown): EditOperation {\n  return EditOperationSchema.parse(data);\n}\n\n/**\n * Validate an array of edit operations\n */\nexport function validateEditOperations(data: unknown): EditOperation[] {\n  return z.array(EditOperationSchema).parse(data);\n}\n\n/**\n * Safe validation that returns result with error information\n */\nexport function safeValidateDocument(data: unknown): {\n  success: true;\n  data: IdyllDocument;\n} | {\n  success: false;\n  error: z.ZodError;\n} {\n  const result = IdyllDocumentSchema.safeParse(data);\n  if (result.success) {\n    return { success: true, data: result.data };\n  } else {\n    return { success: false, error: result.error };\n  }\n}\n\n/**\n * Safe validation for edit operations\n */\nexport function safeValidateEditOperation(data: unknown): {\n  success: true;\n  data: EditOperation;\n} | {\n  success: false;\n  error: z.ZodError;\n} {\n  const result = EditOperationSchema.safeParse(data);\n  if (result.success) {\n    return { success: true, data: result.data };\n  } else {\n    return { success: false, error: result.error };\n  }\n}\n\n// Export all schemas for external use\nexport {\n  IdyllDocumentSchema,\n  AgentDocumentSchema,\n  DiffDocumentSchema,\n  NodeSchema,\n  ContentNodeSchema,\n  ExecutableNodeSchema,\n  RichContentSchema,\n  TextContentSchema,\n  InlineElementSchema,\n  EditOperationSchema,\n  DocumentMetadataSchema\n};","/**\n * Document Executor for Idyllic Engine\n * \n * Handles execution of executable nodes within documents,\n * maintaining execution state and providing context to functions.\n */\n\nimport { z } from 'zod';\nimport type { \n  IdyllDocument, \n  Node, \n  ExecutableNode, \n  RichContent \n} from './ast';\nimport type {\n  ExecutionState,\n  ExecutionReport,\n  ExecutionOptions,\n  NodeExecutionResult,\n  NodeExecutionContext,\n  NodeExecutionError,\n  ExecutionMetadata,\n  ExecutionRequest,\n  ExecutionHooks,\n} from './execution-types';\nimport { AbstractFunctionExecutor } from './abstract-function-executor';\n\nexport class DocumentExecutor<TApi = any> extends AbstractFunctionExecutor {\n  private options: ExecutionOptions<TApi>;\n  \n  constructor(options: ExecutionOptions<TApi>) {\n    super(options.hooks);\n    this.options = {\n      stopOnError: false,\n      timeout: 30000,\n      ...options,\n    };\n  }\n  \n  /**\n   * Execute a single node or entire document\n   */\n  async execute(request: ExecutionRequest): Promise<ExecutionReport> {\n    if (request.mode === 'single') {\n      return this.executeSingleNode(request.document, (request as any).nodeId!);\n    } else {\n      return this.executeDocument(request.document);\n    }\n  }\n  \n  /**\n   * Execute all executable nodes in a document\n   */\n  async executeDocument(document: IdyllDocument): Promise<ExecutionReport> {\n    const startTime = new Date();\n    const state: ExecutionState = new Map();\n    \n    // Find all executable nodes\n    const executableNodes = this.findExecutableNodes(document.nodes);\n    const total = executableNodes.length;\n    \n    // Execute nodes sequentially\n    for (let i = 0; i < executableNodes.length; i++) {\n      const node = executableNodes[i];\n      \n      // Progress callback\n      this.options.onProgress?.(node.id, i + 1, total);\n      \n      // Create context for this node\n      const context: NodeExecutionContext & { api?: TApi } = {\n        currentNodeId: node.id,\n        previousResults: new Map(state), // Copy current state\n        document,\n        api: this.options.api,\n      };\n      \n      // Execute the node using shared execution logic\n      const func = this.options.functions[node.fn];\n      if (!func) {\n        const errorResult: NodeExecutionResult = {\n          success: false,\n          error: {\n            message: `Function not found: ${node.fn}`,\n            code: 'FUNCTION_NOT_FOUND',\n            details: { functionName: node.fn }\n          },\n          duration: 0,\n          timestamp: new Date(),\n        };\n        state.set(node.id, errorResult);\n        continue;\n      }\n      \n      // Validate parameters\n      let validatedParams: any;\n      try {\n        validatedParams = func.schema.parse(node.parameters);\n      } catch (error) {\n        const errorResult: NodeExecutionResult = {\n          success: false,\n          error: {\n            message: error instanceof z.ZodError \n              ? `Invalid parameters: ${error.issues.map((e: any) => e.message).join(', ')}`\n              : 'Parameter validation failed',\n            code: 'INVALID_PARAMETERS',\n            details: error\n          },\n          duration: 0,\n          timestamp: new Date(),\n        };\n        state.set(node.id, errorResult);\n        continue;\n      }\n      \n      // Extract content as string\n      const content = this.extractContent(node.content);\n      \n      // Execute using shared logic with hooks\n      const result = await this.executeFunction(node.fn, func, validatedParams, content, context);\n      state.set(node.id, result);\n      \n      // Stop on error if requested\n      if (!result.success && this.options.stopOnError) {\n        break;\n      }\n    }\n    \n    const endTime = new Date();\n    \n    // Calculate metadata\n    const metadata: ExecutionMetadata = {\n      startTime,\n      endTime,\n      totalDuration: endTime.getTime() - startTime.getTime(),\n      nodesExecuted: state.size,\n      nodesSucceeded: Array.from(state.values()).filter(r => r.success).length,\n      nodesFailed: Array.from(state.values()).filter(r => !r.success).length,\n    };\n    \n    return { nodes: state, metadata };\n  }\n  \n  /**\n   * Execute a single node by ID\n   */\n  async executeSingleNode(\n    document: IdyllDocument, \n    nodeId: string\n  ): Promise<ExecutionReport> {\n    const startTime = new Date();\n    const state: ExecutionState = new Map();\n    \n    // Find the node\n    const node = this.findNodeById(document.nodes || (document as any).blocks, nodeId);\n    if (!node) {\n      throw new Error(`Node with ID ${nodeId} not found`);\n    }\n    \n    if (!this.isExecutableNode(node)) {\n      throw new Error(`Node ${nodeId} is not executable`);\n    }\n    \n    // Build context with previous results (all nodes before this one)\n    const previousResults = this.getPreviousResults(document, nodeId);\n    \n    const context: NodeExecutionContext & { api?: TApi } = {\n      currentNodeId: nodeId,\n      previousResults,\n      document,\n      api: this.options.api,\n    };\n    \n    // Execute the node using shared execution logic\n    const executableNode = node as ExecutableNode;\n    const func = this.options.functions[executableNode.fn];\n    if (!func) {\n      throw new Error(`Function not found: ${executableNode.fn}`);\n    }\n    \n    // Validate parameters\n    let validatedParams: any;\n    try {\n      validatedParams = func.schema.parse(executableNode.parameters);\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        throw new Error(`Invalid parameters: ${error.issues.map((e: any) => e.message).join(', ')}`);\n      }\n      throw error;\n    }\n    \n    // Extract content as string\n    const content = this.extractContent(executableNode.content);\n    \n    // Execute using shared logic with hooks\n    const result = await this.executeFunction(executableNode.fn, func, validatedParams, content, context);\n    state.set(nodeId, result);\n    \n    const endTime = new Date();\n    \n    const metadata: ExecutionMetadata = {\n      startTime,\n      endTime,\n      totalDuration: endTime.getTime() - startTime.getTime(),\n      nodesExecuted: 1,\n      nodesSucceeded: result.success ? 1 : 0,\n      nodesFailed: result.success ? 0 : 1,\n    };\n    \n    return { nodes: state, metadata };\n  }\n  \n  \n  /**\n   * Find all executable nodes in document\n   */\n  private findExecutableNodes(nodes: Node[]): ExecutableNode[] {\n    const executable: ExecutableNode[] = [];\n    \n    for (const node of nodes) {\n      if (this.isExecutableNode(node)) {\n        executable.push(node as ExecutableNode);\n      }\n      \n      // Check children recursively\n      if ('children' in node && node.children) {\n        executable.push(...this.findExecutableNodes(node.children));\n      }\n    }\n    \n    return executable;\n  }\n  \n  /**\n   * Find a node by ID\n   */\n  private findNodeById(nodes: Node[], id: string): Node | null {\n    for (const node of nodes) {\n      if (node.id === id) {\n        return node;\n      }\n      \n      // Check children\n      if ('children' in node && node.children) {\n        const found = this.findNodeById(node.children, id);\n        if (found) return found;\n      }\n    }\n    \n    return null;\n  }\n  \n  /**\n   * Get results from all nodes before the given node\n   */\n  private getPreviousResults(document: IdyllDocument, beforeNodeId: string): ExecutionState {\n    const results: ExecutionState = new Map();\n    const executableNodes = this.findExecutableNodes(document.nodes);\n    \n    // Find all nodes before the target node\n    for (const node of executableNodes) {\n      if (node.id === beforeNodeId) {\n        break;\n      }\n      // Note: We don't have actual results in this case, \n      // this would be populated from prior execution\n      // For now, return empty state\n    }\n    \n    return results;\n  }\n  \n  /**\n   * Check if a node is executable\n   */\n  private isExecutableNode(node: Node): boolean {\n    return node.type === 'function_call' || node.type === 'trigger';\n  }\n  \n  /**\n   * Extract text content from rich content\n   */\n  private extractContent(content?: RichContent[]): string {\n    if (!content) return '';\n    \n    return content\n      .map(item => {\n        if ('text' in item) {\n          return item.text;\n        }\n        return '';\n      })\n      .join('');\n  }\n}","/**\n * Abstract Function Executor\n * \n * Base class for all function execution strategies, providing\n * shared execution logic with hooks and instrumentation.\n */\n\nimport { \n  NodeExecutionContext, \n  ExecutionHooks, \n  FunctionDefinition,\n  NodeExecutionResult\n} from './execution-types';\n\n/**\n * Abstract base class for function execution with hooks and instrumentation\n */\nexport abstract class AbstractFunctionExecutor {\n  protected hooks: ExecutionHooks;\n  \n  constructor(hooks?: ExecutionHooks) {\n    this.hooks = hooks || {};\n  }\n  \n  /**\n   * Execute a function with shared hooks and instrumentation\n   */\n  protected async executeFunction(\n    functionName: string,\n    fndef: FunctionDefinition,\n    params: any,\n    content: string,\n    context: NodeExecutionContext\n  ): Promise<NodeExecutionResult> {\n    // Pre-execution hooks\n    await this.hooks.beforeExecution?.(functionName, params, context);\n    \n    const startTime = performance.now();\n    \n    try {\n      // Execute with timeout\n      const result = await this.executeWithTimeout(fndef.execute, params, content, context);\n      \n      const duration = performance.now() - startTime;\n      \n      // Post-execution hooks\n      await this.hooks.afterExecution?.(functionName, result, duration, context);\n      \n      return {\n        success: true,\n        data: result,\n        duration,\n        timestamp: new Date()\n      };\n    } catch (error) {\n      const duration = performance.now() - startTime;\n      \n      // Error hooks\n      await this.hooks.onError?.(functionName, error, duration, context);\n      \n      return {\n        success: false,\n        error: {\n          message: error instanceof Error ? error.message : 'Unknown error',\n          code: error instanceof Error && 'code' in error ? (error as any).code : undefined,\n          details: error\n        },\n        duration,\n        timestamp: new Date()\n      };\n    }\n  }\n  \n  /**\n   * Execute function implementation with timeout\n   */\n  private async executeWithTimeout(\n    impl: FunctionDefinition['execute'],\n    params: any,\n    content: string,\n    context: NodeExecutionContext,\n    timeout: number = 30000\n  ): Promise<unknown> {\n    return new Promise(async (resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        reject(new Error(`Function execution timed out after ${timeout}ms`));\n      }, timeout);\n      \n      try {\n        const result = await impl(params, content, context);\n        clearTimeout(timeoutId);\n        resolve(result);\n      } catch (error) {\n        clearTimeout(timeoutId);\n        reject(error);\n      }\n    });\n  }\n  \n  /**\n   * Abstract method for specific execution strategies\n   */\n  abstract execute(request: any): Promise<any>;\n}","/**\n * Function Registry for Idyllic Engine\n * \n * Provides utilities for managing and creating function registries\n * with proper type safety and validation.\n */\n\nimport { z } from 'zod';\nimport type { FunctionRegistry, FunctionDefinition, NodeExecutionContext } from './execution-types';\n\n// Re-export types for external use\nexport type { FunctionRegistry, FunctionDefinition } from './execution-types';\n\n/**\n * Create a type-safe function registry\n */\nexport function createFunctionRegistry<TApi = any>(\n  functions: FunctionRegistry<TApi>\n): FunctionRegistry<TApi> {\n  return functions;\n}\n\n/**\n * Define a single function with type inference\n */\nexport function defineFunction<TParams = any, TApi = any>(\n  definition: {\n    schema: z.ZodSchema<TParams>;\n    execute: (params: TParams, content: string, context: NodeExecutionContext & { api?: TApi }) => Promise<any> | any;\n    description?: string;\n  }\n): FunctionDefinition<TParams, TApi> {\n  return definition;\n}\n\n/**\n * Merge multiple function registries\n */\nexport function mergeFunctionRegistries<TApi = any>(\n  ...registries: FunctionRegistry<TApi>[]\n): FunctionRegistry<TApi> {\n  return registries.reduce((merged, registry) => {\n    return { ...merged, ...registry };\n  }, {} as FunctionRegistry<TApi>);\n}\n\n/**\n * Create a function registry from a simple function map\n * (for quick testing without schemas)\n */\nexport function createSimpleRegistry<TApi = any>(\n  functions: Record<string, (params: any, content: string, context?: NodeExecutionContext & { api?: TApi }) => any>\n): FunctionRegistry<TApi> {\n  const registry: FunctionRegistry<TApi> = {};\n  \n  for (const [name, fn] of Object.entries(functions)) {\n    registry[name] = {\n      schema: z.any(), // Accept any params\n      execute: (params, content, context) => fn(params, content, context),\n    };\n  }\n  \n  return registry;\n}","/**\n * Function naming utilities for Idyll Engine\n * \n * Handles transformation between Idyll function names (module:function) \n * and external platform requirements.\n */\n\n/**\n * Transform Idyll function name to Azure function name\n * \"module:function\" → \"module--function\"\n * \"function\" → \"function\" (no module)\n */\nexport function toAzureFunctionName(idyllFunctionName: string): string {\n  return idyllFunctionName.replace(':', '--');\n}\n\n/**\n * Transform Azure function name back to Idyll function name\n * \"module--function\" → \"module:function\"\n * \"function\" → \"function\" (no module)\n */\nexport function fromAzureFunctionName(azureFunctionName: string): string {\n  // Double hyphen is our separator\n  if (azureFunctionName.includes('--')) {\n    return azureFunctionName.replace('--', ':');\n  }\n  // No separator means no module namespace\n  return azureFunctionName;\n}\n\n/**\n * Validate that a function name follows Idyll conventions\n * Must be valid JS identifiers: [module:]function\n */\nexport function validateFunctionName(functionName: string): { valid: boolean; error?: string } {\n  const pattern = /^([a-zA-Z_$][a-zA-Z0-9_$]*:)?[a-zA-Z_$][a-zA-Z0-9_$]*$/;\n  \n  if (!pattern.test(functionName)) {\n    return {\n      valid: false,\n      error: 'Function name must be valid JS identifiers in format \"module:function\" or \"function\"'\n    };\n  }\n  \n  return { valid: true };\n}\n\n/**\n * Parse a function name into module and function parts\n */\nexport function parseFunctionName(functionName: string): { module?: string; function: string } {\n  const colonIndex = functionName.indexOf(':');\n  \n  if (colonIndex === -1) {\n    return { function: functionName };\n  }\n  \n  return {\n    module: functionName.substring(0, colonIndex),\n    function: functionName.substring(colonIndex + 1)\n  };\n}\n\n/**\n * Build a function name from module and function parts\n */\nexport function buildFunctionName(module: string | undefined, functionName: string): string {\n  return module ? `${module}:${functionName}` : functionName;\n}\n\n","/**\n * Document validation logic\n */\n\nimport {\n  Node,\n  IdyllDocument,\n  isExecutableNode,\n  extractMentions,\n  extractVariables,\n  traverseNodes,\n} from './ast';\nimport { ValidationContext, ValidationError } from '../types';\n\n// ============================================\n// Validation Types\n// ============================================\n\nexport interface ValidationResult {\n  valid: boolean;\n  errors: ValidationIssue[];\n  warnings: ValidationIssue[];\n}\n\nexport interface ValidationIssue {\n  type: 'error' | 'warning';\n  code: string;\n  message: string;\n  nodeId?: string;\n  path?: string[];\n}\n\n// ============================================\n// Main Validation Function\n// ============================================\n\n/**\n * Validate a document structure and optionally its references\n */\nexport async function validateDocument(\n  document: IdyllDocument,\n  context?: ValidationContext\n): Promise<ValidationResult> {\n  const errors: ValidationIssue[] = [];\n  const warnings: ValidationIssue[] = [];\n  \n  // Phase 1: Structure validation\n  validateStructure(document, errors, warnings);\n  \n  // Phase 2: Reference validation (if context provided)\n  if (context) {\n    await validateReferences(document, context, errors, warnings);\n  }\n  \n  return {\n    valid: errors.length === 0,\n    errors,\n    warnings,\n  };\n}\n\n// ============================================\n// Structure Validation\n// ============================================\n\n/**\n * Validate document structure\n */\nfunction validateStructure(\n  document: IdyllDocument,\n  errors: ValidationIssue[],\n  warnings: ValidationIssue[]\n): void {\n  // Validate document has an ID\n  if (!document.id) {\n    errors.push({\n      type: 'error',\n      code: 'MISSING_DOCUMENT_ID',\n      message: 'Document must have an ID',\n    });\n  }\n  \n  // Validate document has nodes\n  if (!document.nodes || document.nodes.length === 0) {\n    warnings.push({\n      type: 'warning',\n      code: 'EMPTY_DOCUMENT',\n      message: 'Document has no content nodes',\n    });\n  }\n  \n  // Validate each node\n  const nodeIds = new Set<string>();\n  for (const node of traverseNodes(document.nodes)) {\n    validateNode(node, nodeIds, errors, warnings);\n  }\n}\n\n/**\n * Validate a single node\n */\nfunction validateNode(\n  node: Node,\n  nodeIds: Set<string>,\n  errors: ValidationIssue[],\n  warnings: ValidationIssue[]\n): void {\n  const nodeId = node.id || 'unknown';\n  \n  // Check for duplicate IDs\n  if (node.id && nodeIds.has(node.id)) {\n    errors.push({\n      type: 'error',\n      code: 'DUPLICATE_NODE_ID',\n      message: `Duplicate node ID: ${node.id}`,\n      nodeId: node.id,\n    });\n  }\n  if (node.id) {\n    nodeIds.add(node.id);\n  }\n  \n  // Validate node has required fields\n  if (!node.id) {\n    errors.push({\n      type: 'error',\n      code: 'MISSING_NODE_ID',\n      message: 'Node must have an ID',\n    });\n  }\n  \n  if (!node.type) {\n    errors.push({\n      type: 'error',\n      code: 'MISSING_NODE_TYPE',\n      message: 'Node must have a type',\n      nodeId,\n    });\n    return; // Can't validate further without type\n  }\n  \n  // Validate executable nodes\n  if (isExecutableNode(node)) {\n    if (!node.fn) {\n      errors.push({\n        type: 'error',\n        code: 'MISSING_FUNCTION',\n        message: 'Executable node must specify a function',\n        nodeId,\n      });\n    }\n    \n    if (!node.parameters) {\n      warnings.push({\n        type: 'warning',\n        code: 'MISSING_PARAMETERS',\n        message: 'Executable node has no parameters',\n        nodeId,\n      });\n    }\n  }\n}\n\n// ============================================\n// Reference Validation\n// ============================================\n\n/**\n * Validate document references (mentions, variables, tools)\n */\nasync function validateReferences(\n  document: IdyllDocument,\n  context: ValidationContext,\n  errors: ValidationIssue[],\n  warnings: ValidationIssue[]\n): Promise<void> {\n  // Validate mentions\n  if (context.validateMention) {\n    const mentions = extractMentions(document.nodes);\n    for (const mention of mentions) {\n      if (!context.validateMention(mention)) {\n        errors.push({\n          type: 'error',\n          code: 'INVALID_MENTION',\n          message: `Invalid ${mention.mentionType} mention: ${mention.id}`,\n        });\n      }\n    }\n  }\n  \n  // Validate variables\n  if (context.validateVariable) {\n    const variables = extractVariables(document.nodes);\n    for (const variable of variables) {\n      const result = context.validateVariable(variable);\n      if (!result.valid) {\n        errors.push({\n          type: 'error',\n          code: 'INVALID_VARIABLE',\n          message: `Invalid variable: ${variable.name}`,\n        });\n      }\n    }\n  }\n  \n  // Validate functions\n  if (context.validateFunction) {\n    for (const node of traverseNodes(document.nodes)) {\n      if (isExecutableNode(node) && node.fn) {\n        if (!context.validateFunction(node.fn)) {\n          errors.push({\n            type: 'error',\n            code: 'INVALID_FUNCTION',\n            message: `Function not found: ${node.fn}`,\n            nodeId: node.id || 'unknown',\n          });\n        }\n      }\n    }\n  }\n}\n\n// ============================================\n// Validation Utilities\n// ============================================\n\n/**\n * Create a validation error from issues\n */\nexport function createValidationError(result: ValidationResult): ValidationError {\n  const errorMessages = result.errors.map(e => e.message);\n  return new ValidationError(\n    `Document validation failed with ${result.errors.length} error(s)`,\n    errorMessages,\n    { issues: result.errors }\n  );\n}\n\n/**\n * Format validation issues for display\n */\nexport function formatValidationIssues(issues: ValidationIssue[]): string {\n  return issues\n    .map(issue => {\n      const prefix = issue.type === 'error' ? '❌' : '⚠️';\n      const location = issue.nodeId ? ` (node: ${issue.nodeId})` : '';\n      return `${prefix} ${issue.message}${location}`;\n    })\n    .join('\\n');\n}","/**\n * Variable Resolution System for Idyllic Engine\n * \n * Handles the resolution of variables in custom functions using AI interpolation\n */\n\nimport type { Node, RichContent, VariableElement } from './ast';\nimport { isVariable, traverseNodes } from './ast';\n\n/**\n * Variable with metadata for resolution\n */\nexport interface VariableDefinition {\n  name: string;\n  prompt?: string;\n  firstOccurrenceBlockId: string;\n  firstOccurrenceIndex: number;\n}\n\n/**\n * Context for variable resolution\n */\nexport interface VariableResolutionContext {\n  /** Agent-provided context (rich content) */\n  agentContext: string;\n  \n  /** Document context (surrounding nodes) */\n  documentContext?: string;\n  \n  /** Inherited agent context/personality */\n  inheritedContext?: Record<string, unknown>;\n}\n\n/**\n * Variable resolution result\n */\nexport interface VariableResolutionResult {\n  /** Resolved variable values */\n  variables: Map<string, string>;\n  \n  /** Any errors during resolution */\n  errors?: Array<{ variable: string; error: string }>;\n}\n\n/**\n * Extract all unique variables from nodes\n * Follows declare-once, use-many pattern\n */\nexport function extractVariableDefinitions(nodes: Node[]): VariableDefinition[] {\n  const definitions = new Map<string, VariableDefinition>();\n  const seenNames = new Set<string>();\n  \n  let globalIndex = 0;\n  \n  for (const node of traverseNodes(nodes)) {\n    if ('content' in node && Array.isArray(node.content)) {\n      processContent(node.content, node.id);\n    }\n    \n    // Check executable node content\n    if ('content' in node && node.content) {\n      processContent(node.content, node.id);\n    }\n  }\n  \n  function processContent(content: RichContent[], blockId: string) {\n    for (const item of content) {\n      if (isVariable(item)) {\n        // First occurrence declares the variable\n        if (!seenNames.has(item.name)) {\n          seenNames.add(item.name);\n          definitions.set(item.name, {\n            name: item.name,\n            prompt: item.prompt,\n            firstOccurrenceBlockId: blockId,\n            firstOccurrenceIndex: globalIndex++,\n          });\n        }\n      } else if ('content' in item && Array.isArray(item.content)) {\n        // Recurse into nested content\n        processContent(item.content, blockId);\n      }\n    }\n  }\n  \n  return Array.from(definitions.values());\n}\n\n/**\n * Check for variable redeclaration errors\n */\nexport function checkVariableRedeclaration(nodes: Node[]): Array<{ name: string; error: string }> {\n  const errors: Array<{ name: string; error: string }> = [];\n  const declarations = new Map<string, { nodeId: string; prompt?: string }>();\n  \n  for (const node of traverseNodes(nodes)) {\n    const variables = extractVariablesFromNode(node);\n    \n    for (const variable of variables) {\n      const existing = declarations.get(variable.name);\n      \n      if (existing) {\n        // Check if it's a redeclaration (different prompt)\n        if (variable.prompt && existing.prompt !== variable.prompt) {\n          errors.push({\n            name: variable.name,\n            error: `Variable \"${variable.name}\" redeclared with different prompt. Original: \"${existing.prompt}\", New: \"${variable.prompt}\"`,\n          });\n        }\n      } else if (variable.prompt) {\n        // First declaration with prompt\n        declarations.set(variable.name, {\n          nodeId: node.id,\n          prompt: variable.prompt,\n        });\n      }\n    }\n  }\n  \n  return errors;\n}\n\n/**\n * Extract variables from a single node\n */\nfunction extractVariablesFromNode(node: Node): VariableElement[] {\n  const variables: VariableElement[] = [];\n  \n  function extractFromContent(content: RichContent[]) {\n    for (const item of content) {\n      if (isVariable(item)) {\n        variables.push(item);\n      } else if ('content' in item && Array.isArray(item.content)) {\n        extractFromContent(item.content);\n      }\n    }\n  }\n  \n  if ('content' in node && Array.isArray(node.content)) {\n    extractFromContent(node.content);\n  }\n  \n  if ('content' in node && node.content) {\n    extractFromContent(node.content);\n  }\n  \n  return variables;\n}\n\n/**\n * Resolve variables using AI interpolation or fallback to mock\n */\nexport async function resolveVariables(\n  definitions: VariableDefinition[],\n  context: VariableResolutionContext\n): Promise<VariableResolutionResult> {\n  // Use mock resolution (AI resolution removed - model should be provided externally if needed)\n  const variables = new Map<string, string>();\n  const errors: Array<{ variable: string; error: string }> = [];\n  \n  for (const def of definitions) {\n    try {\n      const resolvedValue = await mockResolveVariable(def, context);\n      variables.set(def.name, resolvedValue);\n    } catch (error) {\n      errors.push({\n        variable: def.name,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      });\n    }\n  }\n  \n  return { variables, errors: errors.length > 0 ? errors : undefined };\n}\n\n/**\n * Mock variable resolution for testing\n * Replace with actual AI implementation\n */\nasync function mockResolveVariable(\n  definition: VariableDefinition,\n  context: VariableResolutionContext\n): Promise<string> {\n  // Simulate AI resolution based on variable name and context\n  const contextLower = context.agentContext.toLowerCase();\n  \n  switch (definition.name) {\n    case 'searchQuery':\n      if (contextLower.includes('ai breakthroughs')) {\n        return 'AI breakthroughs 2024';\n      }\n      if (contextLower.includes('machine learning')) {\n        return 'machine learning advances';\n      }\n      return 'technology news';\n      \n    case 'timeframe':\n      if (contextLower.includes('past month') || contextLower.includes('last month')) {\n        return 'past month';\n      }\n      if (contextLower.includes('past week') || contextLower.includes('last week')) {\n        return 'past week';\n      }\n      return 'recent';\n      \n    case 'focusArea':\n      if (contextLower.includes('practical')) {\n        return 'practical applications';\n      }\n      if (contextLower.includes('research')) {\n        return 'research developments';\n      }\n      return 'general overview';\n      \n    default:\n      // Use prompt as hint for resolution\n      if (definition.prompt) {\n        return `Resolved: ${definition.name} (${definition.prompt})`;\n      }\n      return `Resolved: ${definition.name}`;\n  }\n}\n\n/**\n * Apply resolved variable values to nodes\n * Updates variable elements with resolvedValue\n */\nexport function applyResolvedVariables(\n  nodes: Node[],\n  resolvedVariables: Map<string, string>\n): Node[] {\n  // Deep clone nodes to avoid mutation\n  const clonedNodes = JSON.parse(JSON.stringify(nodes)) as Node[];\n  \n  for (const node of traverseNodes(clonedNodes)) {\n    if ('content' in node && Array.isArray(node.content)) {\n      node.content = applyToContent(node.content);\n    }\n    \n    if ('content' in node && node.content) {\n      node.content = applyToContent(node.content);\n    }\n  }\n  \n  function applyToContent(content: RichContent[]): RichContent[] {\n    return content.map(item => {\n      if (isVariable(item)) {\n        const resolvedValue = resolvedVariables.get(item.name);\n        if (resolvedValue !== undefined) {\n          return {\n            ...item,\n            resolvedValue,\n          } as VariableElement;\n        }\n      } else if ('content' in item && Array.isArray(item.content)) {\n        return {\n          ...item,\n          content: applyToContent(item.content),\n        };\n      }\n      return item;\n    });\n  }\n  \n  return clonedNodes;\n}\n\n/**\n * Get interpolated text content with variables replaced\n */\nexport function interpolateContent(\n  content: RichContent[],\n  resolvedVariables: Map<string, string>\n): string {\n  let result = '';\n  \n  for (const item of content) {\n    if (item.type === 'text') {\n      result += item.text;\n    } else if (isVariable(item)) {\n      const value = resolvedVariables.get(item.name);\n      result += value || `{{${item.name}}}`;\n    } else if ('content' in item && Array.isArray(item.content)) {\n      result += interpolateContent(item.content, resolvedVariables);\n    }\n  }\n  \n  return result;\n}","/**\n * Agent Custom Function Executor for Idyllic Engine\n * \n * Executes custom functions defined with <function> blocks in agent context,\n * handling variable resolution and multi-step execution\n */\n\nimport type { \n  Node,\n  ContentNode,\n  ExecutableNode,\n  IdyllDocument \n} from './ast';\nimport { isExecutableNode, getExecutableNodes } from './ast';\nimport type { \n  FunctionExecutionReport, \n  ExecutionOptions,\n  NodeExecutionResult,\n  ExecutionHooks\n} from './execution-types';\nimport { AbstractFunctionExecutor } from './abstract-function-executor';\nimport { DocumentExecutor } from './executor';\nimport {\n  extractVariableDefinitions,\n  checkVariableRedeclaration,\n  resolveVariables,\n  applyResolvedVariables,\n  interpolateContent,\n  type VariableResolutionContext,\n} from './variable-resolution';\n\n/**\n * Options for agent custom function execution\n */\nexport interface AgentCustomFunctionExecutionOptions<TApi = any> extends ExecutionOptions<TApi> {\n  /** Agent context provided when invoking the function */\n  agentContext: string;\n  \n  /** Inherited context from agent */\n  inheritedContext?: Record<string, unknown>;\n}\n\n/**\n * Agent Custom Function Executor class\n */\nexport class AgentCustomFunctionExecutor<TApi = any> extends AbstractFunctionExecutor {\n  private options: AgentCustomFunctionExecutionOptions<TApi>;\n  \n  constructor(options: AgentCustomFunctionExecutionOptions<TApi>) {\n    super(options.hooks);\n    this.options = options;\n  }\n  \n  async execute(functionNode: ContentNode): Promise<FunctionExecutionReport> {\n    return executeCustomFunction(functionNode, this.options);\n  }\n}\n\n/**\n * Execute a custom function defined as a ContentNode\n */\nexport async function executeCustomFunction<TApi = any>(\n  functionNode: ContentNode,\n  options: AgentCustomFunctionExecutionOptions<TApi>\n): Promise<FunctionExecutionReport> {\n  const startTime = Date.now();\n  \n  // Validate it's a function node\n  if (functionNode.type !== 'function') {\n    throw new Error('Node is not a function');\n  }\n  \n  const functionName = (functionNode.props?.title as string) || 'Unnamed Function';\n  \n  // Get function definition nodes (children)\n  const definitionNodes = functionNode.children || [];\n  \n  // Check for variable redeclaration errors\n  const redeclarationErrors = checkVariableRedeclaration(definitionNodes);\n  if (redeclarationErrors.length > 0) {\n    throw new Error(\n      `Variable redeclaration errors: ${redeclarationErrors.map(e => e.error).join('; ')}`\n    );\n  }\n  \n  // Extract variable definitions\n  const variableDefinitions = extractVariableDefinitions(definitionNodes);\n  \n  // Resolve variables\n  const resolutionContext: VariableResolutionContext = {\n    agentContext: options.agentContext,\n    inheritedContext: options.inheritedContext,\n  };\n  \n  const resolutionResult = await resolveVariables(variableDefinitions, resolutionContext);\n  \n  if (resolutionResult.errors) {\n    console.warn('Variable resolution errors:', resolutionResult.errors);\n  }\n  \n  // Apply resolved variables to nodes\n  const nodesWithVariables = applyResolvedVariables(\n    definitionNodes,\n    resolutionResult.variables\n  );\n  \n  // Interpolate content in executable nodes\n  const interpolatedNodes = interpolateExecutableNodes(\n    nodesWithVariables,\n    resolutionResult.variables\n  );\n  \n  // Create a document for execution\n  const executionDocument: IdyllDocument = {\n    id: `function-exec-${Date.now()}`,\n    nodes: interpolatedNodes,\n  };\n  \n  // Execute using DocumentExecutor (with shared hooks)\n  const executor = new DocumentExecutor(options);\n  const report = await executor.execute({\n    mode: 'document',\n    document: executionDocument,\n    options,\n  });\n  \n  // Build execution context\n  const executionContext: FunctionExecutionReport = {\n    variables: resolutionResult.variables,\n    nodes: report.nodes,\n    metadata: {\n      functionName: functionName,\n      duration: Date.now() - startTime,\n      nodesExecuted: report.metadata.nodesExecuted,\n      nodesSucceeded: report.metadata.nodesSucceeded,\n      nodesFailed: report.metadata.nodesFailed,\n    },\n    functionDefinition: functionNode,\n  };\n  \n  return executionContext;\n}\n\n/**\n * Interpolate variables in executable node content\n */\nfunction interpolateExecutableNodes(\n  nodes: Node[],\n  resolvedVariables: Map<string, string>\n): Node[] {\n  return nodes.map(node => {\n    if (isExecutableNode(node) && node.content) {\n      // Interpolate the content to create the content string\n      const interpolatedContent = interpolateContent(\n        node.content,\n        resolvedVariables\n      );\n      \n      // Return a modified node with interpolated content\n      // Note: We're modifying the content to be a simple text content\n      // In a real implementation, we might want to preserve the structure\n      return {\n        ...node,\n        content: [{\n          type: 'text',\n          text: interpolatedContent,\n        }],\n      } as ExecutableNode;\n    }\n    \n    // Recursively handle children\n    if ('children' in node && node.children) {\n      return {\n        ...node,\n        children: interpolateExecutableNodes(node.children, resolvedVariables),\n      };\n    }\n    \n    return node;\n  });\n}\n\n/**\n * Extract relevant result from function execution context\n * This would be used by the subprocess to return only what's needed\n */\nexport function extractRelevantResult(\n  context: FunctionExecutionReport,\n  extractionHint?: string\n): unknown {\n  // Get the last successful result by default\n  const results = Array.from(context.nodes.values());\n  const lastSuccess = results\n    .reverse()\n    .find(r => r.success);\n  \n  if (lastSuccess) {\n    return lastSuccess.data;\n  }\n  \n  // If no successful results, return error summary\n  const errors = results\n    .filter(r => !r.success)\n    .map(r => r.error?.message || 'Unknown error');\n  \n  return {\n    success: false,\n    errors,\n    functionName: context.metadata.functionName,\n  };\n}\n\n/**\n * Parse custom function from document\n */\nexport function parseCustomFunction(document: IdyllDocument): ContentNode | null {\n  for (const node of document.nodes) {\n    if ('type' in node && node.type === 'function') {\n      return node as ContentNode;\n    }\n  }\n  return null;\n}","/**\n * Diff Application Logic for Idyll Documents\n * \n * Applies edit operations to document nodes with proper error handling.\n */\n\nimport { \n  Node, \n  RichContent,\n  EditOperation, \n  EditAttrOperation,\n  EditContentOperation,\n  EditParamsOperation,\n  EditIdOperation,\n  InsertOperation,\n  DeleteOperation,\n  ReplaceOperation,\n  MoveOperation\n} from './ast';\nimport { \n  validateEditOperations, \n  validateNodes,\n  safeValidateEditOperation \n} from '../grammar/validation';\nimport { v4 as uuidv4 } from 'uuid';\n\nexport interface DiffResult {\n  success: boolean;\n  nodes?: Node[];\n  error?: string;\n  validationErrors?: string[];\n}\n\n/**\n * Apply a list of edit operations to document nodes with validation\n */\nexport function applyDiff(nodes: Node[], operations: EditOperation[]): DiffResult {\n  try {\n    // Validate input nodes\n    validateNodes(nodes);\n    \n    // Validate all operations before applying any\n    validateEditOperations(operations);\n    \n    let result = [...nodes];\n\n    for (const operation of operations) {\n      switch (operation.type) {\n        case 'edit:attr':\n          result = applyEditAttr(result, operation);\n          break;\n\n        case 'edit:content':\n          result = applyEditContent(result, operation);\n          break;\n\n        case 'edit:params':\n          result = applyEditParams(result, operation);\n          break;\n\n        case 'edit:id':\n          result = applyEditId(result, operation);\n          break;\n\n        case 'insert':\n          result = applyInsert(result, operation);\n          break;\n\n        case 'delete':\n          result = applyDelete(result, operation);\n          break;\n\n        case 'replace':\n          result = applyReplace(result, operation);\n          break;\n\n        case 'move':\n          result = applyMove(result, operation);\n          break;\n\n        default:\n          throw new Error(`Unknown operation type: ${(operation as any).type}`);\n      }\n    }\n\n    // Validate the final result\n    validateNodes(result);\n    \n    return { success: true, nodes: result };\n  } catch (error) {\n    return { \n      success: false, \n      nodes,\n      error: error instanceof Error ? error.message : String(error) \n    };\n  }\n}\n\n/**\n * Safe version of applyDiff that returns detailed validation errors\n */\nexport function safeApplyDiff(nodes: Node[], operations: EditOperation[]): DiffResult {\n  const validationErrors: string[] = [];\n  \n  try {\n    // Validate input nodes\n    validateNodes(nodes);\n  } catch (error) {\n    validationErrors.push(`Invalid input nodes: ${error instanceof Error ? error.message : String(error)}`);\n  }\n  \n  // Validate each operation individually for detailed error reporting\n  for (let i = 0; i < operations.length; i++) {\n    const validation = safeValidateEditOperation(operations[i]);\n    if (!validation.success) {\n      validationErrors.push(`Operation ${i}: ${validation.error.message}`);\n    }\n  }\n  \n  if (validationErrors.length > 0) {\n    return {\n      success: false,\n      nodes,\n      validationErrors\n    };\n  }\n  \n  // If validation passes, apply the diff normally\n  return applyDiff(nodes, operations);\n}\n\n// ============================================\n// Operation Application Functions\n// ============================================\n\nfunction applyEditAttr(nodes: Node[], op: EditAttrOperation): Node[] {\n  let found = false;\n  \n  const result = nodes.map(node => {\n    if (node.id === op.blockId) {\n      found = true;\n      return { \n        ...node, \n        props: { ...((node as any).props || {}), [op.name]: op.value } \n      };\n    }\n    \n    // Search in children for nested nodes (even though we prefer flat structure)\n    if ('children' in node && node.children && node.children.length > 0) {\n      const updatedChildren = applyEditAttr(node.children, op);\n      if (!found && updatedChildren !== node.children) {\n        found = true;\n      }\n      return { ...node, children: updatedChildren };\n    }\n    \n    return node;\n  });\n  \n  if (!found) {\n    throw new Error(`Block not found: ${op.blockId}`);\n  }\n  \n  return result;\n}\n\nfunction applyEditContent(nodes: Node[], op: EditContentOperation): Node[] {\n  let found = false;\n  \n  const result = nodes.map(node => {\n    if (node.id === op.blockId) {\n      found = true;\n      \n      // Both ContentNode and ExecutableNode use the content field\n      if ('content' in node) {\n        // Trim whitespace from text content\n        const trimmedContent = trimContent(op.content);\n        return { ...node, content: trimmedContent };\n      }\n      // Node does not have editable content\n      else {\n        throw new Error(`Block ${op.blockId} does not have editable content`);\n      }\n    }\n    \n    if ('children' in node && node.children && node.children.length > 0) {\n      const updatedChildren = applyEditContent(node.children, op);\n      if (!found && updatedChildren !== node.children) {\n        found = true;\n      }\n      return { ...node, children: updatedChildren };\n    }\n    \n    return node;\n  });\n  \n  if (!found) {\n    throw new Error(`Block not found: ${op.blockId}`);\n  }\n  \n  return result;\n}\n\nfunction applyEditParams(nodes: Node[], op: EditParamsOperation): Node[] {\n  let found = false;\n  \n  const result = nodes.map(node => {\n    if (node.id === op.blockId) {\n      found = true;\n      // Only executable nodes have parameters\n      if ('parameters' in node) {\n        return { ...node, parameters: op.params };\n      } else {\n        throw new Error(`Block ${op.blockId} is not an executable node`);\n      }\n    }\n    \n    if ('children' in node && node.children && node.children.length > 0) {\n      const updatedChildren = applyEditParams(node.children, op);\n      if (!found && updatedChildren !== node.children) {\n        found = true;\n      }\n      return { ...node, children: updatedChildren };\n    }\n    \n    return node;\n  });\n  \n  if (!found) {\n    throw new Error(`Block not found: ${op.blockId}`);\n  }\n  \n  return result;\n}\n\nfunction applyEditId(nodes: Node[], op: EditIdOperation): Node[] {\n  let found = false;\n  \n  const result = nodes.map(node => {\n    if (node.id === op.blockId) {\n      found = true;\n      return { ...node, id: op.newId };\n    }\n    \n    if ('children' in node && node.children && node.children.length > 0) {\n      const updatedChildren = applyEditId(node.children, op);\n      if (!found && updatedChildren !== node.children) {\n        found = true;\n      }\n      return { ...node, children: updatedChildren };\n    }\n    \n    return node;\n  });\n  \n  if (!found) {\n    throw new Error(`Block not found: ${op.blockId}`);\n  }\n  \n  return result;\n}\n\nfunction applyInsert(nodes: Node[], op: InsertOperation): Node[] {\n  // Validate position specification\n  const positionCount = [op.atStart, op.atEnd, op.afterBlockId, op.beforeBlockId]\n    .filter(Boolean).length;\n  \n  if (positionCount !== 1) {\n    throw new Error('Insert operation must specify exactly one position');\n  }\n  \n  // Ensure all inserted blocks have IDs\n  const blocksToInsert = op.blocks.map(block => ({\n    ...block,\n    id: block.id || uuidv4(),\n  }));\n\n  if (op.atStart) {\n    return [...blocksToInsert, ...nodes];\n  }\n\n  if (op.atEnd) {\n    return [...nodes, ...blocksToInsert];\n  }\n\n  const result: Node[] = [];\n  let inserted = false;\n\n  for (const node of nodes) {\n    if (op.beforeBlockId && node.id === op.beforeBlockId) {\n      result.push(...blocksToInsert);\n      inserted = true;\n    }\n\n    result.push(node);\n\n    if (op.afterBlockId && node.id === op.afterBlockId) {\n      result.push(...blocksToInsert);\n      inserted = true;\n    }\n  }\n\n  if (!inserted) {\n    throw new Error(`Could not find anchor block for insert operation`);\n  }\n\n  return result;\n}\n\nfunction applyDelete(nodes: Node[], op: DeleteOperation): Node[] {\n  // Remove from top level and recursively from children\n  return nodes\n    .filter(node => node.id !== op.blockId)\n    .map(node => {\n      if ('children' in node && node.children && node.children.length > 0) {\n        return { ...node, children: applyDelete(node.children, op) };\n      }\n      return node;\n    });\n}\n\nfunction applyReplace(nodes: Node[], op: ReplaceOperation): Node[] {\n  // When replacing with a single block, preserve the original ID\n  const replacementBlocks = op.blocks.map((block, index) => {\n    const newId = op.blocks.length === 1 && index === 0 ? op.blockId : (block.id || uuidv4());\n    return {\n      ...block,\n      id: newId,\n    };\n  });\n\n  const result: Node[] = [];\n  let replaced = false;\n\n  for (const node of nodes) {\n    if (node.id === op.blockId) {\n      result.push(...replacementBlocks);\n      replaced = true;\n    } else {\n      result.push(node);\n    }\n  }\n\n  if (!replaced) {\n    throw new Error(`Could not find block ${op.blockId} to replace`);\n  }\n\n  return result;\n}\n\nfunction applyMove(nodes: Node[], op: MoveOperation): Node[] {\n  // Determine what blocks to move\n  let blocksToMove: Node[] = [];\n  let remainingNodes: Node[] = [];\n\n  if (op.blockId) {\n    // Single block move\n    const blockToMove = findNodeById(nodes, op.blockId);\n    if (!blockToMove) {\n      throw new Error(`Block not found: ${op.blockId}`);\n    }\n    blocksToMove = [blockToMove];\n    remainingNodes = nodes.filter(n => n.id !== op.blockId);\n  } else if (op.blockIds) {\n    // Multiple blocks move\n    for (const id of op.blockIds) {\n      const block = findNodeById(nodes, id);\n      if (!block) {\n        throw new Error(`Block not found: ${id}`);\n      }\n      blocksToMove.push(block);\n    }\n    remainingNodes = nodes.filter(n => !op.blockIds!.includes(n.id));\n  } else if (op.fromBlockId && op.toBlockId) {\n    // Range move\n    const fromIndex = nodes.findIndex(n => n.id === op.fromBlockId);\n    const toIndex = nodes.findIndex(n => n.id === op.toBlockId);\n    \n    if (fromIndex === -1) {\n      throw new Error(`Block not found: ${op.fromBlockId}`);\n    }\n    if (toIndex === -1) {\n      throw new Error(`Block not found: ${op.toBlockId}`);\n    }\n    \n    const startIndex = Math.min(fromIndex, toIndex);\n    const endIndex = Math.max(fromIndex, toIndex);\n    \n    blocksToMove = nodes.slice(startIndex, endIndex + 1);\n    remainingNodes = [\n      ...nodes.slice(0, startIndex),\n      ...nodes.slice(endIndex + 1)\n    ];\n  } else {\n    throw new Error('Move operation must specify blockId, blockIds, or fromBlockId/toBlockId');\n  }\n\n  // Now insert the moved blocks at the new position\n  const insertOp: InsertOperation = {\n    type: 'insert',\n    afterBlockId: op.afterBlockId,\n    beforeBlockId: op.beforeBlockId,\n    atStart: op.atStart,\n    atEnd: op.atEnd,\n    blocks: blocksToMove\n  };\n\n  return applyInsert(remainingNodes, insertOp);\n}\n\n// ============================================\n// Helper Functions\n// ============================================\n\nfunction findNodeById(nodes: Node[], id: string): Node | null {\n  for (const node of nodes) {\n    if (node.id === id) {\n      return node;\n    }\n    \n    if ('children' in node && node.children) {\n      const found = findNodeById(node.children, id);\n      if (found) return found;\n    }\n  }\n  \n  return null;\n}\n\n/**\n * Trim whitespace from RichContent array\n */\nfunction trimContent(content: RichContent[]): RichContent[] {\n  if (!content || content.length === 0) {\n    return content || [];\n  }\n  \n  const result = content\n    .filter(item => item != null) // Filter out null/undefined items\n    .map(item => {\n      if (!item || typeof item !== 'object') {\n        console.warn('Invalid content item:', item);\n        return null;\n      }\n      \n      if (item.type === 'text' && 'text' in item) {\n        // Ensure text property exists and is a string\n        const text = String(item.text || '').trim();\n        return {\n          ...item,\n          text\n        };\n      }\n      return item;\n    })\n    .filter(item => item != null); // Remove any nulls from invalid items\n  \n  // Remove empty text items after trimming\n  return result.filter(item => {\n    if (item && item.type === 'text') {\n      return item.text && item.text.length > 0;\n    }\n    return true;\n  });\n}\n\n// Re-export types for convenience\nexport type { EditOperation } from './ast';","/**\n * Lightweight Agent implementation for idyll-engine\n *\n * This is a clean implementation inspired by the app's Agent class\n * but without the database dependencies and app-specific logic.\n */\n\nimport {\n  generateText,\n  streamText,\n  Message,\n  CoreTool,\n  LanguageModel,\n  tool,\n} from \"ai\";\nimport {\n  AgentConfig,\n  AgentDefinition,\n  AgentContext,\n  AgentExecuteOptions,\n  AgentExecuteResult,\n  AgentActivity,\n} from \"./types\";\nimport type { AgentDocument } from \"../document/ast\";\nimport { ActivityMemory } from \"./memory\";\nimport { FunctionRegistry } from \"../document/function-registry\";\nimport { NodeExecutionContext } from \"../document/execution-types\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { buildDetailedSystemPrompt } from \"./system-prompt\";\nimport { extractCustomFunctions } from \"./custom-functions\";\nimport { mergeFunctionRegistries } from \"../document/function-registry\";\nimport { ResponsePipeline, ResponseMiddleware } from \"./response-pipeline\";\nimport {\n  toAzureFunctionName,\n  fromAzureFunctionName,\n} from \"../document/function-naming\";\nimport { Logger, LogLevel } from \"../utils/logger\";\n\ntype GenerateTextOptions = Parameters<typeof generateText>[0];\ntype StreamTextOptions = Parameters<typeof streamText>[0];\n\n/**\n * Agent class for executing conversations with tools\n */\nexport class Agent {\n  private program: AgentDefinition;\n  private model: LanguageModel;\n  private functions: FunctionRegistry;\n  private memory: ActivityMemory;\n  private context: AgentContext;\n  private aiTools: Record<string, CoreTool> = {};\n  private currentMessages: Message[] = [];\n  private responsePipeline: ResponsePipeline;\n  private config: AgentConfig;\n  private logger: Logger;\n\n  constructor(config: AgentConfig) {\n    this.config = config;\n    this.program = config.program;\n    this.model = config.model;\n    this.functions = config.functions;\n\n    // Initialize logger with configuration\n    this.logger = new Logger({\n      prefix: 'Agent',\n      level: config.logging?.level ?? LogLevel.WARN,\n      enableColors: config.logging?.enableColors ?? true,\n      includeTimestamp: config.logging?.includeTimestamp ?? false,\n      ...config.logging,\n    });\n\n    this.memory = new ActivityMemory();\n    this.context = {\n      agentId: this.program.id,\n      activities: [],\n    };\n\n    // Initialize response pipeline\n    this.responsePipeline = new ResponsePipeline();\n    if (config.responseMiddleware) {\n      config.responseMiddleware.forEach((mw) => this.responsePipeline.use(mw));\n    }\n\n    // Initialize AI tools from function registry\n    this.initializeTools();\n  }\n\n  /**\n   * Initialize tools for AI SDK (converts functions to AI tools)\n   */\n  private initializeTools() {\n    // Extract custom functions from agent program\n    this.logger.debug(\n      `Initializing tools, agent program has nodes: ${this.program.nodes.length}`\n    );\n    this.logger.debug(\n      `Node types: ${this.program.nodes.map((n) => n.type).join(', ')}`\n    );\n    const customTools = extractCustomFunctions(\n      this.program,\n      this.functions,\n      () => {\n        // Get the last user message as agent context\n        const lastUserMessage = this.currentMessages\n          .filter((m) => m.role === \"user\")\n          .pop();\n        return typeof lastUserMessage?.content === \"string\"\n          ? lastUserMessage.content\n          : JSON.stringify(lastUserMessage?.content || \"\");\n      },\n      this.config.customFunctionExecutor // Pass the custom executor\n    );\n\n    // Merge base functions with custom functions\n    this.logger.debug(`Custom tools extracted: ${Object.keys(customTools).join(', ')}`);\n    const allTools = mergeFunctionRegistries(this.functions, customTools);\n    this.logger.debug(\n      `All tools after merge: ${Object.keys(allTools).length} tools (${Object.keys(allTools).join(', ')})`\n    );\n\n    // Convert all functions to AI SDK tool format\n    for (const [name, functionDef] of Object.entries(allTools)) {\n      // Transform function name to be OpenAI-compatible using Azure adapter pattern\n      const aiToolName = toAzureFunctionName(name);\n\n      \n      // Create AI SDK tool wrapper for the function\n      const createdTool = tool({\n        description: functionDef.description || \"\",\n        parameters: functionDef.schema,\n        execute: async (params: any) => {\n          this.logger.execution(`Executing function: ${name}`);\n\n          // Create execution context\n          const context: NodeExecutionContext = {\n            currentNodeId: uuidv4(),\n            previousResults: new Map(),\n            document: { id: this.program.id, nodes: this.program.nodes } as any,\n          };\n\n          try {\n            // Execute function\n            const content = params.content || \"\";\n            delete params.content; // Remove content from params\n\n            const result = await functionDef.execute(params, content, context);\n\n            // Process response through middleware pipeline\n            const finalResult = await this.responsePipeline.process({\n              functionName: name,\n              params: params,\n              result: result,\n              messages: this.currentMessages.slice(-3),\n            });\n\n            const isCustomFunction = name.startsWith(\"custom:\");\n            if (isCustomFunction) {\n              this.logger.function(`Custom function ${name} executed and compressed`);\n            }\n\n            // Track function call in activity memory\n            this.memory.add({\n              type: \"tool\",\n              functionCalls: [\n                {\n                  name,\n                  args: params,\n                  result: finalResult,\n                },\n              ],\n            });\n\n            return finalResult;\n          } catch (error) {\n            const errorMessage =\n              error instanceof Error ? error.message : \"Unknown error\";\n\n            // Track error\n            this.memory.add({\n              type: \"tool\",\n              functionCalls: [\n                {\n                  name,\n                  args: params,\n                },\n              ],\n              error: errorMessage,\n            });\n\n            throw error;\n          }\n        },\n      });\n      \n      if (name === 'documents:create') {\n        this.logger.debug(`Created tool: ${name}`);\n        this.logger.debug(`Tool parameters:`, createdTool.parameters);\n      }\n      \n      this.aiTools[aiToolName] = createdTool;\n    }\n  }\n\n  /**\n   * Get the system prompt with memory injection\n   */\n  private getSystemPrompt(): string {\n    const memoryContext = this.memory.formatForPrompt();\n    const functionNames = Object.keys(this.aiTools);\n\n    const systemPrompt = buildDetailedSystemPrompt(\n      this.program,\n      functionNames,\n      memoryContext\n    );\n\n    this.logger.debug(\n      `System prompt generated (${systemPrompt.length} chars)`\n    );\n    this.logger.debug(\n      `System prompt contains response_guidelines: ${systemPrompt.includes(\"response_guidelines\")}`\n    );\n    this.logger.debug(\n      `Available functions in system prompt: ${functionNames.filter((name) => name.startsWith(\"custom\")).join(\", \")}`\n    );\n\n    return systemPrompt;\n  }\n\n  /**\n   * Execute a chat message (non-streaming)\n   */\n  async chat(\n    messages: Message[],\n    options?: GenerateTextOptions\n  ): Promise<AgentExecuteResult> {\n    // Store current messages for context\n    this.currentMessages = messages;\n\n    const userMessage = messages[messages.length - 1]?.content;\n\n    // Debug: Check if options contains tools\n    if (options && 'tools' in options) {\n      this.logger.warn('chat() received options with tools property!', options.tools);\n    }\n\n    try {\n      // Add to memory\n      const activity = this.memory.add({\n        type: \"chat\",\n        userMessage:\n          typeof userMessage === \"string\"\n            ? userMessage\n            : JSON.stringify(userMessage),\n      });\n\n      // Debug: Log what we're passing to generateText\n      this.logger.debug(`About to call generateText with tools: ${Object.keys(this.aiTools).join(', ')}`);\n      if (this.aiTools['documents--create']) {\n        this.logger.debug('documents--create tool in generateText:', this.aiTools['documents--create']);\n      }\n      \n      const result = await generateText({\n        ...options,\n        model: this.model,\n        system: this.getSystemPrompt(),\n        messages,\n        tools: this.aiTools,\n        toolChoice: \"auto\",\n        maxSteps: options?.maxSteps ?? 10,\n        temperature: options?.temperature ?? 0.7,\n      });\n\n      // Update activity with response\n      activity.assistantMessage = result.text;\n      activity.usage = result.usage;\n      if (result.toolCalls && result.toolCalls.length > 0) {\n        activity.functionCalls = result.toolCalls.map((tc) => ({\n          name: tc.toolName,\n          args: tc.args as Record<string, any>,\n        }));\n      }\n\n      return {\n        message: {\n          id: uuidv4(),\n          role: \"assistant\",\n          content: result.text,\n          createdAt: new Date(),\n        },\n        usage: result.usage,\n        finishReason: result.finishReason,\n      };\n    } catch (error) {\n      // Track error\n      this.memory.add({\n        type: \"chat\",\n        userMessage:\n          typeof userMessage === \"string\"\n            ? userMessage\n            : JSON.stringify(userMessage),\n        error: error instanceof Error ? error.message : \"Unknown error\",\n      });\n\n      throw error;\n    }\n  }\n\n  /**\n   * Execute a chat message (streaming)\n   * Returns streamText result that can be used with toDataStreamResponse()\n   */\n  async chatStream(messages: Message[], options?: StreamTextOptions) {\n    const userMessage = messages[messages.length - 1]?.content;\n\n    try {\n      // Add to memory\n      const activity = this.memory.add({\n        type: \"chat\",\n        userMessage:\n          typeof userMessage === \"string\"\n            ? userMessage\n            : JSON.stringify(userMessage),\n      });\n\n      // Debug tools before calling streamText\n      this.logger.debug(`About to call streamText with tools: ${Object.keys(this.aiTools).join(', ')}`);\n      if (this.aiTools['documents--create']) {\n        this.logger.debug('documents--create tool:', this.aiTools['documents--create']);\n        this.logger.debug('documents--create parameters:', this.aiTools['documents--create'].parameters);\n      }\n      \n      const result = await streamText({\n        ...options,\n        model: this.model,\n        system: this.getSystemPrompt(),\n        messages,\n        tools: this.aiTools,\n        toolChoice: \"auto\",\n        maxSteps: options?.maxSteps ?? 10,\n        temperature: options?.temperature ?? 0.7,\n        onFinish: async ({ text, toolCalls, usage, finishReason }) => {\n          this.logger.info(\n            `Final finish - reason: ${finishReason}, text length: ${text.length}, functionCalls: ${toolCalls?.length || 0}`\n          );\n\n          // Update activity when stream finishes\n          activity.assistantMessage = text;\n          if (toolCalls && toolCalls.length > 0) {\n            activity.functionCalls = toolCalls.map((tc) => ({\n              name: fromAzureFunctionName(tc.toolName),\n              args: tc.args,\n            }));\n          }\n\n          // Call the external onFinish callback if provided\n          if (options?.onFinish) {\n            await options.onFinish({\n              text,\n              // @ts-ignore\n              functionCalls: toolCalls?.map((tc) => ({\n                ...tc,\n                functionName: fromAzureFunctionName(tc.toolName),\n              })),\n              usage,\n              finishReason,\n            });\n          }\n        },\n      });\n\n      return result;\n    } catch (error) {\n      // Track error\n      this.memory.add({\n        type: \"chat\",\n        userMessage:\n          typeof userMessage === \"string\"\n            ? userMessage\n            : JSON.stringify(userMessage),\n        error: error instanceof Error ? error.message : \"Unknown error\",\n      });\n\n      throw error;\n    }\n  }\n\n  /**\n   * Get memory/activity history\n   */\n  getMemory(): ActivityMemory {\n    return this.memory;\n  }\n\n  /**\n   * Get agent context\n   */\n  getContext(): AgentContext {\n    return {\n      ...this.context,\n      activities: this.memory.toJSON(),\n    };\n  }\n\n  /**\n   * Clear memory\n   */\n  clearMemory(): void {\n    this.memory.clear();\n  }\n}\n","/**\n * In-memory activity tracking for agents\n */\n\nimport { formatDistanceToNow } from 'date-fns';\nimport { AgentActivity } from './types';\n\n/**\n * Simple in-memory activity store\n */\nexport class ActivityMemory {\n  private activities: AgentActivity[] = [];\n  private maxSize: number;\n\n  constructor(maxSize = 20) {\n    this.maxSize = maxSize;\n  }\n\n  /**\n   * Add an activity record\n   */\n  add(activity: Omit<AgentActivity, 'id' | 'timestamp'>): AgentActivity {\n    const record: AgentActivity = {\n      ...activity,\n      id: crypto.randomUUID(),\n      timestamp: new Date(),\n    };\n\n    this.activities.unshift(record);\n    \n    // Keep only maxSize records\n    if (this.activities.length > this.maxSize) {\n      this.activities = this.activities.slice(0, this.maxSize);\n    }\n\n    return record;\n  }\n\n  /**\n   * Get recent activities\n   */\n  getRecent(limit?: number): AgentActivity[] {\n    return limit ? this.activities.slice(0, limit) : this.activities;\n  }\n\n  /**\n   * Clear all activities\n   */\n  clear(): void {\n    this.activities = [];\n  }\n\n  /**\n   * Format activities as memory context for agent\n   */\n  formatForPrompt(limit = 10): string {\n    const recent = this.getRecent(limit);\n    \n    if (recent.length === 0) {\n      return '';\n    }\n\n    const formatted = recent.map(activity => {\n      const timeAgo = formatDistanceToNow(activity.timestamp, { addSuffix: true });\n      const parts = [`[${timeAgo}] ${activity.type}`];\n      \n      if (activity.userMessage) {\n        parts.push(`User: \"${activity.userMessage.substring(0, 100)}${activity.userMessage.length > 100 ? '...' : ''}\"`);\n      }\n      \n      if (activity.assistantMessage) {\n        parts.push(`Assistant: \"${activity.assistantMessage.substring(0, 100)}${activity.assistantMessage.length > 100 ? '...' : ''}\"`);\n      }\n      \n      if (activity.functionCalls && activity.functionCalls.length > 0) {\n        parts.push(`Functions: ${activity.functionCalls.map(tc => tc.name).join(', ')}`);\n      }\n      \n      if (activity.error) {\n        parts.push(`Error: ${activity.error}`);\n      }\n      \n      return parts.join(' | ');\n    }).join('\\n');\n\n    return `<recent_activity>\n${formatted}\n</recent_activity>`;\n  }\n\n  /**\n   * Get activities as JSON\n   */\n  toJSON(): AgentActivity[] {\n    return this.activities;\n  }\n}","/**\n * System prompt builder for agents\n * \n * Converts AgentDocument to a proper system prompt with:\n * - Background context\n * - Tool definitions\n * - Custom instructions from nodes\n */\n\nimport { AgentDocument, Node, isExecutableNode, isTextContent } from '../document/ast';\nimport { serializeAstToXml } from '../grammar/parser';\n\n/**\n * Build system prompt from agent document\n */\nexport function buildSystemPrompt(agent: AgentDocument, availableTools: string[]): string {\n  const sections: string[] = [];\n  \n  // Agent identity\n  sections.push(`You are ${agent.name || 'an AI assistant'}.`);\n  if (agent.description) {\n    sections.push(agent.description);\n  }\n  \n  // Model info\n  sections.push(`\\nModel: ${agent.model || 'default'}`);\n  \n  // Available functions (shown as tools to the AI)\n  if (availableTools.length > 0) {\n    sections.push(`\\nAvailable tools:\\n${availableTools.map(t => `- ${t}`).join('\\n')}`);\n  }\n  \n  // Process blocks for custom instructions and function definitions\n  const instructions: string[] = [];\n  const customTools: string[] = [];\n  const triggers: string[] = [];\n  \n  for (const node of agent.nodes) {\n    if (node.type === 'function') {\n      // Extract function definition\n      const title = node.props?.title as string || 'Untitled Function';\n      // Convert title to the actual function name used in the registry\n      const functionName = title\n        .toLowerCase()\n        .replace(/[^a-z0-9]+/g, '_')\n        .replace(/^_+|_+$/g, '');\n      // The actual callable name uses -- instead of :\n      const callableName = `custom--${functionName}`;\n      customTools.push(`- ${callableName} (Custom function: \"${title}\")`);\n    } else if (node.type === 'trigger') {\n      // Note triggers\n      const trigger = node.props?.trigger as string;\n      if (trigger) {\n        triggers.push(`Trigger: ${trigger}`);\n      }\n    } else if ('content' in node && node.content) {\n      // Extract text content as instructions\n      const text = extractTextFromBlock(node);\n      if (text) {\n        instructions.push(text);\n      }\n    }\n  }\n  \n  // Add custom functions section\n  if (customTools.length > 0) {\n    sections.push(`\\nCustom functions defined:\\n${customTools.join('\\n')}\\n\\nIMPORTANT: When the user asks you to use a custom function by name, find the matching function in the available tools list and call it. Custom function names use double hyphens (--) instead of colons (:) when calling them.`);\n  }\n  \n  // Add triggers section\n  if (triggers.length > 0) {\n    sections.push(`\\nTriggers configured:\\n${triggers.join('\\n')}`);\n  }\n  \n  // Add instructions\n  if (instructions.length > 0) {\n    sections.push(`\\nInstructions:\\n${instructions.join('\\n\\n')}`);\n  }\n  \n  // Add XML context for understanding the format\n  sections.push(`\\nWhen working with documents, use the Idyllic XML format.`);\n  \n  return sections.join('\\n');\n}\n\n/**\n * Extract plain text from a node\n */\nfunction extractTextFromBlock(node: Node): string {\n  if (!('content' in node) || !node.content) {\n    return '';\n  }\n  \n  const texts: string[] = [];\n  \n  for (const content of node.content) {\n    if (isTextContent(content)) {\n      texts.push(content.text);\n    }\n  }\n  \n  return texts.join('');\n}\n\n/**\n * Create a more detailed prompt with XML examples\n */\nexport function buildDetailedSystemPrompt(\n  agent: AgentDocument, \n  availableTools: string[],\n  includeMemory?: string\n): string {\n  let prompt = buildSystemPrompt(agent, availableTools);\n  \n  // Add memory if provided\n  if (includeMemory) {\n    prompt = `${prompt}\\n\\n${includeMemory}`;\n  }\n  \n  // Add document structure explanation\n  prompt += `\\n\\n<document_format>\nDocuments are structured using XML with blocks like:\n- <p> for paragraphs\n- <h1>, <h2>, etc. for headings\n- <fncall idyll-fn=\"...\"> for function execution\n- <variable name=\"...\" /> for variables\n- <mention:type id=\"...\">label</mention:type> for references\n</document_format>\n\n<response_guidelines>\nWhen responding to user queries:\n1. If you need to call functions, call them first\n2. After function calls complete, provide ONE clear, comprehensive response\n3. Do not repeat or rephrase the same information multiple times\n4. Only continue with additional steps if you need to call different functions or perform distinct reasoning\n5. Avoid generating multiple similar responses about the same topic\n</response_guidelines>`;\n  \n  return prompt;\n}","/**\n * Custom function extraction for agents\n * \n * Extracts custom function definitions from agent documents\n * and converts them into tools that agents can call.\n */\n\nimport { z } from 'zod';\nimport { AgentDocument, Node, ContentNode } from '../document/ast';\nimport { FunctionDefinition, FunctionRegistry } from '../document/function-registry';\nimport { executeCustomFunction, parseCustomFunction, AgentCustomFunctionExecutionOptions } from '../document/custom-function-executor';\nimport { parseXmlToAst } from '../grammar/parser';\nimport { createLogger, LogLevel } from '../utils/logger';\n\n/**\n * Extract custom functions from agent document and convert them to tools\n */\nexport function extractCustomFunctions(\n  agentDoc: AgentDocument,\n  baseFunctions: FunctionRegistry,\n  getAgentContext?: () => string,\n  customFunctionExecutor?: any\n): FunctionRegistry {\n  const customFunctions: FunctionRegistry = {};\n  const logger = createLogger('CustomFunctions', LogLevel.WARN);\n  \n  logger.debug('Extracting custom functions from agent document...');\n  \n  // Find all function blocks\n  for (const block of agentDoc.nodes) {\n    if (block.type === 'function' && 'props' in block) {\n      logger.debug('Found function block:', JSON.stringify(block, null, 2));\n      const title = block.props?.title as string || 'Untitled Function';\n      const icon = block.props?.icon as string;\n      \n      // Extract description from content\n      const description = extractTextContent(block);\n      \n      // Extract function definition blocks from children\n      const definitionBlocks = extractFunctionDefinitionBlocks(block);\n      \n      logger.debug(`Extracted ${definitionBlocks.length} definition blocks from function \"${title}\"`);\n      logger.debug('Definition blocks:', JSON.stringify(definitionBlocks, null, 2));\n      \n      if (definitionBlocks.length === 0) {\n        logger.warn(`Function \"${title}\" has no definition blocks`);\n        continue;\n      }\n      \n      // Convert title to valid function name (snake_case)\n      const functionName = title\n        .toLowerCase()\n        .replace(/[^a-z0-9]+/g, '_')\n        .replace(/^_+|_+$/g, '');\n      \n      // Create the tool from this custom function\n      customFunctions[`custom:${functionName}`] = {\n        description: description || `Custom function: ${title}`,\n        schema: z.object({\n          context: z.string()\n            .describe('Relevant context to help resolve any variables in the function')\n            .optional(),\n        }),\n        execute: async (params, content, context) => {\n          logger.debug(`Executing custom function: ${title}`);\n          \n          // Create a virtual document with the function definition\n          const functionDoc = {\n            id: `custom-function-${functionName}`,\n            nodes: definitionBlocks,\n          };\n          \n          // Create custom function block for execution\n          const customFunctionBlock: ContentNode = {\n            id: context.currentNodeId || 'custom-function-exec',\n            type: 'function',\n            content: [],\n            children: definitionBlocks,\n            props: { title, icon },\n          };\n          \n          // Build agent context from params and content\n          // The AI typically passes context in params.context or uses content\n          let agentContext = '';\n          if (params.context) {\n            agentContext = params.context;\n          } else if (content) {\n            agentContext = content;\n          } else if (getAgentContext) {\n            // Use the agent context getter if provided\n            agentContext = getAgentContext();\n          } else {\n            // Try to infer from the execution context\n            agentContext = `Function invoked: ${title}`;\n          }\n          \n          logger.debug(`Agent context for variable resolution: \"${agentContext}\"`);\n          logger.debug(`Params:`, params);\n          logger.debug(`Content:`, content);\n          logger.debug(`GetAgentContext available:`, !!getAgentContext);\n          \n          try {\n            // Execute the custom function\n            const executionOptions: AgentCustomFunctionExecutionOptions = {\n              functions: baseFunctions,\n              agentContext: agentContext,\n            };\n            \n            // Use custom executor if provided, otherwise use default\n            const executionContext = customFunctionExecutor \n              ? await customFunctionExecutor.execute(customFunctionBlock, executionOptions)\n              : await executeCustomFunction(customFunctionBlock, executionOptions);\n            \n            // Extract the final result\n            const lastNodeId = Array.from(executionContext.nodes.keys()).pop();\n            const lastResult = lastNodeId ? executionContext.nodes.get(lastNodeId) : undefined;\n            \n            logger.debug(`Execution complete. Last node ID: ${lastNodeId}`);\n            logger.debug(`Last result:`, lastResult);\n            logger.debug(`All nodes:`, Array.from(executionContext.nodes.entries()));\n            \n            // Check if we have any successful results\n            const results = Array.from(executionContext.nodes.values());\n            const successfulResults = results.filter((r: any) => r.success);\n            const failedResults = results.filter((r: any) => !r.success);\n            \n            logger.debug(`Execution summary: ${successfulResults.length} successful, ${failedResults.length} failed`);\n            \n            // If we have successful results, return the full context for compression\n            if (successfulResults.length > 0) {\n              logger.debug(`Returning full FunctionExecutionReport for compression`);\n              return executionContext;\n            }\n            \n            // If everything failed, throw the last error\n            if (lastResult && !lastResult.success) {\n              const errorMsg = typeof lastResult.error === 'string' \n                ? lastResult.error \n                : JSON.stringify(lastResult.error) || 'Function execution failed';\n              throw new Error(errorMsg);\n            }\n            \n            // Fallback\n            return executionContext;\n          } catch (error) {\n            logger.error(`Custom function \"${title}\" failed:`, error);\n            throw error;\n          }\n        },\n      };\n    }\n  }\n  \n  return customFunctions;\n}\n\n/**\n * Extract text content from a block\n */\nfunction extractTextContent(block: Node): string {\n  if (!('content' in block) || !block.content) {\n    return '';\n  }\n  \n  const texts: string[] = [];\n  for (const content of block.content) {\n    if (content.type === 'text') {\n      texts.push(content.text);\n    }\n  }\n  \n  return texts.join('').trim();\n}\n\n/**\n * Extract function definition blocks from a function block\n * \n * Function blocks have a structure like:\n * <function>\n *   <function:description>text content</function:description>\n *   <function:definition>\n *     <p>...</p>\n *     <fncall>...</fncall>\n *   </function:definition>\n * </function>\n */\nfunction extractFunctionDefinitionBlocks(functionBlock: Node): Node[] {\n  if (!('children' in functionBlock) || !functionBlock.children) {\n    return [];\n  }\n  \n  const definitionBlocks: Node[] = [];\n  \n  for (const child of functionBlock.children) {\n    // Look for blocks with specific types from our parser\n    if ('type' in child) {\n      // The parser converts <function:definition> to a block with type 'function:definition'\n      // But we need to check the actual parsed structure\n      if (child.type === 'paragraph' || child.type === 'function_call') {\n        definitionBlocks.push(child);\n      } else if ('children' in child && child.children) {\n        // Recursively extract from nested structures\n        definitionBlocks.push(...extractFunctionDefinitionBlocks(child));\n      }\n    }\n  }\n  \n  return definitionBlocks;\n}","/**\n * Configurable logging system for idyll-engine\n * \n * This replaces console.log calls with a proper logger that can be\n * configured or disabled for production use.\n */\n\nexport enum LogLevel {\n  DEBUG = 0,\n  INFO = 1,\n  WARN = 2,\n  ERROR = 3,\n  SILENT = 4,\n}\n\nexport interface LoggerConfig {\n  level: LogLevel;\n  enableColors: boolean;\n  includeTimestamp: boolean;\n  prefix?: string;\n}\n\nexport class Logger {\n  private config: LoggerConfig;\n  \n  constructor(config: Partial<LoggerConfig> = {}) {\n    this.config = {\n      level: LogLevel.WARN, // Default to WARN for production\n      enableColors: true,\n      includeTimestamp: false,\n      ...config,\n    };\n  }\n\n  private shouldLog(level: LogLevel): boolean {\n    return level >= this.config.level;\n  }\n\n  private formatMessage(level: LogLevel, message: string, ...args: any[]): string {\n    const prefix = this.config.prefix ? `[${this.config.prefix}] ` : '';\n    const timestamp = this.config.includeTimestamp ? `${new Date().toISOString()} ` : '';\n    \n    let levelStr = '';\n    if (this.config.enableColors) {\n      switch (level) {\n        case LogLevel.DEBUG:\n          levelStr = '\\x1b[36mDEBUG\\x1b[0m'; // Cyan\n          break;\n        case LogLevel.INFO:\n          levelStr = '\\x1b[34mINFO\\x1b[0m'; // Blue\n          break;\n        case LogLevel.WARN:\n          levelStr = '\\x1b[33mWARN\\x1b[0m'; // Yellow\n          break;\n        case LogLevel.ERROR:\n          levelStr = '\\x1b[31mERROR\\x1b[0m'; // Red\n          break;\n      }\n    } else {\n      levelStr = LogLevel[level];\n    }\n\n    return `${timestamp}${prefix}${levelStr}: ${message}`;\n  }\n\n  debug(message: string, ...args: any[]): void {\n    if (this.shouldLog(LogLevel.DEBUG)) {\n      console.log(this.formatMessage(LogLevel.DEBUG, message), ...args);\n    }\n  }\n\n  info(message: string, ...args: any[]): void {\n    if (this.shouldLog(LogLevel.INFO)) {\n      console.log(this.formatMessage(LogLevel.INFO, message), ...args);\n    }\n  }\n\n  warn(message: string, ...args: any[]): void {\n    if (this.shouldLog(LogLevel.WARN)) {\n      console.warn(this.formatMessage(LogLevel.WARN, message), ...args);\n    }\n  }\n\n  error(message: string, ...args: any[]): void {\n    if (this.shouldLog(LogLevel.ERROR)) {\n      console.error(this.formatMessage(LogLevel.ERROR, message), ...args);\n    }\n  }\n\n  // Convenience methods for common patterns\n  execution(message: string, ...args: any[]): void {\n    this.debug(`🔧 ${message}`, ...args);\n  }\n\n  agent(message: string, ...args: any[]): void {\n    this.debug(`[Agent] ${message}`, ...args);\n  }\n\n  function(message: string, ...args: any[]): void {\n    this.debug(`🎯 ${message}`, ...args);\n  }\n\n  // Update configuration\n  setLevel(level: LogLevel): void {\n    this.config.level = level;\n  }\n\n  setConfig(config: Partial<LoggerConfig>): void {\n    this.config = { ...this.config, ...config };\n  }\n}\n\n// Global logger instance\nexport const logger = new Logger();\n\n// Development helper - can be removed in production builds\nexport const createLogger = (prefix: string, level: LogLevel = LogLevel.WARN): Logger => {\n  return new Logger({ prefix, level });\n};","/**\n * Response Pipeline System\n * \n * Provides middleware-based processing of function execution results\n * before they are returned to the agent conversation loop.\n */\n\nimport { Message } from 'ai';\n\n/**\n * Context provided to middleware for processing function results\n */\nexport interface MiddlewareContext {\n  /** Name of the function that was executed */\n  functionName: string;\n  \n  /** Parameters passed to the function */\n  params: any;\n  \n  /** The raw result from function execution */\n  result: any;\n  \n  /** Recent conversation messages for context-aware processing */\n  messages?: Message[];\n}\n\n/**\n * Middleware interface for processing function results\n */\nexport interface ResponseMiddleware {\n  /** Unique name for the middleware */\n  name: string;\n  \n  /** Process the function result and return the modified result */\n  process(context: MiddlewareContext): Promise<any>;\n}\n\n/**\n * Pipeline that processes function results through a chain of middleware\n */\nexport class ResponsePipeline {\n  private middleware: ResponseMiddleware[] = [];\n  \n  /**\n   * Add middleware to the pipeline\n   */\n  use(middleware: ResponseMiddleware): void {\n    this.middleware.push(middleware);\n  }\n  \n  /**\n   * Process a function result through all middleware in order\n   */\n  async process(context: MiddlewareContext): Promise<any> {\n    let result = context.result;\n    \n    // Process through each middleware sequentially\n    for (const mw of this.middleware) {\n      try {\n        // Update the context with the current result for the next middleware\n        const updatedContext = { ...context, result };\n        result = await mw.process(updatedContext);\n      } catch (error) {\n        console.error(`[ResponsePipeline] Error in middleware ${mw.name}:`, error);\n        // Continue with the current result if middleware fails\n      }\n    }\n    \n    return result;\n  }\n  \n  /**\n   * Check if any middleware is configured\n   */\n  hasMiddleware(): boolean {\n    return this.middleware.length > 0;\n  }\n  \n  /**\n   * Get list of configured middleware names\n   */\n  getMiddlewareNames(): string[] {\n    return this.middleware.map(mw => mw.name);\n  }\n}"],"mappings":"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","names":["terminal","compiled","z","z","z","validateDocument","uuidv4","uuidv4","uuidv4","z","LogLevel","logger","extractTextContent","z","uuidv4"]}